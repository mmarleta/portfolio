{
  "nav": {
    "projects": "Projetos",
    "stack": "Stack",
    "about": "Sobre",
    "backToPortfolio": "Voltar ao Portfolio",
    "back": "Voltar"
  },
  "hero": {
    "title": "Marcelo Marleta",
    "subtitle": "Senior Backend & AI Engineer",
    "description": "Arquiteturas de conversa√ß√£o enterprise com LangGraph, RAG otimizado e sistemas multi-tenant. Foco em separa√ß√£o de l√≥gica determin√≠stica e linguagem natural.",
    "github": "GitHub",
    "linkedin": "LinkedIn"
  },
  "projects": {
    "title": "Projetos",
    "description": "Sistemas de produ√ß√£o com foco em IA conversacional, processamento de documentos e ferramentas de desenvolvimento.",
    "optimusPlatform": "Optimus Platform",
    "otherProjects": "Outros Projetos",
    "viewMore": "Ver Todos os Projetos"
  },
  "stack": {
    "title": "Stack",
    "backend": "Backend",
    "ai": "AI/ML",
    "infra": "Infra"
  },
  "cta": {
    "wantToSeeMore": "Quer ver mais projetos?",
    "exploreOther": "Explore tamb√©m outros case studies no meu portfolio."
  },
  "common": {
    "fullStack": "Full-Stack Platform",
    "realTime": "Real-time",
    "multiPlatform": "Multi-Platform",
    "back": "‚Üê Voltar",
    "technicalStack": "Stack T√©cnica",
    "next": "Pr√≥ximo",
    "personalProject": "Projeto Pessoal",
    "exploreOtherProjects": "Explore Outros Projetos",
    "seeOtherSystems": "Veja outros sistemas que constru√≠",
    "viewAllProjects": "Ver Todos os Projetos"
  },
  "cards": {
    "aiEngine": {
      "title": "AI Conversation Engine",
      "description": "LangGraph + FSM para separa√ß√£o de l√≥gica determin√≠stica e linguagem natural. 20+ n√≥s especializados, 8 estados de booking."
    },
    "llmPool": {
      "title": "LLM Pool Management",
      "description": "Pools separados chat vs tools, key groups com vault criptografado, rota√ß√£o autom√°tica e fallback inteligente. 40% redu√ß√£o de custos."
    },
    "pricing": {
      "title": "Pricing Intelligence",
      "description": "RAG otimizado com threshold adaptativo, request coalescing e cache multi-tier. 95% precision, <100ms cache hit."
    },
    "memory": {
      "title": "Memory Engine",
      "description": "Sistema hier√°rquico Hot/Warm/Cold com compress√£o sem√¢ntica (90% redu√ß√£o), compliance LGPD/HIPAA autom√°tico e context injection."
    },
    "backend": {
      "title": "Backend Orchestrator",
      "description": "Central hub FastAPI com fail-closed design, tenant isolation, handover atendente, circuit breakers."
    },
    "rules": {
      "title": "Rules Engine",
      "description": "Python Lambda DSL para regras de neg√≥cio, fast-lane patterns, coordena√ß√£o backend + AI engine."
    },
    "whatsapp": {
      "title": "WhatsApp Integration",
      "description": "Redis isolado, webhook processing, WebSocket broadcaster, integra√ß√£o Memory Engine para hist√≥rico."
    },
    "audio": {
      "title": "Audio Processor",
      "description": "Multi-provider STT/TTS (Whisper, ElevenLabs, Azure), async processing com Celery, formatos diversos."
    },
    "observability": {
      "title": "Observability",
      "description": "Prometheus + OpenTelemetry + structlog. Distributed tracing, m√©tricas customizadas, dashboards."
    },
    "frontend": {
      "title": "Frontend Apps",
      "description": "Admin Dashboard (3000) + SuperAdmin Panel (3001). Vue.js 3, WebSocket real-time, handover management, RBAC."
    },
    "testTools": {
      "title": "AI Testing Tools",
      "description": "Hallucination detector, quality scorer, cen√°rios real√≠sticos com personalidades, interface de simula√ß√£o multi-canal."
    },
    "infraDevops": {
      "title": "Infra & DevOps",
      "description": "Docker Compose overlays, Nginx LB com scaling horizontal, Redis Sentinel HA, CI/CD com guardrails de arquitetura."
    },
    "architecture": {
      "title": "Arquitetura Completa",
      "description": "Vis√£o geral da plataforma: 4 microservi√ßos, multi-tenant, integra√ß√£o WhatsApp, Memory Engine hier√°rquico."
    },
    "mcp": {
      "title": "MCP Servers",
      "description": "Servidores Model Context Protocol para Claude Code. Debugging, valida√ß√£o arquitetural e navega√ß√£o de codebase."
    },
    "automark": {
      "title": "AutoMark Platform",
      "description": "SaaS multi-tenant de distribui√ß√£o de ofertas afiliadas. Shopee ‚Üí WhatsApp com anti-spam, scoring e dedupe."
    },
    "icontei": {
      "title": "iContei",
      "description": "Rede social de contadores compartilh√°veis. Next.js 16, FastAPI, WebSocket real-time, verifica√ß√£o por IA, rankings com Redis."
    },
    "gratidiem": {
      "title": "GratiDiem",
      "description": "App Flutter de gratid√£o com 508+ arquivos, 6 plataformas. Riverpod, dual persistence (Hive+Firebase), IA com Gemini."
    },
    "pvcoach": {
      "title": "PVCoach",
      "description": "Chess coach com Stockfish + LLM. MultiPV analysis, explica√ß√µes grounded, hints progressivos."
    },
    "feedRss": {
      "title": "Feed-RSS Monitor",
      "description": "Pipeline de automa√ß√£o de conte√∫do: RSS ‚Üí Filter ‚Üí OpenAI ‚Üí Telegram/Discord. Roteiros de Shorts gerados automaticamente."
    }
  },
  "cases": {
    "automark": {
      "meta": {
        "title": "AutoMark - Affiliate Marketing Platform | Marcelo Marleta",
        "description": "Case study: Plataforma SaaS multi-tenant de distribui√ß√£o inteligente de ofertas afiliadas. Shopee, WhatsApp, anti-spam, scoring inteligente."
      },
      "header": {
        "back": "Voltar",
        "projectType": "Projeto Pessoal"
      },
      "hero": {
        "tag1": "SaaS Platform",
        "tag2": "Affiliate Marketing",
        "title": "AutoMark",
        "titleHighlight": " Platform",
        "description": "Plataforma SaaS multi-tenant de distribui√ß√£o inteligente de ofertas afiliadas. Conecta marketplaces (Shopee, ML, Amazon) a canais (WhatsApp, Telegram) com automa√ß√µes anti-spam, scoring inteligente e deduplica√ß√£o.",
        "stat1Value": "Multi",
        "stat1Label": "Marketplace",
        "stat2Value": "Multi",
        "stat2Label": "Channel",
        "stat3Value": "48h",
        "stat3Label": "Dedupe Target",
        "stat4Value": "0",
        "stat4Label": "Spam/Ban"
      },
      "nav": {
        "problem": "Problema",
        "architecture": "Arquitetura",
        "providers": "Providers",
        "scoring": "Scoring",
        "dedupe": "Dedupe",
        "antiBan": "Anti-Ban",
        "automations": "Automa√ß√µes",
        "stack": "Stack"
      },
      "problem": {
        "title": "O Problema",
        "intro": "Afiliados enfrentam tr√™s problemas cr√≠ticos na distribui√ß√£o de ofertas:",
        "issue1Title": "Distribui√ß√£o manual n√£o escala:",
        "issue1Desc": "Postar links manualmente em grupos gera repeti√ß√£o, spam e ban. Tempo gasto vs convers√£o n√£o compensa.",
        "issue2Title": "Marketplaces s√£o fragmentados:",
        "issue2Desc": "Shopee, Mercado Livre, Amazon t√™m APIs diferentes, formatos diferentes, regras de afiliado diferentes.",
        "issue3Title": "WhatsApp pune comportamento rob√≥tico:",
        "issue3Desc": "Sem controle de cad√™ncia, dedupe e humaniza√ß√£o: shadow ban, bloqueio, queda de engajamento.",
        "objectiveTitle": "üéØ Objetivo",
        "objectiveDesc": "Criar uma plataforma que pare√ßa humana, poste o que converte, no lugar certo, na hora certa, sem spam."
      },
      "architecture": {
        "title": "Arquitetura Multi-Tenant",
        "intro": "A arquitetura segue princ√≠pios r√≠gidos que permitem evolu√ß√£o sem breaking changes:",
        "principle1Title": "Marketplace nunca hardcoded",
        "principle1Desc": "Shopee √© o primeiro conector, mas ML, Amazon, AliExpress s√£o plug-and-play.",
        "principle2Title": "Canal nunca hardcoded",
        "principle2Desc": "WhatsApp √© o primeiro, mas Telegram, Discord, Instagram seguem a mesma interface.",
        "principle3Title": "Automa√ß√£o gera Post, n√£o envia",
        "principle3Desc": "Separa√ß√£o de concerns: Automa√ß√£o decide O QUE, Dispatcher decide COMO.",
        "principle4Title": "Dedupe obrigat√≥rio",
        "principle4Desc": "Nenhum envio acontece sem passar pelo dedupe. Zero spam garantido.",
        "dataModelTitle": "Modelo de Dados",
        "rolesTitle": "Pap√©is e Permiss√µes",
        "superAdminTitle": "SuperAdmin (Plataforma)",
        "superAdminRole1": "Cria tenants",
        "superAdminRole2": "Define quais marketplaces existem",
        "superAdminRole3": "Controla feature flags",
        "superAdminRole4": "Observa sa√∫de global",
        "tenantAdminTitle": "Tenant Admin (Cliente)",
        "tenantAdminRole1": "Conecta canais (WhatsApp, Telegram)",
        "tenantAdminRole2": "Conecta afiliados (Shopee, ML)",
        "tenantAdminRole3": "Cria automa√ß√µes",
        "tenantAdminRole4": "V√™ hist√≥rico e m√©tricas"
      },
      "providers": {
        "title": "Provider Pattern",
        "intro": "Cada marketplace implementa uma interface comum. O provider n√£o sabe o que √© tenant ‚Äî tudo vem via tenant_connection. Isso permite adicionar novos marketplaces sem tocar no core.",
        "shopeeTitle": "Shopee Provider",
        "dedupeKeyTitle": "‚úì Dedupe Key",
        "dedupeKeyDesc": "O dedupe_key √© a identidade real do produto: shopee:123:456. Nunca usar t√≠tulo para dedupe ‚Äî varia√ß√µes de texto causariam spam."
      },
      "scoring": {
        "title": "Offer Scoring",
        "intro": "Nem toda oferta vale a pena postar. O sistema de scoring ranqueia ofertas por potencial de convers√£o, penalizando produtos suspeitos.",
        "formulaTitle": "F√≥rmula de Score",
        "weightsTitle": "Por que esses pesos?",
        "weight1Pct": "40%",
        "weight1Label": "Desconto:",
        "weight1Desc": "Principal driver de clique. Ofertas com desconto alto convertem mais.",
        "weight2Pct": "25%",
        "weight2Label": "Rating:",
        "weight2Desc": "Confian√ßa do produto. Rating baixo = devolu√ß√£o = comiss√£o cancelada.",
        "weight3Pct": "20%",
        "weight3Label": "Vendas:",
        "weight3Desc": "Prova social. Produto muito vendido tem valida√ß√£o de mercado.",
        "weight4Pct": "15%",
        "weight4Label": "Comiss√£o:",
        "weight4Desc": "Retorno para o afiliado. Mas comiss√£o alta demais √© red flag."
      },
      "dedupe": {
        "title": "Deduplica√ß√£o Anti-Spam",
        "intro": "O sistema de dedupe opera em dois escopos: por target (grupo espec√≠fico) e por channel (todos os grupos do canal). Isso previne spam tanto vertical quanto horizontal.",
        "targetScopeTitle": "Target Scope (48h)",
        "targetScopeDesc": "Mesmo produto n√£o pode ser enviado para o mesmo grupo em 48h. Evita repeti√ß√£o percebida pelos membros.",
        "channelScopeTitle": "Channel Scope (2-5min)",
        "channelScopeDesc": "Gap m√≠nimo entre qualquer envio para qualquer grupo. Evita burst que parece bot.",
        "cleanupTitle": "‚úì Cleanup Autom√°tico",
        "cleanupDesc": "Records expirados s√£o deletados periodicamente via cleanup_expired(). A tabela n√£o cresce indefinidamente."
      },
      "antiBan": {
        "title": "Anti-Ban (WhatsApp)",
        "intro": "WhatsApp detecta bots por padr√µes de envio. O sistema implementa m√∫ltiplas camadas de humaniza√ß√£o para evitar banimento:",
        "feature1Icon": "üñäÔ∏è",
        "feature1Title": "Typing Indicator:",
        "feature1Desc": "Antes de enviar, simula \"digitando...\" por 2-5 segundos (Evolution API).",
        "feature2Icon": "üé≤",
        "feature2Title": "Jitter Humano:",
        "feature2Desc": "Delay aleat√≥rio entre mensagens. Nunca intervalos exatos.",
        "feature3Icon": "üö¶",
        "feature3Title": "Rate Limit por Conta:",
        "feature3Desc": "Sem√°foro Redis limita msgs/minuto por n√∫mero. M√∫ltiplas contas = mais throughput.",
        "feature4Icon": "‚ö°",
        "feature4Title": "Circuit Breaker:",
        "feature4Desc": "Erro 429 ou 503 ‚Üí pausa autom√°tica de 30min para aquela conta.",
        "feature5Icon": "üåô",
        "feature5Title": "Quiet Hours:",
        "feature5Desc": "Configur√°vel por target: n√£o envia entre 23h-8h (ou custom)."
      },
      "automations": {
        "title": "Sistema de Automa√ß√µes",
        "intro": "Automa√ß√µes s√£o o cora√ß√£o do sistema. Definem O QUE buscar, ONDE enviar, e QUANDO executar.",
        "pipelineTitle": "Automation Pipeline",
        "typesTitle": "Tipos de Automa√ß√£o",
        "typeSearchTitle": "search",
        "typeSearchDesc": "Busca ativa no marketplace. Executa a cada intervalo configurado.",
        "typeFeedTitle": "feed",
        "typeFeedDesc": "Usa ofertas j√° no banco (ingest√£o externa). Aplica ranking e distribui.",
        "typeMonitorTitle": "monitor",
        "typeMonitorDesc": "Monitora pre√ßo de produtos espec√≠ficos. Alerta quando desconto atinge threshold.",
        "targetTitle": "AutomationTarget (Limites)",
        "targetConfigTitle": "Configura√ß√£o por Grupo"
      },
      "stack": {
        "title": "Stack T√©cnico",
        "backendTitle": "Backend",
        "frontendTitle": "Frontend",
        "integrationsTitle": "Integra√ß√µes",
        "infraTitle": "Infra"
      },
      "results": {
        "title": "Resultados",
        "stat1Value": "0",
        "stat1Label": "Bans de conta WhatsApp",
        "stat2Value": "100%",
        "stat2Label": "Dedupe coverage (zero spam)",
        "stat3Value": "Plug",
        "stat3Label": "& Play para novos marketplaces",
        "stat4Value": "Multi",
        "stat4Label": "Tenant desde o dia 1"
      },
      "cta": {
        "title": "Explore Outros Projetos",
        "description": "Veja outros sistemas que constru√≠"
      },
      "footer": {
        "caseStudy": "Case Study: AutoMark Platform ‚Äî Affiliate Marketing Automation"
      }
    },
    "icontei": {
      "meta": {
        "title": "iContei - Rede Social de Contadores | Marcelo Marleta",
        "description": "Case study: Plataforma full-stack de contadores compartilh√°veis com Next.js 16, FastAPI, WebSocket real-time, e verifica√ß√£o por IA."
      },
      "hero": {
        "tag1": "Full-Stack Platform",
        "tag2": "Social Network",
        "tag3": "Real-time",
        "title": "iContei",
        "description": "Rede social de contadores compartilh√°veis ‚Äî desde estat√≠sticas esportivas virais at√© marcos pessoais. Plataforma full-stack com Next.js 16, FastAPI, WebSockets, e verifica√ß√£o por IA."
      },
      "overview": {
        "title": "Vis√£o Geral",
        "productTitle": "O Produto",
        "productDesc1": "iContei √© uma plataforma social dedicada a contadores de todos os tipos ‚Äî desde estat√≠sticas esportivas virais (\"H√° 2.847 dias o Flamengo est√° sem t√≠tulo mundial\") at√© marcos pessoais (\"Faltam 127 dias para meu casamento\") e corporativos (\"1.567 dias sem acidentes de trabalho\").",
        "productDesc2": "O foco √© criar contadores visualmente impactantes para compartilhamento em redes sociais (TikTok, Instagram, Twitter) com previews din√¢micos, atualiza√ß√£o em tempo real, e comunidade engajada.",
        "useCasesTitle": "Casos de Uso",
        "publicTitle": "üìä P√∫blicos (Virais)",
        "publicExample1": "\"H√° 2.847 dias o Flamengo est√° sem t√≠tulo mundial\"",
        "publicExample2": "\"Faltam 180 dias para a Copa do Mundo 2026\"",
        "publicExample3": "\"Real Madrid h√° 45 dias sem perder no Bernab√©u\"",
        "personalTitle": "üíë Pessoais",
        "personalExample1": "\"Faltam 127 dias para meu casamento\"",
        "personalExample2": "\"H√° 1.234 dias que nos conhecemos\"",
        "corporateTitle": "üè¢ Corporativos",
        "corporateExample1": "\"1.567 dias sem acidentes de trabalho\"",
        "corporateExample2": "\"890 dias como l√≠der de mercado\""
      },
      "architecture": {
        "title": "Arquitetura Full-Stack",
        "frontendStackTitle": "Frontend Stack",
        "backendStackTitle": "Backend Stack"
      },
      "realtime": {
        "title": "Sistema Real-time",
        "description": "Contadores atualizam a cada segundo no frontend. Para suportar milhares de conex√µes simult√¢neas, implementei um sistema de WebSocket com Redis pub/sub, heartbeat, e rate limiting inteligente.",
        "websocketTitle": "WebSocket Manager",
        "websocketDesc": "Rate limiting dual: por usu√°rio autenticado (5 conex√µes) e por IP para an√¥nimos (20 conex√µes, considerando NAT/CGNAT). Heartbeat via Redis Sorted Set para detectar conex√µes mortas.",
        "pubsubTitle": "Redis Pub/Sub Distribution",
        "pubsubDesc": "Com Redis pub/sub, posso escalar horizontalmente o backend ‚Äî cada inst√¢ncia mant√©m suas conex√µes WebSocket e recebe atualiza√ß√µes via Redis.",
        "presenceTitle": "Sistema de Presen√ßa",
        "presenceStat1Value": "30s",
        "presenceStat1Label": "Heartbeat interval",
        "presenceStat2Value": "45s",
        "presenceStat2Label": "Presence timeout",
        "presenceStat3Value": "ZADD",
        "presenceStat3Label": "Redis Sorted Set",
        "presenceDesc": "Cliente envia heartbeat a cada 30s. Servidor usa ZRANGEBYSCORE para listar conex√µes ativas (timestamp > now - 45s). Conex√µes stale s√£o removidas automaticamente."
      },
      "aiVerification": {
        "title": "Verifica√ß√£o por IA",
        "description": "Contadores oficiais passam por verifica√ß√£o automatizada com IA para garantir que datas e informa√ß√µes est√£o corretas. Sistema multi-provider com fallback.",
        "serviceTitle": "AI Verification Service",
        "pipelineTitle": "Pipeline Brave Search + Groq",
        "pipelineDesc": "Para contadores que precisam de dados externos (ex: \"√∫ltima vit√≥ria do time X\"), uso Brave Search para buscar informa√ß√µes recentes e Groq para extrair dados estruturados."
      },
      "rankings": {
        "title": "Sistema de Rankings",
        "description": "Rankings em tempo real usando Redis Sorted Sets com algoritmo de scoring 60/30/10 que balanceia likes, coment√°rios e visualiza√ß√µes.",
        "algorithmTitle": "Algoritmo de Scoring",
        "redisTitle": "Redis Sorted Sets",
        "redisDesc": "ZADD para inserir, ZREVRANGE para buscar top N, ZREMRANGEBYRANK para manter tamanho controlado. O(log N) para todas as opera√ß√µes."
      },
      "automation": {
        "title": "Sistema de Automa√ß√£o",
        "description": "Contadores podem ser atualizados automaticamente via regras configur√°veis ‚Äî desde agendamentos cron at√© triggers baseados em APIs externas.",
        "scheduledTitle": "Scheduled",
        "scheduledDesc": "Cron expressions para atualiza√ß√£o peri√≥dica. Usa croniter para calcular pr√≥xima execu√ß√£o.",
        "apiTriggerTitle": "API Trigger",
        "apiTriggerDesc": "Integra√ß√£o com APIs externas (API-Football, etc.) para buscar dados automaticamente.",
        "crowdsourcedTitle": "Crowdsourced",
        "crowdsourcedDesc": "Usu√°rios podem sugerir atualiza√ß√µes que passam por aprova√ß√£o antes de serem aplicadas.",
        "sportsProviderTitle": "Sports API Provider",
        "sportsProviderDesc": "Provider Pattern permite adicionar novas fontes de dados facilmente. Cada provider implementa fetch_data() e retorna resposta padronizada."
      },
      "observability": {
        "title": "Observabilidade",
        "description": "Stack completa de observabilidade para monitorar a plataforma em produ√ß√£o.",
        "prometheusTitle": "Prometheus + Metrics",
        "otelTitle": "OpenTelemetry",
        "loggingTitle": "Structured Logging"
      },
      "testing": {
        "title": "Testes Automatizados",
        "description": "Cobertura completa com pytest (backend) e vitest + Playwright (frontend).",
        "backendTitle": "Backend (pytest)",
        "backendTestCount": "267",
        "backendTestLabel": "testes",
        "backendStatus": "‚úì",
        "backendStatusLabel": "passando",
        "frontendTitle": "Frontend (vitest + Playwright)",
        "frontendUnitCount": "21",
        "frontendUnitLabel": "unit tests",
        "frontendE2E": "E2E",
        "frontendE2ELabel": "Playwright"
      },
      "workers": {
        "title": "Background Workers",
        "description": "Processamento ass√≠ncrono para tarefas pesadas, mantendo a API responsiva.",
        "schedulerTitle": "Automation Scheduler",
        "schedulerDesc": "Executa regras de automa√ß√£o a cada 5 minutos. Calcula pr√≥ximo run com croniter.",
        "rankingTitle": "Ranking Worker",
        "rankingDesc": "Atualiza Redis Sorted Sets com scores calculados para cada per√≠odo (24h, 7d, 30d, all).",
        "reviewTitle": "Review Worker",
        "reviewDesc": "Processa filas de verifica√ß√£o de contadores, coordena com AI Verification Service.",
        "monitoringTitle": "AI Monitoring",
        "monitoringDesc": "Monitora contadores marcados para verifica√ß√£o cont√≠nua, atualiza quando dados mudam."
      },
      "roadmap": {
        "title": "Roadmap",
        "phase1Title": "Fase 1 - MVP ‚úÖ",
        "phase1Item1": "‚úì CRUD de contadores",
        "phase1Item2": "‚úì Sistema de temas",
        "phase1Item3": "‚úì Rankings (Trending)",
        "phase1Item4": "‚úì OG images din√¢micas",
        "phase1Item5": "‚úì Autentica√ß√£o",
        "phase1Item6": "‚úì Seguir + rea√ß√µes",
        "phase2Title": "Fase 2 - Social",
        "phase2Item1": "Feed personalizado",
        "phase2Item2": "Coment√°rios e discuss√µes",
        "phase2Item3": "Notifica√ß√µes push",
        "phase2Item4": "Badges e gamifica√ß√£o",
        "phase2Item5": "Perfis p√∫blicos robustos",
        "phase3Title": "Fase 3 - Empresas",
        "phase3Item1": "Perfis corporativos",
        "phase3Item2": "Multi-usu√°rio por org",
        "phase3Item3": "Dashboards analytics",
        "phase3Item4": "SSO corporativo",
        "phase3Item5": "Temas licenciados",
        "phase4Title": "Fase 4 - Creators",
        "phase4Item1": "Gera√ß√£o de v√≠deos (Remotion)",
        "phase4Item2": "SDK para redes sociais",
        "phase4Item3": "API p√∫blica",
        "phase4Item4": "Widgets embeddable",
        "phase4Item5": "Marketplace de templates"
      },
      "stackSection": {
        "title": "Stack Completa"
      },
      "cta": {
        "title": "Quer ver mais projetos?",
        "description": "Este √© um dos meus projetos pessoais. Explore tamb√©m o Optimus (plataforma de IA conversacional) e outros case studies no meu portfolio."
      }
    },
    "gratidiem": {
      "meta": {
        "title": "GratiDiem - App de Gratid√£o Flutter | Marcelo Marleta",
        "description": "Case study: App Flutter multi-plataforma de gratid√£o com Clean Architecture, Riverpod, Firebase, IA integrada com Gemini, e sistema de monetiza√ß√£o √©tica."
      },
      "hero": {
        "tag1": "Flutter App",
        "tag2": "Multi-Platform",
        "tag3": "Firebase",
        "title": "GratiDiem",
        "description": "Aplicativo de gratid√£o e bem-estar com 508+ arquivos Dart, 35+ telas, 86+ servi√ßos. Clean Architecture com Riverpod, dual persistence (Hive + Firebase), IA integrada com Gemini, e sistema de monetiza√ß√£o √©tica gamificado."
      },
      "overview": {
        "title": "Vis√£o Geral",
        "productTitle": "O Produto",
        "productDesc1": "GratiDiem √© um companheiro di√°rio de gratid√£o ‚Äî um aplicativo sofisticado que ajuda usu√°rios a cultivar bem-estar atrav√©s de pr√°ticas de gratid√£o, medita√ß√£o guiada, desafios di√°rios, e comunidade.",
        "productDesc2": "O app suporta 6 plataformas (Android, iOS, Web, macOS, Windows, Linux), 3 idiomas (PT, EN, ES), e √© constru√≠do para escalar para milh√µes de usu√°rios.",
        "metricsTitle": "M√©tricas do Codebase",
        "metricFilesValue": "508+",
        "metricFilesLabel": "Arquivos Dart",
        "metricScreensValue": "35+",
        "metricScreensLabel": "Telas",
        "metricServicesValue": "86+",
        "metricServicesLabel": "Services",
        "metricModelsValue": "126+",
        "metricModelsLabel": "Models"
      },
      "architecture": {
        "title": "Arquitetura Clean + Riverpod",
        "presentationTitle": "Presentation",
        "presentationDesc": "278+ arquivos, Material Design 3, responsive design, ConsumerWidget/ConsumerStatefulWidget",
        "stateTitle": "State Management",
        "stateDesc": "Riverpod com AsyncNotifier/StateNotifier, stream subscriptions, real-time updates",
        "businessTitle": "Business Logic",
        "businessDesc": "Singleton services + Repository pattern, 113 arquivos com responsabilidades claras",
        "dataTitle": "Data Layer",
        "dataDesc": "Dual persistence: Hive CE (local-first) + Firebase Firestore (cloud sync)"
      },
      "features": {
        "title": "Features do App",
        "gratitudeTitle": "üôè Gratitude Journal",
        "gratitudeDesc": "Di√°rio de gratid√£o com entradas di√°rias, categorias, tags, e busca full-text. Suporte a imagens e compartilhamento social.",
        "meditationTitle": "üßò Medita√ß√£o Guiada",
        "meditationDesc": "Player de √°udio com sess√µes de medita√ß√£o (manh√£, dia, ansiedade, noite, profunda). Just Audio + Audio Session para background playback.",
        "circlesTitle": "‚≠ï C√≠rculos (Tribos)",
        "circlesDesc": "Comunidades sociais com rituais em grupo, posts, desafios colaborativos, gamifica√ß√£o, e sync real-time via Firestore.",
        "challengesTitle": "üèÜ Challenges & Progression",
        "challengesDesc": "Desafios di√°rios, streaks, sistema de n√≠veis, √°rvore de progress√£o, achievements, e surprise rewards.",
        "nightRitualTitle": "üåô Night Ritual",
        "nightRitualDesc": "Ritual noturno guiado com medita√ß√£o, reflex√£o, inten√ß√µes para o pr√≥ximo dia. Scheduling com notifica√ß√µes locais.",
        "adversityTitle": "üíä Adversity Support",
        "adversityDesc": "M√≥dulo de sa√∫de mental com jornada de adversidade, pr√°ticas terap√™uticas, hist√≥rias inspiradoras, recursos de emerg√™ncia.",
        "timeCapsuleTitle": "‚è≥ Time Capsule",
        "timeCapsuleDesc": "C√°psulas do tempo para guardar mem√≥rias e gratid√µes a serem abertas no futuro.",
        "valuesTitle": "üéØ Values & Goals",
        "valuesDesc": "Defini√ß√£o de valores pessoais, visualiza√ß√£o de metas, reviews peri√≥dicos.",
        "analyticsTitle": "üìä Wellbeing Analytics",
        "analyticsDesc": "Assessments de bem-estar, gr√°ficos de humor (fl_chart), calend√°rio de atividades (table_calendar)."
      },
      "ai": {
        "title": "Integra√ß√£o com IA",
        "description": "Motor de IA multi-backend com Google Gemini, Hugging Face, e modelos on-device (TensorFlow Lite).",
        "engineTitle": "AI Engine",
        "capabilitiesTitle": "Capacidades de IA",
        "sentimentTitle": "An√°lise de Sentimentos",
        "sentimentDesc": "Detecta emo√ß√µes nas entradas de gratid√£o com cache para performance",
        "themesTitle": "Detec√ß√£o de Temas",
        "themesDesc": "Categoriza automaticamente entradas (fam√≠lia, trabalho, sa√∫de, etc.)",
        "responsesTitle": "Respostas Personalizadas",
        "responsesDesc": "Gera reflex√µes e sugest√µes baseadas no hist√≥rico do usu√°rio",
        "premiumTitle": "AI Premium Service",
        "premiumDesc": "Features avan√ßadas para usu√°rios premium com Gemini Pro",
        "aiAnalyticsTitle": "AI Analytics",
        "aiAnalyticsDesc": "Insights e tend√™ncias derivados das pr√°ticas de gratid√£o"
      },
      "monetization": {
        "title": "Sistema de Monetiza√ß√£o √âtica",
        "description": "Transformando an√∫ncios em \"momentos de gratid√£o\" ‚Äî monetiza√ß√£o integrada ao conceito do app, criando experi√™ncia significativa ao inv√©s de intrusiva.",
        "appealsTitle": "üôè Apelos Contextuais",
        "appealsDesc": "Mensagens de gratid√£o personalizadas baseadas no contexto do usu√°rio.",
        "appealsExample1": "P√≥s-Ritual: \"Se este app te ajudou...\"",
        "appealsExample2": "Streak: \"7 dias de gratid√£o! Retribua...\"",
        "appealsExample3": "Alta Energia: \"Sinta essa vibra√ß√£o positiva?\"",
        "appealsExample4": "Conquistas: \"Conquista desbloqueada!\"",
        "tokensTitle": "üéÆ Economia de Tokens",
        "tokensDesc": "Sistema gamificado com tokens que podem ser ganhos e usados no app.",
        "tokensExample1": "Daily bonus com multiplicadores",
        "tokensExample2": "Streak multipliers",
        "tokensExample3": "Achievement rewards",
        "tokensExample4": "Challenge completion",
        "remoteConfigTitle": "üìä Firebase Remote Config",
        "remoteConfigDesc": "Controle din√¢mico de toda a monetiza√ß√£o sem deploy.",
        "remoteConfigExample1": "Frequ√™ncia de an√∫ncios",
        "remoteConfigExample2": "Cooldown periods",
        "remoteConfigExample3": "A/B testing de mensagens",
        "remoteConfigExample4": "M√©tricas de convers√£o",
        "triggersTitle": "Gratitude Triggers Service"
      },
      "firebase": {
        "title": "Firebase Full Stack",
        "authTitle": "üîê Authentication",
        "storageTitle": "üì¶ Storage",
        "analyticsTitle": "üìä Analytics",
        "messagingTitle": "üîî Messaging"
      },
      "persistence": {
        "title": "Dual Persistence: Local-First",
        "description": "Arquitetura local-first com Hive CE para performance e offline, sincronizando automaticamente com Firebase Firestore.",
        "hiveTitle": "Hive CE (Local)",
        "hiveDesc": "197 TypeIDs registrados, c√≥digo gerado via build_runner, adapter registry centralizado.",
        "syncTitle": "Sync Strategy",
        "syncDesc": "Last-write-wins com detec√ß√£o de conflitos, queue de retry para offline, recovery service para reconex√£o."
      },
      "navigation": {
        "title": "Navega√ß√£o com GoRouter",
        "description": "100+ rotas declarativas com GoRouter, deep linking, redirect guards, e par√¢metros tipados."
      },
      "i18n": {
        "title": "Internacionaliza√ß√£o",
        "portuguese": "Portugu√™s",
        "portugueseDesc": "Idioma base (app_pt.arb)",
        "english": "English",
        "englishDesc": "app_en.arb",
        "spanish": "Espa√±ol",
        "spanishDesc": "app_es.arb",
        "summary": "200+ strings traduzidas usando ARB format (Application Resource Bundle), gera√ß√£o autom√°tica via flutter gen-l10n, script Python para tradu√ß√£o em lote."
      },
      "platforms": {
        "title": "6 Plataformas Suportadas",
        "android": "Android",
        "ios": "iOS",
        "web": "Web",
        "macos": "macOS",
        "windows": "Windows",
        "linux": "Linux"
      },
      "testing": {
        "title": "Testing & Quality",
        "unitTitle": "Unit Tests",
        "widgetTitle": "Widget Tests",
        "integrationTitle": "Integration Tests",
        "qualityTitle": "Code Quality"
      },
      "stackSection": {
        "title": "Stack Completa"
      },
      "cta": {
        "title": "Quer ver mais projetos?",
        "description": "Este √© um dos meus projetos pessoais mais completos em Flutter. Explore tamb√©m o iContei (rede social de contadores) e os projetos do Optimus."
      }
    },
    "memory": {
      "badge": "Sistema de Mem√≥ria",
      "title": "Memory Engine",
      "description": "Sistema de mem√≥ria hier√°rquico multi-tier (Hot/Warm/Cold) com compress√£o sem√¢ntica inteligente, compliance autom√°tico LGPD/HIPAA, e context injection para continuidade AI ‚Üî Humano.",
      "metrics": {
        "latency": "Lat√™ncia p99",
        "tokenReduction": "Redu√ß√£o de Tokens",
        "complianceRules": "Compliance Rules",
        "durability": "Durabilidade"
      },
      "problem": {
        "title": "O Problema",
        "intro": "Chatbots enterprise precisam de mem√≥ria de contexto. Quando um cliente retorna dias depois, o bot precisa lembrar conversas anteriores, prefer√™ncias e hist√≥rico de atendimentos.",
        "tokensCost": "Tokens s√£o caros",
        "tokensCostDesc": "Injetar todo o hist√≥rico no prompt explode os custos",
        "latencyKillsUx": "Lat√™ncia mata UX",
        "latencyKillsUxDesc": "Busca em banco relacional adiciona 200-500ms",
        "complianceMandatory": "Compliance obrigat√≥rio",
        "complianceMandatoryDesc": "LGPD, CFM, CFO t√™m regras r√≠gidas de reten√ß√£o",
        "handoverComplicates": "Handover complica",
        "handoverComplicatesDesc": "AI precisa saber o que aconteceu quando humano atendeu"
      },
      "solution": {
        "title": "A Solu√ß√£o",
        "hotWarmCold": {
          "title": "Arquitetura Hot/Warm/Cold",
          "intro": "Sistema de armazenamento em 3 tiers com estrat√©gia Write-Through:",
          "hot": "HOT",
          "hotDesc": "Redis ¬∑ TTL 1min",
          "hotLatency": "<10ms lat√™ncia",
          "warm": "WARM",
          "warmDesc": "Redis ¬∑ TTL 1h",
          "warmLatency": "<50ms lat√™ncia",
          "cold": "COLD",
          "coldDesc": "PostgreSQL",
          "coldLatency": "~100ms ¬∑ Permanente",
          "writeThrough": "Write-Through",
          "writeThroughDesc": "Toda escrita vai primeiro para PostgreSQL (durabilidade garantida), depois replica para Redis (performance)."
        },
        "customerFacts": {
          "title": "Customer Facts Temporais",
          "intro": "Em vez de armazenar conversas brutas, extra√≠mos fatos estruturados com janela de validade temporal:",
          "footer": "Hist√≥rico temporal completo para auditoria. Consulta O(1) para fatos atuais via √≠ndice parcial."
        },
        "semanticCompression": {
          "title": "Compress√£o Sem√¢ntica com LLM",
          "intro": "Conversas longas s√£o comprimidas usando OpenAI com templates verticais espec√≠ficos (dental, m√©dico, jur√≠dico):",
          "preserves": "Preserva",
          "preservesDesc": "Fatos cr√≠ticos, decis√µes, pr√≥ximos passos",
          "removes": "Remove",
          "removesDesc": "Sauda√ß√µes, confirma√ß√µes redundantes, detalhes operacionais",
          "result": "Resultado",
          "resultDesc": "90% redu√ß√£o com 100% preserva√ß√£o de informa√ß√£o relevante"
        },
        "compliance": {
          "title": "Compliance Autom√°tico",
          "intro": "Classifica√ß√£o e tratamento autom√°tico baseado no vertical:",
          "lgpd": "LGPD",
          "lgpdDesc": "Brasil",
          "hipaa": "HIPAA",
          "hipaaDesc": "EUA - Sa√∫de",
          "cfo": "CFO",
          "cfoDesc": "Odontologia",
          "cfm": "CFM",
          "cfmDesc": "Medicina",
          "oab": "OAB",
          "oabDesc": "Advocacia",
          "gdpr": "GDPR",
          "gdprDesc": "Europa",
          "footer": "Anonimiza√ß√£o inteligente: CPF -> ***.***.***.00 | Email -> ***{'@'}domain.com"
        },
        "handover": {
          "title": "Handover Summary",
          "intro": "Continuidade perfeita quando atendente humano interv√©m:",
          "step1": "Mensagens do operador ‚Üí Buffer Redis (hot path)",
          "step2": "Encerramento ‚Üí Celery worker gera resumo com OpenAI",
          "step3": "AI retoma ‚Üí Recebe resumo estruturado injetado no contexto"
        }
      },
      "architecture": {
        "title": "Arquitetura",
        "lastMsg": "√öltima msg",
        "activeSession": "Sess√£o Ativa",
        "completeHistory": "Hist√≥rico Completo",
        "writeThroughStrategy": "Write-Through Strategy",
        "sourceOfTruth": "(PostgreSQL = Source of Truth)",
        "contextComposer": "CONTEXT COMPOSER v2",
        "factsLogic": "Facts (L√≥gica)",
        "summaryLanguage": "Summary (Linguagem)",
        "recentChat": "Recent (Chat)",
        "lastMsgs": "[√∫ltimas 5 msgs]"
      },
      "decisions": {
        "title": "Decis√µes T√©cnicas",
        "writeThrough": {
          "question": "Por que Write-Through e n√£o Write-Behind?",
          "answer": "Write-Behind (async write to DB) √© mais perform√°tico mas arriscado. Em atendimento ao cliente, perder uma mensagem √© inaceit√°vel. Write-Through garante durabilidade imediata com performance aceit√°vel."
        },
        "schemaIsolation": {
          "question": "Por que schema isolation e n√£o row-level security?",
          "answer": "RLS adiciona overhead em cada query. Com schemas separados (t_{tenant_id}), o isolamento √© f√≠sico e a performance √© m√°xima. Trade-off: mais complexidade operacional."
        },
        "temporalFacts": {
          "question": "Por que Customer Facts temporais?",
          "answer": "LLMs s√£o p√©ssimos em \"esquecer\". Se o cliente mudou de prefer√™ncia, o modelo com hist√≥rico completo continuaria usando a prefer√™ncia antiga. Facts temporais com valid_at/invalid_at resolvem isso elegantemente."
        },
        "factsSummary": {
          "question": "Por que separar Facts vs Summary no Context Composer?",
          "answer": "Facts s√£o para l√≥gica (o sistema usa para tomar decis√µes). Summary √© para linguagem (o LLM usa para gerar respostas naturais). Essa separa√ß√£o evita que o LLM \"alucine\" sobre dados estruturados."
        }
      },
      "nextProject": "Pr√≥ximo: AI Conversation Engine ‚Üí"
    },
    "backend": {
      "badge": "Gateway Inteligente",
      "title": "Backend Orchestrator",
      "description": "Gateway enterprise multi-tenant com rate limiting distribu√≠do, circuit breaker, handover dual-mode (operator + AI-initiated), WebSocket real-time e fail-closed resilience.",
      "metrics": {
        "gatewayLatency": "Gateway Latency",
        "reqPerMinTenant": "Req/min/tenant",
        "retryStrategies": "Retry Strategies",
        "uptime": "Uptime"
      },
      "problem": {
        "title": "O Problema",
        "intro": "Em sistemas de atendimento multi-tenant, o gateway √© o ponto cr√≠tico de falha. Problemas comuns:",
        "noisyNeighbor": "Noisy Neighbor",
        "noisyNeighborDesc": "Um tenant com tr√°fego alto derruba todos os outros",
        "cascadingFailures": "Cascading Failures",
        "cascadingFailuresDesc": "AI Engine lento bloqueia todo o sistema",
        "handoverChaos": "Handover Chaos",
        "handoverChaosDesc": "AI responde quando humano est√° atendendo",
        "idempotencyBugs": "Idempotency Bugs",
        "idempotencyBugsDesc": "Mesma mensagem processada m√∫ltiplas vezes",
        "frontendDesync": "Frontend Desync",
        "frontendDesyncDesc": "UI n√£o reflete estado real das conversas"
      },
      "solution": {
        "title": "A Solu√ß√£o",
        "rateLimiting": {
          "title": "Enterprise Rate Limiting",
          "intro": "Sistema de rate limiting multi-camada com algoritmos adaptativos:",
          "slidingWindow": "Sliding Window",
          "slidingWindowDesc": "Precis√£o temporal com Redis ZSET",
          "tokenBucket": "Token Bucket",
          "tokenBucketDesc": "Burst handling com Lua scripts at√¥micos",
          "localFallback": "Local Fallback",
          "localFallbackDesc": "Cache local quando Redis indispon√≠vel",
          "tenantTiers": "Tenant Tiers",
          "tenantTiersDesc": "FREE (10 req/min) ‚Üí BASIC (50) ‚Üí PROFESSIONAL (200) ‚Üí ENTERPRISE (unlimited)"
        },
        "circuitBreaker": {
          "title": "Circuit Breaker Pattern",
          "intro": "Prote√ß√£o contra cascading failures com 3 estados:",
          "closed": "CLOSED",
          "open": "OPEN",
          "halfOpen": "HALF_OPEN",
          "failureThreshold": "failure_threshold",
          "failureThresholdDesc": "5 falhas consecutivas abrem o circuito",
          "recoveryTimeout": "recovery_timeout",
          "recoveryTimeoutDesc": "60s antes de testar novamente",
          "halfOpenMaxCalls": "half_open_max_calls",
          "halfOpenMaxCallsDesc": "10 requests de teste antes de fechar"
        },
        "handover": {
          "title": "Handover Dual-Mode",
          "intro": "Dois modos de transi√ß√£o AI ‚Üî Humano:",
          "operatorTakeover": "Operator Takeover",
          "operatorTakeoverList": [
            "Operador clica \"assumir conversa\"",
            "Redis latch bloqueia AI instantaneamente",
            "Timer auto-resume configur√°vel por tenant",
            "Lazy finalize: summary gerado ao retomar"
          ],
          "aiInitiated": "AI-Initiated",
          "aiInitiatedList": [
            "AI detecta problema (ERP failure, complexidade)",
            "Context injection com prioridade m√°xima",
            "Mensagem natural para cliente",
            "Hist√≥rico multi-handover preservado"
          ]
        },
        "failClosed": {
          "title": "Fail-Closed Resilience",
          "intro": "Quando Redis est√° indispon√≠vel, o sistema bloqueia AI (n√£o fica silencioso):",
          "comment": "# Fail-closed",
          "customerReceives": "# Cliente recebe: \"Um momento, estamos te transferindo...\"",
          "notSilent": "# N√ÉO: sil√™ncio total (fail-open)",
          "retryStrategy": "Retry Strategy",
          "retryStrategyDesc": "3 tentativas com exponential backoff (50ms base) + jitter aleat√≥rio"
        },
        "websocket": {
          "title": "WebSocket Real-Time",
          "intro": "Broadcasting de eventos para sincroniza√ß√£o frontend:",
          "conversationUpdate": "conversation_update",
          "conversationUpdateDesc": "Nova conversa ou mudan√ßa de status",
          "newMessage": "new_message",
          "newMessageDesc": "Mensagem cliente/AI normalizada",
          "operatorMessage": "operator_message",
          "operatorMessageDesc": "Mensagem do operador (WhatsApp/Web)",
          "cacheInvalidation": "cache_invalidation",
          "cacheInvalidationDesc": "Trigger de refetch no frontend"
        },
        "idempotency": {
          "title": "Idempotency Gate",
          "intro": "Prote√ß√£o contra processamento duplicado:",
          "step1": "Request chega com",
          "step2": "Check Redis: j√° processado? ‚Üí retorna cached response",
          "step3": "Slot reservado ‚Üí processa request",
          "step4": "Response cacheada com TTL de 24h"
        }
      },
      "architecture": {
        "title": "Arquitetura",
        "gatewayEnterprise": "(Gateway Enterprise)",
        "rateLimiter": "Rate Limiter",
        "multiTier": "(Multi-tier)",
        "circuitBreaker": "Circuit Breaker",
        "threeStates": "(3 states)",
        "handoverGate": "Handover Gate",
        "failClosed": "(Fail-closed)",
        "chatOrchestrator": "Chat Orchestrator",
        "idempotency": "+ Idempotency",
        "aiEngine": "AI Engine",
        "langGraph": "(LangGraph)",
        "memoryEngine": "Memory Engine",
        "postgresql": "(PostgreSQL)",
        "websocketBroadcast": "WebSocket Broadcast",
        "requestFlow": "Request Flow:",
        "step1": "1. Rate Limit Check (per-tenant tier)",
        "step2": "2. Circuit Breaker (protect downstream)",
        "step3": "3. Handover Gate (AI blocking)",
        "step4": "4. Idempotency Check (dedupe)",
        "step5": "5. AI Engine Call (with timeout)",
        "step6": "6. WebSocket Broadcast (real-time)",
        "step7": "7. Cache Response (24h TTL)"
      },
      "decisions": {
        "title": "Decis√µes T√©cnicas",
        "failClosed": {
          "question": "Por que fail-closed e n√£o fail-open?",
          "answer": "Em atendimento ao cliente, sil√™ncio √© pior que resposta de fallback. Fail-closed garante que o cliente sempre receba feedback (\"estamos te transferindo\") mesmo quando Redis est√° indispon√≠vel. Fail-open deixaria o cliente esperando indefinidamente."
        },
        "redisLatch": {
          "question": "Por que Redis latch e n√£o database flag?",
          "answer": "Redis latch com TTL autom√°tico elimina a necessidade de cleanup workers. Se o operador esquecer de \"devolver\" a conversa, o TTL expira e AI retoma automaticamente. Database flags precisariam de cron jobs para timeout."
        },
        "slidingWindow": {
          "question": "Por que sliding window e n√£o fixed window?",
          "answer": "Fixed window tem o problema de \"boundary burst\": 100 requests no segundo 59 + 100 no segundo 0 = 200 requests em 2 segundos. Sliding window distribui uniformemente e evita esse pico."
        },
        "luaScripts": {
          "question": "Por que Lua scripts para token bucket?",
          "answer": "Token bucket precisa de opera√ß√µes at√¥micas (read-modify-write). Sem Lua, ter√≠amos race conditions entre GET e SET. Lua scripts executam atomicamente no servidor Redis, garantindo consist√™ncia mesmo com milhares de requests concorrentes."
        }
      },
      "nextProject": "Pr√≥ximo: Memory Engine ‚Üí"
    },
    "rules": {
      "badge": "Optimus Platform",
      "badgeSecondary": "Business Intelligence",
      "title": "Rules Engine",
      "description": "Motor de regras Python-native que elimina o overhead interpretado do JSONLogic. Avalia√ß√£o em sub-millisegundo, regras criadas em runtime por tenant, type safety completo.",
      "tags": {
        "pythonLambda": "Python Lambda",
        "subMillisecond": "Sub-millisecond",
        "multiTenant": "Multi-tenant",
        "eventDriven": "Event-driven",
        "typeSafe": "Type Safe",
        "cacheCoherence": "Cache Coherence"
      },
      "problem": {
        "title": "O Problema: Por que JSONLogic n√£o escala",
        "jsonLogicTrap": "JSONLogic - A Armadilha",
        "simpleRule": "// Regra \"simples\" em JSONLogic",
        "issues": {
          "interpreted": "Interpretado recursivamente",
          "interpretedDesc": "cada operador √© uma chamada de fun√ß√£o aninhada",
          "limitedOps": "Operadores limitados",
          "limitedOpsDesc": "s√≥ suporta {'<'}, {'>'}, ==, in, and, or",
          "noTypeCheck": "Sem type checking",
          "noTypeCheckDesc": "erros s√≥ aparecem em runtime",
          "debugImpossible": "Debug imposs√≠vel",
          "debugImpossibleDesc": "stack traces incompreens√≠veis",
          "slowPerf": "~50-200ms",
          "slowPerfDesc": "para avaliar 100 regras complexas"
        },
        "pythonNativeSolution": "Python-Native - A Solu√ß√£o",
        "sameRule": "# Mesma regra em Python-native",
        "benefits": {
          "compiledOnce": "Compilado uma vez",
          "compiledOnceDesc": "bytecode Python nativo",
          "fullPower": "Full Python power",
          "fullPowerDesc": "regex, datetime, math, tudo",
          "typeHints": "Type hints + mypy",
          "typeHintsDesc": "erros antes do deploy",
          "normalDebug": "Debug normal",
          "normalDebugDesc": "pdb, breakpoints, stack traces",
          "fastPerf": "<0.5ms",
          "fastPerfDesc": "para avaliar 100 regras - 1000x mais r√°pido"
        },
        "benchmark": {
          "title": "Benchmark Real: JSONLogic vs Python-Native",
          "jsonLogic": "JSONLogic (100 regras)",
          "pythonNative": "Python-Native (100 regras)",
          "fasterCold": "Mais r√°pido (cold)",
          "fasterCached": "Mais r√°pido (cached)"
        }
      },
      "architecture": {
        "title": "Arquitetura: Rules Engine + Coordinator",
        "requestFlow": "Request Flow (sub-ms target)",
        "clientRequest": "Client Request",
        "backendOrchestrator": "Backend Orchestrator",
        "rulesCoordinator": "Rules Coordinator",
        "cacheFallback": "(Cache + Fallback)",
        "rulesEngine": "Rules Engine",
        "port": "(Port 8040)",
        "redisCache": "Redis Cache",
        "ttl15min": "(15 min)",
        "postgresql": "PostgreSQL",
        "rulesDb": "(Rules DB)",
        "fallbackHierarchy": "Fallback Hierarchy (never fails)",
        "primary": "1. Rules Engine API ‚Üí Primary (target <50ms)",
        "secondary": "2. Redis Cache      ‚Üí Secondary (target <5ms)",
        "basic": "3. Basic Fallback   ‚Üí Always available (keyword-based)",
        "components": {
          "rulesEngine": {
            "title": "Rules Engine",
            "desc": "Microsservi√ßo dedicado que compila e executa regras Python-native. Cada tenant tem suas pr√≥prias regras isoladas.",
            "items": [
              "Compila√ß√£o de lambdas Python",
              "Sandboxing de execu√ß√£o",
              "M√©tricas por regra",
              "Multi-vertical support"
            ]
          },
          "rulesCoordinator": {
            "title": "Rules Coordinator",
            "desc": "Proxy inteligente no Backend Orchestrator com cache, circuit breaker e fallback multi-tier.",
            "items": [
              "Cache de avalia√ß√µes (15min TTL)",
              "Memory context enrichment",
              "Circuit breaker protection",
              "Graceful degradation"
            ]
          },
          "contextEnrichment": {
            "title": "Context Enrichment",
            "desc": "Integra√ß√£o com Memory Engine para enriquecer fatos com contexto hist√≥rico do cliente.",
            "items": [
              "Frequ√™ncia de intera√ß√£o",
              "N√≠vel de urg√™ncia detectado",
              "Indicadores de dor/emerg√™ncia",
              "Padr√µes inteligentes"
            ]
          }
        }
      },
      "runtimeCreation": {
        "title": "Runtime Rule Creation: Cada Neg√≥cio √© √önico",
        "intro": "O grande diferencial do Rules Engine √© permitir que cada tenant crie suas pr√≥prias regras em tempo real, sem deploy, sem downtime, sem c√≥digo.",
        "apiTitle": "API de Cria√ß√£o de Regras",
        "examples": {
          "dental": {
            "title": "ü¶∑ Regra Dental",
            "desc": "Lembrete de limpeza baseado em √∫ltima visita + status do seguro. Se passou 6 meses e tem cobertura ‚Üí agenda preventiva."
          },
          "ecommerce": {
            "title": "üõí Regra E-commerce",
            "desc": "Carrinho abandonado h√° 2h + valor > R$200 + cliente recorrente ‚Üí oferta de 10% desconto + frete gr√°tis."
          },
          "legal": {
            "title": "‚öñÔ∏è Regra Legal",
            "desc": "Prazo processual em 48h + cliente n√£o respondeu √∫ltima mensagem ‚Üí alerta urgente + escala√ß√£o para advogado respons√°vel."
          }
        },
        "multiTenant": {
          "title": "üîí Isolamento Multi-tenant Completo",
          "clinic": {
            "name": "Cl√≠nica ABC",
            "rules": "47 regras ativas",
            "vertical": "Vertical: dental",
            "focus": "Foco: agendamento"
          },
          "store": {
            "name": "Loja XYZ",
            "rules": "89 regras ativas",
            "vertical": "Vertical: e-commerce",
            "focus": "Foco: convers√£o"
          },
          "law": {
            "name": "Advocacia 123",
            "rules": "23 regras ativas",
            "vertical": "Vertical: legal",
            "focus": "Foco: prazos"
          },
          "footer": "Cada tenant tem regras completamente isoladas. Nenhuma regra da Cl√≠nica ABC afeta a Loja XYZ. Zero vazamento de l√≥gica de neg√≥cio entre clientes."
        }
      },
      "deepDive": {
        "title": "Deep Dive: Como Funciona",
        "coordinator": {
          "title": "Rules Coordinator: Cache + Fallback Inteligente",
          "docstring": "üéØ Coordenador Central de Regras",
          "responsibilities": [
            "1. Proxy inteligente para Rules Engine com <50ms target",
            "2. Cache Redis para performance otimizada",
            "3. Integra√ß√£o com Memory Coordinator para contexto enriquecido",
            "4. Fallback quando Rules Engine falha",
            "5. Circuit breaker para prote√ß√£o contra falhas"
          ],
          "comment1": "# 1. üß† Enriquecer dados com Memory Coordinator",
          "comment2": "# 2. üéØ Tentar Rules Engine (primary)",
          "comment3": "# Cache para reuso futuro",
          "comment4": "# 3. üîÑ Fallback para Redis cache",
          "comment5": "# 4. üö® Basic fallback (keyword-based, nunca falha)",
          "responsibilities[0]": "1. Proxy inteligente para Rules Engine com &lt;50ms target",
          "responsibilities[1]": "2. Cache Redis para performance otimizada",
          "responsibilities[2]": "3. Integra√ß√£o com Memory Coordinator para contexto enriquecido",
          "responsibilities[3]": "4. Fallback quando Rules Engine falha",
          "responsibilities[4]": "5. Circuit breaker para prote√ß√£o contra falhas"
        },
        "enrichment": {
          "title": "Context Enrichment: Regras com Contexto Hist√≥rico",
          "docstring": "Extrai padr√µes inteligentes do contexto de mem√≥ria para regras mais sofisticadas",
          "comments": {
            "detectsUrgency": "# Detecta urg√™ncia (dor, emerg√™ncia, sangramento)",
            "detectsScheduling": "# Detecta necessidade de agendamento",
            "analyzesFrequency": "# Analisa frequ√™ncia de intera√ß√£o",
            "result": "# Resultado: regras podem usar facts enriquecidos"
          }
        },
        "eventTypes": {
          "title": "Event-Driven: Triggers Autom√°ticos",
          "messageReceived": "message_received",
          "messageReceivedDesc": "Nova mensagem do cliente",
          "conversationStarted": "conversation_started",
          "conversationStartedDesc": "In√≠cio de conversa",
          "handoverCompleted": "handover_completed",
          "handoverCompletedDesc": "Atendente finalizou",
          "appointmentScheduled": "appointment_scheduled",
          "appointmentScheduledDesc": "Agendamento confirmado",
          "cartAbandoned": "cart_abandoned",
          "cartAbandonedDesc": "Carrinho abandonado",
          "deadlineApproaching": "deadline_approaching",
          "deadlineApproachingDesc": "Prazo se aproximando",
          "sentimentNegative": "sentiment_negative",
          "sentimentNegativeDesc": "Cliente insatisfeito",
          "timeBased": "time_based",
          "timeBasedDesc": "Trigger por hor√°rio"
        }
      },
      "results": {
        "title": "Resultados: Regras que Escalam",
        "latencyP95": "Lat√™ncia P95",
        "latencyP95Desc": "Target de performance",
        "vsJsonLogic": "vs JSONLogic",
        "vsJsonLogicDesc": "Com cache aquecido",
        "rulesInProduction": "Regras em Produ√ß√£o",
        "rulesInProductionDesc": "Dental + E-commerce + Medical",
        "evaluationUptime": "Uptime Avalia√ß√£o",
        "evaluationUptimeDesc": "Fallback nunca falha",
        "decisions": {
          "title": "üí° Decis√µes T√©cnicas Chave",
          "pythonLambda": {
            "title": "Python Lambda vs DSL Customizada",
            "desc": "Consideramos criar uma DSL (Domain-Specific Language) para regras, mas decidimos usar Python lambda diretamente. Raz√£o: desenvolvedores j√° conhecem Python, debugging normal, type hints funcionam, ecosystem inteiro dispon√≠vel. O sandboxing √© feito via AST parsing + restricted builtins."
          },
          "cache15min": {
            "title": "Cache de 15 minutos (n√£o infinito)",
            "desc": "Regras s√£o cacheadas por 15 minutos, n√£o infinitamente. Isso permite que altera√ß√µes em regras (via API) sejam refletidas em tempo razo√°vel sem necessidade de invalida√ß√£o manual. O tradeoff entre performance e freshness foi calibrado em produ√ß√£o."
          },
          "keywordFallback": {
            "title": "Fallback Keyword-Based (Sempre Funciona)",
            "desc": "O √∫ltimo n√≠vel de fallback usa an√°lise simples de keywords. N√£o √© sofisticado, mas garante que o sistema NUNCA falha em avaliar uma mensagem. \"Dor\" ‚Üí urg√™ncia, \"agendar\" ‚Üí appointment. Simples, mas funcional como √∫ltimo recurso."
          },
          "separateMicroservice": {
            "title": "Microsservi√ßo Separado (n√£o library)",
            "desc": "Rules Engine √© um microsservi√ßo independente, n√£o uma library importada. Isso permite escalar horizontalmente, deploy independente, e isolamento de falhas. Se o Rules Engine crashar, o Coordinator usa cache/fallback."
          }
        }
      },
      "technicalStack": {
        "title": "Stack T√©cnico",
        "runtime": "Runtime",
        "runtimeDesc": "Python 3.11+ (bytecode optimized)",
        "framework": "Framework",
        "frameworkDesc": "FastAPI + Pydantic",
        "cache": "Cache",
        "cacheDesc": "Redis (cache + pub/sub)",
        "storage": "Storage",
        "storageDesc": "PostgreSQL (rules metadata)",
        "isolation": "Isolation",
        "isolationDesc": "Per-tenant rule namespaces",
        "circuitBreaker": "Circuit Breaker",
        "circuitBreakerDesc": "5 failures ‚Üí 60s recovery",
        "httpClient": "HTTP Client",
        "httpClientDesc": "HTTPX async pooling",
        "metrics": "Metrics",
        "metricsDesc": "Prometheus + per-rule tracking"
      },
      "cta": {
        "title": "Quer discutir mais sobre Rules Engines?",
        "desc": "JSONLogic vs Python-native, DSLs customizadas, ou como fazer regras escalarem - adoro falar sobre esses temas.",
        "contact": "Entrar em Contato"
      },
      "meta": {
        "title": "Rules Engine - Python-Native 1000x mais r√°pido que JSONLogic | Marcelo Marleta",
        "description": "Motor de regras Python-native que elimina JSONLogic. Avalia√ß√£o sub-millisecond, regras em runtime por tenant, type safety completo."
      }
    },
    "testTools": {
      "back": "Voltar",
      "platformName": "Optimus AI Platform",
      "badge": "Quality Assurance",
      "badgeSecondary": "AI Testing",
      "title": "AI Testing",
      "titleHighlight": "Tools",
      "description": "Suite completa de testes para AI conversacional: interface de simula√ß√£o multi-canal, detector de alucina√ß√µes, quality scorer multi-dimensional, e cen√°rios real√≠sticos com personalidades de cliente configur√°veis.",
      "metrics": {
        "analyzers": "Analyzers",
        "personalities": "Personalidades",
        "realtime": "Real-time",
        "multichannel": "Multi",
        "websocket": "WebSocket",
        "channel": "Channel"
      },
      "nav": {
        "problem": "Problema",
        "interface": "Interface",
        "hallucination": "Hallucination Detector",
        "quality": "Quality Scorer",
        "scenarios": "Cen√°rios",
        "runner": "Test Runner"
      },
      "problem": {
        "title": "O Problema",
        "description": "Testar sistemas de AI conversacional √© fundamentalmente diferente de testar software tradicional. Outputs s√£o probabil√≠sticos, contexto importa, e \"correto\" √© subjetivo.",
        "challengesTitle": "Desafios Espec√≠ficos de AI Testing",
        "challenges": {
          "hallucinations": "AI inventa informa√ß√µes que parecem plaus√≠veis mas s√£o falsas. Em contexto m√©dico/dental, isso √© perigoso.",
          "consistency": "Mesma pergunta pode gerar respostas diferentes. Como testar isso?",
          "multiTurn": "Resposta no turno 5 depende dos turnos 1-4. Testes isolados n√£o capturam isso.",
          "subjectivity": "\"Boa resposta\" depende de tom, empatia, completude ‚Äî m√©tricas dif√≠ceis de quantificar."
        },
        "solution": "A solu√ß√£o foi criar uma suite de ferramentas especializadas: interface de simula√ß√£o para testes manuais, analisadores autom√°ticos para detec√ß√£o de problemas, e um framework de cen√°rios real√≠sticos para testes de regress√£o."
      },
      "interface": {
        "title": "Interface de Simula√ß√£o",
        "description": "Interface web Flask + SocketIO para testes manuais interativos. Simula diferentes canais (WhatsApp, Web, API) com headers corretos, gerencia handover, e mostra m√©tricas em tempo real.",
        "features": {
          "channelProfiles": {
            "title": "Channel Profiles",
            "description": "WhatsApp, Web, API ‚Äî cada um com headers espec√≠ficos (X-Request-Source)."
          },
          "handover": {
            "title": "Handover Management",
            "description": "Takeover, Return to AI, Operator Messages ‚Äî testa fluxo completo."
          },
          "multiSession": {
            "title": "Multi-Session",
            "description": "M√∫ltiplas sess√µes simult√¢neas para simular carga."
          },
          "realtime": {
            "title": "Real-time",
            "description": "WebSocket para feedback instant√¢neo de respostas."
          }
        },
        "scenariosTitle": "Cen√°rios de Teste Embutidos"
      },
      "hallucination": {
        "title": "Hallucination Detector",
        "description": "Detecta alucina√ß√µes e erros factuais nas respostas. Cr√≠tico para contexto m√©dico/dental onde informa√ß√£o falsa pode causar danos reais.",
        "typesTitle": "Tipos de Alucina√ß√£o Detectados",
        "types": {
          "factualError": {
            "title": "factual_error",
            "description": "Informa√ß√£o contradiz fatos conhecidos (ex: \"limpeza custa R$5000\")."
          },
          "inventedInfo": {
            "title": "invented_info",
            "description": "AI inventa detalhes espec√≠ficos n√£o fornecidos (ex: nome do dentista)."
          },
          "impossibleClaim": {
            "title": "impossible_claim",
            "description": "Afirma√ß√µes logicamente imposs√≠veis (ex: \"consulta de 5 minutos\")."
          },
          "medicalMisinfo": {
            "title": "medical_misinformation",
            "description": "Informa√ß√£o m√©dica incorreta ou perigosa."
          }
        },
        "knowledgeBaseTitle": "Knowledge Base para Valida√ß√£o"
      },
      "quality": {
        "title": "Quality Scorer",
        "description": "Avalia qualidade das respostas em m√∫ltiplas dimens√µes. N√£o √© s√≥ \"certo ou errado\" ‚Äî √© legibilidade, relev√¢ncia, empatia, completude, tom.",
        "dimensionsTitle": "Dimens√µes de Qualidade",
        "dimensions": {
          "readability": "N√≠vel Flesch-Kincaid de leitura. Respostas devem ser acess√≠veis ao p√∫blico geral.",
          "empathy": "Detecta indicadores de empatia: \"entendo\", \"compreendo\", \"sinto muito\".",
          "callToAction": "Resposta leva a pr√≥ximos passos? \"agende\", \"ligue\", \"visite\".",
          "professionalLanguage": "Uso de termos profissionais: \"consulta\", \"tratamento\", \"procedimento\"."
        },
        "detractorsTitle": "Detratores de Qualidade (reduzem score)"
      },
      "scenarios": {
        "title": "Cen√°rios Real√≠sticos",
        "description": "Gera√ß√£o de cen√°rios de teste com diferentes n√≠veis de complexidade e personalidades de cliente. Permite testes sistem√°ticos de edge cases e regress√µes.",
        "validationsTitle": "Valida√ß√µes de Cen√°rio"
      },
      "runner": {
        "title": "Test Suite Runner",
        "description": "Orquestrador de testes com suporte a paraleliza√ß√£o, coverage, e relat√≥rios HTML. Integra com pytest e oferece CLI rica via Rich.",
        "markersTitle": "Custom Pytest Markers",
        "markers": {
          "slow": {
            "title": "{'@'}pytest.mark.slow",
            "description": "Testes lentos, pulados por padr√£o. Use --runslow para incluir."
          },
          "integration": {
            "title": "{'@'}pytest.mark.integration",
            "description": "Testes que precisam de servi√ßos rodando."
          },
          "aiQuality": {
            "title": "{'@'}pytest.mark.ai_quality",
            "description": "Testes de qualidade AI (alucina√ß√£o, quality score)."
          },
          "security": {
            "title": "{'@'}pytest.mark.security",
            "description": "Testes de seguran√ßa (SQL injection, XSS)."
          }
        }
      },
      "techStack": "Stack T√©cnico",
      "results": {
        "title": "Resultados",
        "metrics": {
          "analyzers": "Analisadores especializados",
          "coverage": "Cobertura de cen√°rios cr√≠ticos",
          "hallucinations": "Alucina√ß√µes em produ√ß√£o",
          "realtime": "Feedback via WebSocket"
        }
      },
      "cta": {
        "title": "Explore Outros Case Studies",
        "description": "Veja como outros componentes do Optimus foram constru√≠dos"
      },
      "footer": "Case Study: AI Testing Tools ‚Äî Optimus AI Platform",
      "meta": {
        "title": "AI Testing Tools - Optimus AI | Marcelo Marleta",
        "description": "Case study: Suite de testes para AI conversacional com detector de alucina√ß√µes, quality scorer, cen√°rios real√≠sticos e interface de simula√ß√£o multi-canal."
      }
    },
    "infraDevops": {
      "back": "Voltar",
      "platformName": "Optimus AI Platform",
      "badge": "Infrastructure & DevOps",
      "badgeSecondary": "Platform Engineering",
      "title": "Infrastructure &",
      "titleHighlight": "DevOps Pipeline",
      "description": "Arquitetura containerizada production-grade com scaling horizontal autom√°tico, alta disponibilidade via Redis Sentinel, e CI/CD com valida√ß√£o de arquitetura integrada. Da prototipa√ß√£o ao scaling de m√∫ltiplas inst√¢ncias sem downtime.",
      "metrics": {
        "microservices": "Microservi√ßos",
        "composeOverlays": "Compose Overlays",
        "sentinelsHa": "Sentinels HA",
        "workflowsCicd": "Workflows CI/CD"
      },
      "nav": {
        "problem": "Problema",
        "containers": "Containers",
        "scaling": "Scaling",
        "ha": "Alta Disponibilidade",
        "cicd": "CI/CD",
        "security": "Seguran√ßa",
        "operations": "Opera√ß√µes",
        "results": "Resultados"
      },
      "problem": {
        "title": "O Problema",
        "description": "Plataformas AI multi-tenant t√™m caracter√≠sticas √∫nicas que complicam infraestrutura tradicional: workloads altamente vari√°veis (um prompt pode levar 100ms ou 30s), depend√™ncia cr√≠tica de servi√ßos externos (LLMs, WhatsApp), e a necessidade de isolar tenants enquanto compartilha recursos eficientemente.",
        "challengesTitle": "Desafios Espec√≠ficos",
        "challenges": {
          "spikyTraffic": "Campanhas de marketing podem 10x o tr√°fego em minutos ‚Äî precisa escalar r√°pido e voltar sem desperdi√ßar recursos",
          "statefulServices": "Memory Engine e pgvector precisam de connection pools controlados ‚Äî n√£o √© s√≥ \"spawn more containers\" e pronto",
          "redisSPOF": "Cache, sessions, queues, rate limiting ‚Äî tudo passa pelo Redis. Precisa de HA real",
          "microservices": "Orquestrar deploys coordenados sem breaking changes entre servi√ßos de vers√µes diferentes",
          "secretsSprawl": "40+ API keys de LLMs, webhooks, databases ‚Äî precisam de rota√ß√£o sem downtime"
        },
        "solution": "A solu√ß√£o foi constru√≠da iterativamente: come√ßou com docker-compose monol√≠tico, evoluiu para overlays por ambiente, depois scaling horizontal com nginx LB, e finalmente Redis Sentinel para HA. Cada passo foi motivado por necessidades reais de produ√ß√£o."
      },
      "containers": {
        "title": "Arquitetura de Containers",
        "description": "Dockerfiles seguem padr√µes production-grade: multi-stage builds para imagens menores, usu√°rios non-root para seguran√ßa, BuildKit cache mounts para builds r√°pidos, e health checks que realmente testam a aplica√ß√£o (n√£o s√≥ se o processo existe).",
        "dockerfileTitle": "Production Patterns",
        "overlaysTitle": "Docker Compose Overlays",
        "overlaysDescription": "Em vez de um docker-compose.yml monol√≠tico, usamos overlays que comp√µem configura√ß√µes. Isso permite que desenvolvimento, staging e produ√ß√£o compartilhem a base mas customizem o que precisam ‚Äî sem duplica√ß√£o e sem drift acidental.",
        "overlays": {
          "base": "Base: todos os servi√ßos, volumes, networks. Configura√ß√£o comum que funciona em qualquer ambiente.",
          "scale": "Overlay: nginx-lb, job de migrations separado, portas removidas (tudo via LB), WEB_CONCURRENCY configur√°vel.",
          "sentinel": "Overlay: topologia Redis master/replica/sentinel para HA. Servi√ßos recebem vars REDIS_SENTINEL_*.",
          "dev": "Overlay: volumes de c√≥digo montados, debug habilitado, hot reload, portas expostas diretamente."
        },
        "compositionTitle": "Composi√ß√£o de Overlays",
        "resourceLimitsTitle": "Resource Limits & Reservations"
      },
      "scaling": {
        "title": "Scaling Horizontal",
        "description": "Sistema de scaling que vai de 1 a N inst√¢ncias sem mudan√ßa de c√≥digo. Load balancer nginx distribui tr√°fego, session affinity via Redis, e health checks determinam routing.",
        "nginxTitle": "Nginx Load Balancer",
        "scriptTitle": "Script de Scaling",
        "sessionAffinityTitle": "Session Affinity",
        "architectureTitle": "Arquitetura de Scaling",
        "externalTraffic": "External Traffic",
        "dynamicDns": "least_conn + dynamic DNS",
        "nginxLbTitle": "Nginx Load Balancer",
        "migrationJobTitle": "Migration Job Isolado",
        "migrationJobDescription": "Quando voc√™ escala servi√ßos, todos tentam rodar migrations ao iniciar ‚Äî race condition garantida. A solu√ß√£o foi um job dedicado que roda ANTES das replicas subirem, usando depends_on: condition: service_completed_successfully.",
        "scaleUpScriptTitle": "Scale-Up Script",
        "statefulConsiderations": {
          "title": "Considera√ß√µes Stateful",
          "description": "Memory Engine √© stateful ‚Äî mant√©m connection pools com PostgreSQL. Escalar de 2 para 6 replicas cria 6x mais conex√µes ao banco. Por isso configuramos DB_POOL_SIZE e DB_MAX_OVERFLOW via env vars, permitindo ajuste din√¢mico: DB_POOL_SIZE=5 DB_MAX_OVERFLOW=10 = m√°x 15 conex√µes/replica."
        }
      },
      "ha": {
        "title": "Alta Disponibilidade",
        "description": "Redis Sentinel para failover autom√°tico. Tr√™s sentinels monitoram o master e promovem replica automaticamente em caso de falha.",
        "topologyTitle": "Topologia Sentinel",
        "failoverTitle": "Failover Autom√°tico",
        "clientConfigTitle": "Configura√ß√£o do Cliente",
        "quorum": "quorum: 2 (2 de 3 precisam concordar)",
        "monitors": "monitora",
        "writes": "(writes)",
        "reads": "(reads)",
        "failoverSteps": {
          "step1": "Master fica inacess√≠vel (crash, network partition, ou qualquer falha)",
          "step2": "Sentinels detectam (configurable timeout, default 30s)",
          "step3": "Quorum de 2 sentinels concorda que master est√° down",
          "step4": "Elei√ß√£o de novo master entre replicas (baseia-se em replication offset)",
          "step5": "Sentinels atualizam configura√ß√£o; clientes reconectam automaticamente"
        },
        "whyThreeSentinels": {
          "title": "Por que 3 Sentinels?",
          "description": "Com quorum de 2, voc√™ precisa de no m√≠nimo 3 sentinels para tolerar 1 falha. Se tiver s√≥ 2 sentinels e 1 falhar, n√£o atinge quorum e failover n√£o acontece. N√∫mero √≠mpar evita split-brain (empate de votos)."
        }
      },
      "cicd": {
        "title": "CI/CD Pipeline",
        "description": "GitHub Actions com 12 workflows especializados. Cada PR passa por lint, type check, testes unit√°rios, e valida√ß√£o de arquitetura antes de merge.",
        "workflowsTitle": "Workflows Principais",
        "workflows": {
          "lint": "Lint & Format: black, isort, flake8, mypy",
          "test": "Testes: pytest com coverage m√≠nimo de 80%",
          "build": "Build: Docker multi-stage com cache",
          "deploy": "Deploy: Rolling update com health checks",
          "ci": {
            "title": "ci.yml",
            "description": "Ruff lint, mypy type-check, pytest, Docker build. Roda em todo push/PR."
          },
          "guardrails": {
            "title": "guardrails.yml",
            "description": "Valida√ß√£o de arquitetura. Bloqueia PRs que violam patterns definidos em policy.yaml."
          },
          "e2e": {
            "title": "e2e-tests.yml",
            "description": "Testes end-to-end com pgvector + Redis reais. Valida fluxos multi-ERP."
          },
          "llmEval": {
            "title": "llm-eval.yml",
            "description": "Avalia√ß√£o de qualidade de outputs do AI Engine. Detecta regress√µes em prompts."
          }
        },
        "archGuardsTitle": "Architecture Guards",
        "guardrailsTitle": "Architecture Guardrails",
        "guardrailsDescription": "O sistema de guardrails usa um MCP server que analisa diffs e valida contra regras. Se um PR viola um pattern (ex: import direto entre camadas, SQL raw em controllers), o workflow falha e posta um coment√°rio detalhado no PR.",
        "e2eTestsTitle": "E2E Tests com Services"
      },
      "security": {
        "title": "Seguran√ßa",
        "description": "M√∫ltiplas camadas de seguran√ßa: secrets management, network isolation, e scanning automatizado.",
        "secretsTitle": "Secrets Management",
        "networkTitle": "Network Isolation",
        "scanningTitle": "Scanning Automatizado",
        "secretsSeparationTitle": "Separa√ß√£o de Secrets",
        "secretsFiles": {
          "secrets": "API keys, passwords, tokens. Nunca commitado. Gitignore'd.",
          "models": "Configura√ß√µes de modelos LLM. Pode ser commitado (sem keys).",
          "example": "Template com placeholders. Commitado para documenta√ß√£o."
        },
        "containerSecurityTitle": "Container Security",
        "containerSecurity": {
          "nonRoot": "Todos os containers rodam como usu√°rio n√£o-root (appuser:1001 ou similar). Mitiga privilege escalation.",
          "slimImages": "python:3.12-slim em vez de full. Menos pacotes = menos superf√≠cie de ataque.",
          "readOnlyConfigs": "Arquivos de config montados como :ro (read-only). Containers n√£o podem modificar.",
          "networkIsolation": "Rede bridge dedicada (optimus). Services s√≥ acess√≠veis via LB.",
          "internalEngine": "Porta 8050 n√£o exposta ao host ‚Äî s√≥ acess√≠vel via nginx-lb internamente."
        }
      },
      "operations": {
        "title": "Opera√ß√µes",
        "description": "Ferramentas de opera√ß√£o para gerenciar o ciclo de vida dos servi√ßos.",
        "backupTitle": "Backup & Restore",
        "logsTitle": "Log Aggregation",
        "monitoringTitle": "Monitoring",
        "scripts": {
          "scaleUp": {
            "title": "scale-up.sh",
            "description": "Scaling completo com build, migrations, e tail de logs."
          },
          "validateRedis": {
            "title": "validate_redis.sh",
            "description": "Health check de Redis: ping, memory, connected clients."
          },
          "loadTests": {
            "title": "run_load_tests.sh",
            "description": "Load testing com k6 ou locust. Gera relat√≥rio."
          },
          "traceSmokeTest": {
            "title": "trace_smoke_test.sh",
            "description": "Valida tracing E2E: gera trace, verifica no Tempo."
          }
        },
        "healthChecksTitle": "Health Checks √öteis"
      },
      "techStack": "Stack T√©cnico",
      "results": {
        "title": "Resultados",
        "metrics": {
          "uptime": "Uptime",
          "deployTime": "Deploy Time",
          "scalingTime": "Scaling Time",
          "mttr": "MTTR",
          "secretsExposed": "Secrets expostos (valida√ß√£o autom√°tica)",
          "failover": "Failover autom√°tico Redis"
        },
        "lessonsLearned": {
          "title": "Li√ß√µes Aprendidas",
          "overlays": "Compose overlays > monol√≠tico: Manuten√ß√£o muito mais f√°cil quando cada concern est√° isolado",
          "migrations": "Migrations job separado: Evita race conditions e permite escalar replicas livremente",
          "healthChecks": "Health checks reais: Testar o endpoint /health, n√£o s√≥ se o processo existe",
          "dynamicDns": "DNS din√¢mico no LB: Sem isso, nginx n√£o descobre novas replicas",
          "sentinelQuorum": "Sentinel quorum √≠mpar: 3 sentinels com quorum 2 √© o m√≠nimo para HA real"
        }
      },
      "cta": {
        "title": "Explore Outros Case Studies",
        "description": "Veja como outros componentes do Optimus foram constru√≠dos"
      },
      "footer": "Case Study: Infrastructure & DevOps ‚Äî Optimus AI Platform",
      "meta": {
        "title": "Infrastructure & DevOps - Optimus AI | Marcelo Marleta",
        "description": "Case study: Arquitetura containerizada com scaling horizontal, Redis Sentinel HA, e CI/CD com valida√ß√£o de arquitetura."
      }
    },
    "frontend": {
      "backToPortfolio": "Voltar ao Portfolio",
      "badge": "User Interface",
      "title": "Frontend Apps",
      "description": "Duas aplica√ß√µes Vue.js 3 especializadas: Admin Dashboard para operadores de cada tenant e SuperAdmin Panel para gest√£o global da plataforma. WebSocket real-time, gest√£o de handover, e interfaces responsivas.",
      "architectureTitle": "Arquitetura: 2 Apps, 2 Prop√≥sitos",
      "rbac": {
        "title": "RBAC (Role-Based Access Control)",
        "admin": "admin ‚Üí Acesso ao Admin App (3000) do seu tenant",
        "superadmin": "superadmin ‚Üí Acesso ao SuperAdmin (3001) + todos os tenants"
      },
      "adminDashboard": {
        "title": "Admin Dashboard",
        "port": "Port 3000",
        "description": "Interface para operadores e administradores de cada tenant. Foco em atendimento ao cliente e gest√£o do dia-a-dia.",
        "featuresTitle": "Features:",
        "features": {
          "chat": "Chat em tempo real com clientes (WebSocket)",
          "handover": "Gest√£o de handover (timer auto-return 30min)",
          "dashboard": "Dashboard de m√©tricas do tenant",
          "conversations": "Lista de conversas ativas",
          "history": "Hist√≥rico de atendimentos",
          "notifications": "Notifica√ß√µes de novas mensagens"
        }
      },
      "superAdminPanel": {
        "title": "SuperAdmin Panel",
        "port": "Port 3001",
        "description": "Interface para gest√£o global da plataforma. Configura√ß√£o, provisionamento de tenants, e monitoramento.",
        "featuresTitle": "Features:",
        "features": {
          "tenants": "Gerenciamento de tenants (CRUD)",
          "users": "Gest√£o de usu√°rios e permiss√µes",
          "config": "Configura√ß√£o global da plataforma",
          "monitoring": "Monitoramento cross-tenant",
          "analytics": "Analytics e relat√≥rios",
          "provisioning": "Provisionamento de novos tenants",
          "prompts": "Configura√ß√£o de prompts por tenant",
          "llmPools": "LLM Pools & Key Groups management",
          "preflight": "Preflight panel (health checks)",
          "defaults": "System defaults (global configs)"
        }
      },
      "websocket": {
        "title": "WebSocket Real-time",
        "description": "Comunica√ß√£o bidirecional para atualiza√ß√µes instant√¢neas.",
        "events": {
          "newMessage": "new_message: Nova mensagem de cliente",
          "statusChange": "status_change: Mudan√ßa de status de conversa",
          "handoverUpdate": "handover_update: Atualiza√ß√£o de handover"
        }
      },
      "handover": {
        "title": "Gest√£o de Handover",
        "description": "Sistema completo de transfer√™ncia AI ‚Üî Humano.",
        "features": {
          "takeover": "Takeover manual pelo operador",
          "autoReturn": "Auto-return ap√≥s 30min de inatividade",
          "history": "Hist√≥rico de transfer√™ncias"
        }
      },
      "components": {
        "title": "Componentes Reutiliz√°veis",
        "description": "Biblioteca de componentes Vue.js compartilhados entre as duas aplica√ß√µes."
      },
      "techStack": {
        "title": "Stack T√©cnico",
        "framework": "Framework",
        "styling": "Styling",
        "state": "State",
        "realtime": "Real-time",
        "router": "Router",
        "http": "HTTP",
        "build": "Build",
        "container": "Container",
        "backendIntegration": {
          "title": "Integra√ß√£o com Backend",
          "restApis": "REST APIs",
          "websocket": "WebSocket"
        }
      },
      "cta": {
        "title": "Explore Outros Case Studies",
        "description": "Veja como outros componentes do Optimus foram constru√≠dos",
        "button": "Entrar em Contato"
      },
      "footer": "Case Study: Frontend Apps ‚Äî Optimus AI Platform",
      "meta": {
        "title": "Frontend Apps - Optimus AI | Marcelo Marleta",
        "description": "Case study: Aplica√ß√µes Vue.js 3 para gest√£o de atendimento com WebSocket real-time e RBAC."
      },
      "chatRealtime": {
        "title": "Chat Real-time com WebSocket",
        "description": "A interface de chat usa WebSocket para atualiza√ß√µes em tempo real. Quando uma nova mensagem chega (WhatsApp, web, etc.), o operador v√™ instantaneamente sem refresh.",
        "flowTitle": "Fluxo WebSocket",
        "eventsTitle": "Eventos Suportados",
        "events": {
          "newMessage": "Nova mensagem na conversa",
          "conversationUpdated": "Status ou metadata alterados",
          "handoverStarted": "Operador assumiu conversa",
          "handoverEnded": "Conversa retornou para IA",
          "typing": "Cliente est√° digitando"
        }
      },
      "handoverManagement": {
        "title": "Handover Management",
        "description": "Quando um operador assume uma conversa (handover), a UI mostra um timer de 30 minutos. Se n√£o houver intera√ß√£o, a conversa retorna automaticamente para a IA.",
        "states": {
          "aiServing": {
            "title": "1. IA Atendendo",
            "description": "Estado normal. IA responde automaticamente. Operador pode visualizar mas n√£o interv√©m."
          },
          "handoverActive": {
            "title": "2. Handover Ativo",
            "description": "Operador assumiu. Timer de 30 min vis√≠vel. IA pausa, mensagens v√£o direto pro operador."
          },
          "timerExpires": {
            "title": "3. Timer Expira",
            "description": "Sem a√ß√£o em 30min ‚Üí auto-return para IA. Operador √© notificado antes (warning em 5min)."
          }
        },
        "timerUiTitle": "Timer UI Component",
        "extend": "Estender +15min",
        "returningSoon": "Retorno em breve!",
        "timeRemaining": "Tempo restante"
      },
      "superAdminFeatures": {
        "title": "SuperAdmin: Gest√£o Global",
        "tenantManagement": {
          "title": "Gest√£o de Tenants",
          "list": "Lista de tenants com status, vertical, e √∫ltima atividade",
          "create": "Criar tenant via wizard (escolhe vertical, configura identity)",
          "edit": "Editar tenant (nome, timezone, locale, features)",
          "deactivate": "Desativar/Deletar com confirma√ß√£o e soft-delete"
        },
        "promptConfig": {
          "title": "Configura√ß√£o de Prompts",
          "systemPrompt": "System prompt customizado por tenant",
          "greeting": "Greeting message (primeira mensagem da IA)",
          "intent": "Intent classification prompt",
          "handoverContext": "Handover context (resumo para operador)",
          "variables": "Variables override (assistant_name, rules, etc.)"
        },
        "llmPools": {
          "title": "LLM Pools & Keys",
          "globalPools": "Pools globais (chat, tools, embeddings)",
          "keyGroups": "Key Groups com m√∫ltiplas API keys",
          "reveal": "Reveal protegido (s√≥ superadmin v√™ keys)",
          "health": "Health status de cada key/pool"
        },
        "preflightPanel": {
          "title": "Preflight Panel",
          "ok": "OK - Todas configs v√°lidas",
          "warning": "Warning - Usando defaults gen√©ricos",
          "critical": "Critical - Falta assistant_name ou template vazio",
          "sourceBadges": "Source badges - Seeded vs Override vs Default"
        }
      },
      "dashboard": {
        "title": "Dashboard Multi-tenant",
        "description": "O Admin Dashboard mostra m√©tricas espec√≠ficas do tenant logado. Conversas ativas, tempo m√©dio de resposta, handovers, e mais.",
        "metrics": {
          "conversationsToday": "Conversas Hoje",
          "activeNow": "Ativas Agora",
          "inHandover": "Em Handover",
          "responseTime": "Tempo Resposta"
        },
        "conversationsList": {
          "title": "Lista de Conversas",
          "lastMsg": "√öltima msg",
          "aiResponding": "IA Respondendo",
          "handover": "Handover",
          "operator": "Operador"
        }
      },
      "results": {
        "title": "Resultados",
        "websocketLatency": "Lat√™ncia WebSocket",
        "websocketLatencyDesc": "Mensagens em tempo real",
        "specializedApps": "Apps Especializadas",
        "specializedAppsDesc": "Admin + SuperAdmin",
        "accessControl": "Controle de Acesso",
        "accessControlDesc": "admin vs superadmin",
        "autoReturnHandover": "Auto-return Handover",
        "autoReturnHandoverDesc": "Timer configur√°vel"
      }
    },
    "pricing": {
      "back": "‚Üê Voltar",
      "badge": "RAG + ML",
      "title": "Pricing Intelligence",
      "description": "Sistema de consulta de pre√ßos com RAG otimizado, threshold adaptativo, request coalescing e cache multi-tier para respostas sub-segundo.",
      "metrics": {
        "precision": "Precis√£o",
        "cacheHit": "Cache Hit",
        "cacheRate": "Cache Rate",
        "embeddingDim": "Embedding Dim"
      },
      "problem": {
        "title": "O Problema",
        "intro": "Consultas de pre√ßo em cl√≠nicas s√£o complexas: pacientes perguntam usando nomes diferentes (\"raio-x\", \"radiografia\", \"rx dental\"), com erros de digita√ß√£o, e esperam respostas instant√¢neas. RAG tradicional falha em:",
        "fuzzyMatching": "Matching fuzzy de nomes de procedimentos",
        "multipleItems": "M√∫ltiplos itens na mesma pergunta (\"quanto custa limpeza e clareamento?\")",
        "acceptableLatency": "Lat√™ncia aceit√°vel sob carga (thundering herd)"
      },
      "solution": {
        "title": "A Solu√ß√£o",
        "pricingFastLane": {
          "title": "Pricing Fast Lane",
          "description": "Bypass otimizado que detecta inten√ß√£o de pre√ßo e executa busca direta, sem passar pelo loop completo do agent:",
          "fastLaneComment": "# Fast Lane Flow",
          "normalFlowComment": "# vs Normal Flow"
        },
        "adaptiveThreshold": {
          "title": "Adaptive Threshold v2",
          "description": "Threshold de similaridade din√¢mico baseado nas caracter√≠sticas da query:",
          "shortQuery": "Query curta",
          "mediumQuery": "Query m√©dia",
          "longQuery": "Query longa",
          "shortQueryDesc": "(&lt;3 palavras): threshold mais baixo (0.75)",
          "numbersQuery": "Query com n√∫meros",
          "numbersQueryDesc": "threshold ajustado para abbreviations",
          "multiItemQuery": "Query multi-item",
          "multiItemQueryDesc": "threshold relaxado + diversifica√ß√£o",
          "llmOverride": "LLM override",
          "llmOverrideDesc": "modelo pode sugerir threshold espec√≠fico"
        },
        "requestCoalescing": {
          "title": "Request Coalescing",
          "description": "M√∫ltiplas requests para o mesmo procedimento s√£o agrupadas em uma √∫nica busca:",
          "intro": "Quando m√∫ltiplas requests chegam para a mesma query:",
          "step1": "Primeira request adquire lock e computa resultado",
          "step2": "Requests subsequentes aguardam (com timeout)",
          "step3": "Resultado √© compartilhado entre todas",
          "step4": "Cache √© populado para pr√≥ximas requests"
        }
      },
      "cacheArchitecture": {
        "title": "Arquitetura de Cache",
        "description": "Cache multi-tier com TTLs diferenciados por tipo de dado."
      },
      "intelligentCacheKey": {
        "title": "Cache Key Inteligente",
        "description": "Normaliza√ß√£o de queries para maximizar cache hits.",
        "intro": "Em vez de hash da query bruta (que falha com varia√ß√µes), usamos",
        "semanticSignature": "assinatura sem√¢ntica",
        "basedOnItems": "baseada nos itens detectados:",
        "traditional": "Cache Key Tradicional",
        "semantic": "Cache Key Sem√¢ntica"
      },
      "techStack": "Stack T√©cnico",
      "cta": {
        "title": "Explore Outros Case Studies",
        "description": "Veja como outros componentes do Optimus foram constru√≠dos"
      },
      "footer": "Case Study: Pricing Intelligence ‚Äî Optimus AI Platform",
      "meta": {
        "title": "Pricing Intelligence - Optimus AI | Marcelo Marleta",
        "description": "Case study: Sistema de consulta de pre√ßos com RAG otimizado, threshold adaptativo e cache multi-tier."
      },
      "nextProject": "Pr√≥ximo: Document Processing ‚Üí"
    },
    "llmPool": {
      "back": "‚Üê Voltar",
      "badge": "Cost Optimization",
      "title": "LLM Pool Management",
      "description": "Sistema de gest√£o de pools LLM com separa√ß√£o tool-calling vs chat, rota√ß√£o autom√°tica de keys, fallback inteligente e 40% de redu√ß√£o de custos com lat√™ncia otimizada.",
      "metrics": {
        "costReduction": "Redu√ß√£o de Custo",
        "latencyP95": "Lat√™ncia p95",
        "availability": "Disponibilidade",
        "simultaneousProviders": "Providers Simult√¢neos"
      },
      "problem": {
        "title": "O Problema",
        "intro": "Sistemas de AI conversacional enterprise enfrentam desafios cr√≠ticos de custo e lat√™ncia:",
        "explosiveCosts": "Custos explosivos",
        "explosiveCostsDesc": "GPT-4 para tudo √© caro. Nem toda tarefa precisa do modelo mais poderoso",
        "toolCallingExpensive": "Tool-calling √© caro",
        "toolCallingExpensiveDesc": "Modelos que suportam function calling custam mais que modelos simples",
        "rateLimits": "Rate limits",
        "rateLimitsDesc": "Uma √∫nica API key atinge limites rapidamente em produ√ß√£o",
        "vendorLockIn": "Vendor lock-in",
        "vendorLockInDesc": "Depend√™ncia de um √∫nico provider (OpenAI) √© arriscado",
        "keyManagement": "Gest√£o de keys",
        "keyManagementDesc": "API keys em c√≥digo ou env vars √© inseguro"
      },
      "solution": {
        "title": "A Solu√ß√£o",
        "poolArchitecture": {
          "title": "Arquitetura de Pools Separados",
          "intro": "Sistema de pools com separa√ß√£o expl√≠cita entre",
          "chatPool": "Chat Pool",
          "chatPoolOptimized": "Modelo otimizado para conversa√ß√£o",
          "chatPoolLowerCost": "Custo mais baixo (gpt-4o-mini)",
          "chatPoolHumanized": "Usado para respostas humanizadas",
          "toolsPool": "Tools Pool",
          "toolsPoolFunctionCalling": "Modelo com function calling",
          "toolsPoolHigherCost": "Custo mais alto (gpt-4o)",
          "toolsPoolOnlyWhenNeeded": "Usado s√≥ quando precisa chamar tools",
          "resultLabel": "Resultado",
          "chat": "chat",
          "chatDesc": "(conversa√ß√£o)",
          "and": "e",
          "tools": "tools",
          "toolsDesc": "(function calling)",
          "resultText": "40% de redu√ß√£o de custos usando modelo barato para chat e modelo premium s√≥ para opera√ß√µes que realmente precisam de tool calling."
        },
        "keyGroups": {
          "title": "Key Groups",
          "description": "Agrupamento de API keys com rota√ß√£o autom√°tica e rate limiting distribu√≠do.",
          "intro": "Separa√ß√£o entre pools (configura√ß√£o de modelo) e key groups (vault de chaves):",
          "fernetEncryption": "Criptografia Fernet",
          "fernetEncryptionDesc": "Chaves armazenadas criptografadas em repouso",
          "fingerprint": "Fingerprint",
          "fingerprintDesc": "UI mostra apenas fingerprint (sk-...7f2a), nunca a chave completa",
          "autoValidation": "Valida√ß√£o autom√°tica",
          "autoValidationDesc": "Sistema valida chaves periodicamente e marca status",
          "pools": "pools",
          "poolsDesc": "(configura√ß√£o de modelo)",
          "and": "e",
          "keyGroupsLabel": "key groups",
          "keyGroupsDesc": "(vault de chaves)"
        },
        "automaticSelection": {
          "title": "Sele√ß√£o Autom√°tica",
          "description": "Escolha inteligente de modelo baseada em tipo de tarefa, custo e disponibilidade.",
          "step1": "Request chega para pool",
          "step2": "Sistema busca key_group",
          "step3": "Filtra apenas chaves com",
          "step4": "Seleciona chave (round-robin ou random)",
          "step5": "Se rate limit ‚Üí marca cooldown ‚Üí tenta pr√≥xima chave"
        },
        "globalDefaults": {
          "title": "Defaults Globais",
          "description": "Configura√ß√£o centralizada com override por tenant."
        },
        "crossPoolFallback": {
          "title": "Fallback Cross-Pool",
          "description": "Se um pool falha, o sistema tenta automaticamente outro.",
          "exhausted": "Chat pool exausto (todas as chaves em rate limit)",
          "tryTools": "Tenta tools_pool (se suporta chat)",
          "tryGlobal": "Tenta global defaults",
          "success": "Request completa com lat√™ncia m√≠nima adicional",
          "quotaEnforcerLabel": "QuotaEnforcer",
          "quotaEnforcerText": "Tracked provider health com cooldown de 60s por chave."
        },
        "frontendIntegration": {
          "title": "Integra√ß√£o Frontend",
          "description": "Dashboard para monitoramento de custos e uso em tempo real.",
          "poolManagement": "Pool Management",
          "poolCrud": "CRUD de pools",
          "toggleTools": "Toggle <code>supports_tools</code>",
          "toggleActive": "Toggle <code>is_active</code>",
          "keyGroupSelection": "Sele√ß√£o de key_group",
          "keyManagement": "Key Management",
          "addRemoveKeys": "Adicionar/remover chaves",
          "revealVault": "Reveal com vault password",
          "batchValidation": "Valida√ß√£o em batch",
          "statusPerKey": "Status por chave (valid/invalid)"
        }
      },
      "architecture": {
        "title": "Arquitetura",
        "description": "Vis√£o geral do sistema de pools."
      },
      "decisions": {
        "title": "Decis√µes T√©cnicas",
        "separatePools": {
          "question": "Por que pools separados para chat vs tools?",
          "answer": "Modelos de tool-calling (GPT-4, Claude) custam 10-20x mais que modelos simples. Separar permite usar GPT-3.5 para conversa√ß√£o e reservar GPT-4 s√≥ para quando precisa chamar ferramentas."
        },
        "keyRotation": {
          "question": "Por que rota√ß√£o de keys?",
          "answer": "Rate limits s√£o por key. Com m√∫ltiplas keys rotacionando, o throughput efetivo multiplica. Tamb√©m permite revogar keys comprometidas sem downtime."
        },
        "vault": {
          "question": "Por que vault criptografado?",
          "answer": "API keys s√£o segredos cr√≠ticos. Armazenar em env vars ou c√≥digo √© vulner√°vel. Vault com encryption at-rest e audit logging √© enterprise-grade."
        },
        "fallback": {
          "question": "Por que fallback inteligente?",
          "answer": "Providers t√™m outages. Fallback autom√°tico para outro provider garante disponibilidade mesmo quando OpenAI est√° fora."
        }
      },
      "techStack": "Stack T√©cnico",
      "cta": {
        "title": "Explore Outros Case Studies",
        "description": "Veja como outros componentes do Optimus foram constru√≠dos"
      },
      "footer": "Case Study: LLM Pool Management ‚Äî Optimus AI Platform",
      "meta": {
        "title": "LLM Pool Management - Optimus AI | Marcelo Marleta",
        "description": "Case study: Sistema de gest√£o de pools LLM com separa√ß√£o tool-calling vs chat, rota√ß√£o de keys e 40% de redu√ß√£o de custos."
      },
      "technicalDecisions": {
        "title": "Decis√µes T√©cnicas",
        "whySeparate": "Por que separar pools e key groups?",
        "whySeparateAnswer": "Pools definem configura√ß√£o de modelo (model, temperature, supports_tools). Key groups definem credenciais (provider_type, base_url, keys). Essa separa√ß√£o permite reusar o mesmo vault de chaves em m√∫ltiplos pools com modelos diferentes.",
        "whyFailFast": "Por que fail-fast e n√£o fallback para env vars?",
        "whyFailFastAnswer": "Em produ√ß√£o, chaves em c√≥digo/env vars s√£o anti-pattern de seguran√ßa. Fail-fast for√ßa configura√ß√£o correta no sistema e evita \"funciona na minha m√°quina\" com chaves diferentes.",
        "whyCache60s": "Por que cache de 60s para provider configs?",
        "whyCache60sAnswer": "Balance entre consist√™ncia e performance. 60s √© suficiente para propagar mudan√ßas de configura√ß√£o sem bombardear Memory Engine a cada request. TTLCache com lock thread-safe.",
        "whyCooldown60s": "Por que QuotaEnforcer com cooldown de 60s?",
        "whyCooldown60sAnswer": "Rate limits de providers (OpenAI, Groq) tipicamente resetam em 60s. Cooldown evita retry storms que piorariam o rate limit. Cross-pool fallback garante continuidade."
      },
      "nextProject": "Pr√≥ximo: AI Conversation Engine ‚Üí"
    },
    "whatsapp": {
      "backToPortfolio": "Voltar ao Portfolio",
      "badge": "Messaging Infrastructure",
      "title": "WhatsApp Integration",
      "description": "Servi√ßo enterprise para WhatsApp com Message Aggregator inteligente, Redis isolado, graceful degradation e integra√ß√£o bidirecional com Evolution API.",
      "tags": {
        "aggregator": "Message Aggregator",
        "debounce": "5s Debounce",
        "evolution": "Evolution API",
        "redis": "Redis Isolado",
        "degradation": "Graceful Degradation",
        "websocket": "WebSocket"
      },
      "problem": {
        "title": "O Problema: \"Split Messages\" do WhatsApp",
        "naturalBehavior": "‚ùå Comportamento Natural dos Usu√°rios",
        "userFragmented": "Usu√°rios enviam pensamentos fragmentados em m√∫ltiplas mensagens r√°pidas. Isso √© comportamento normal no WhatsApp.",
        "normalBehavior": "Usu√°rios enviam pensamentos fragmentados em m√∫ltiplas mensagens r√°pidas. Isso √© comportamento normal no WhatsApp.",
        "inWhatsApp": "Usu√°rios enviam pensamentos fragmentados em m√∫ltiplas mensagens r√°pidas. Isso √© comportamento normal no WhatsApp.",
        "withoutAggregation": "Sem Agrega√ß√£o (caos):",
        "issue1": "5 chamadas √† API de IA para UMA inten√ß√£o",
        "issue2": "5 respostas confusas (\"Oi!\", \"Bem!\", \"Agendar o qu√™?\"...)",
        "issue3": "Custo de tokens 5x maior",
        "issue4": "UX horr√≠vel para o cliente"
      },
      "solution": {
        "title": "‚úÖ Message Aggregator (5s Debounce)",
        "messagesReceived": "// Mensagens recebidas em 14s...",
        "aggregatedIn": "// Agregadas em UMA mensagem:",
        "aggregatedResult": "\"Oi, tudo bem? Queria agendar uma consulta pra amanh√£ √†s 10h\"",
        "description": "O Message Aggregator espera 5 segundos ap√≥s cada mensagem.",
        "withAggregation": "Com Agrega√ß√£o (elegante):",
        "benefit1": "1 chamada √† API de IA com contexto completo",
        "benefit2": "1 resposta precisa (\"Perfeito! Agendei para amanh√£ 10h.\")",
        "benefit3": "Custo de tokens 5x menor",
        "benefit4": "UX natural e fluida",
        "extendsTimeout": "estende o timeout"
      },
      "aggregatorFlow": {
        "title": "üìä Fluxo do Message Aggregator",
        "timeline": "Message Aggregator Timeline",
        "message": "Mensagem",
        "timeout": "Timeout",
        "send": "ENVIAR",
        "timer": "5s timer",
        "reset": "RESET!",
        "timerExtended": "Timer estendido",
        "timerExpired": "Timer expirou",
        "aggregatedMessage": "Mensagem Agregada:",
        "backendOrch": "‚Üí Backend Orch.",
        "aiEngine": "‚Üí AI Engine"
      },
      "typingDetection": {
        "title": "üîÑ Typing Detection: O Segredo da Fluidez",
        "description": "O WhatsApp envia eventos de \"digitando...\" via webhook. O Message Aggregator",
        "realScenario": "Cen√°rio Real:",
        "step1": "Usu√°rio envia \"Oi\" ‚Üí timer 5s inicia",
        "step2": "Webhook: \"usu√°rio digitando\" ‚Üí timer pausado",
        "step3": "Usu√°rio envia \"quero agendar\" ‚Üí timer 5s reinicia",
        "step4": "Sem typing, timer expira ‚Üí mensagem agregada enviada",
        "result": "Resultado: O usu√°rio pode digitar no seu ritmo natural. O sistema \"espera\" inteligentemente at√© ele terminar o pensamento completo.",
        "safetyLimits": "Limites de Seguran√ßa",
        "maxTimeout": "Max Timeout Total",
        "maxMessages": "Max Mensagens por Agrega√ß√£o",
        "debounceBase": "Debounce Base",
        "limitsDesc": "Esses limites previnem DoS e garantem que mensagens n√£o fiquem \"presas\" indefinidamente se o usu√°rio ficar digitando sem parar.",
        "extendIntelligently": "estender o timeout inteligentemente",
        "resultDesc": "O usu√°rio pode digitar no seu ritmo natural. O sistema \"espera\" inteligentemente at√© ele terminar o pensamento completo."
      },
      "redisIsolated": {
        "title": "üîí Redis Isolado: Separa√ß√£o de Tr√°fego",
        "description": "WhatsApp gera <strong class=\"text-green-400\">muito tr√°fego de webhook</strong> -",
        "mixingBad": "Misturar isso com o Redis principal √© receita para disaster.",
        "archTitle": "REDIS ISOLATED ARCHITECTURE",
        "mainRedis": "üî¥ Redis Principal (Porta 6379/6380)",
        "aiEngineCache": "AI Engine ‚úÖ Cache de conversas",
        "orchestratorCache": "Backend Orchestrator ‚úÖ Rate limiting, cache",
        "memoryCache": "Memory Engine ‚úÖ Hot/Warm storage",
        "rulesCache": "Rules Engine ‚úÖ Cache de regras",
        "celeryQueues": "Celery Workers ‚úÖ Task queues",
        "whatsappRedis": "üü¢ Redis WhatsApp (Porta 6382) - ISOLADO",
        "whatsappOnly": "WhatsApp Integration ONLY",
        "messageBuffers": "Message buffers (agrega√ß√£o)",
        "typingState": "Typing state tracking",
        "webhookDedupe": "Webhook deduplication",
        "instanceMapping": "Instance ‚Üí Tenant mapping",
        "deliveryCache": "Delivery status cache",
        "benefits": "‚ö° Benef√≠cios:",
        "benefit1": "‚Ä¢ WhatsApp broadcast n√£o afeta cache de conversas",
        "benefit2": "‚Ä¢ Falha no Redis WhatsApp n√£o derruba sistema principal",
        "benefit3": "‚Ä¢ M√©tricas separadas para debugging",
        "benefit4": "‚Ä¢ Escala independente se necess√°rio",
        "faultIsolation": "üõ°Ô∏è",
        "faultIsolationTitle": "Isolamento de Falhas",
        "faultIsolationDesc": "Se Redis WhatsApp cair ou ficar lento, o sistema principal (AI, Memory, Rules) continua funcionando normalmente.",
        "separateMetrics": "üìä",
        "separateMetricsTitle": "M√©tricas Separadas",
        "separateMetricsDesc": "Monitoring independente: lat√™ncia do Redis WhatsApp n√£o polui m√©tricas do sistema core. Debug mais f√°cil.",
        "independentScale": "üìà",
        "independentScaleTitle": "Escala Independente",
        "independentScaleDesc": "Alta demanda de WhatsApp? Escala s√≥ o Redis WhatsApp. N√£o precisa mexer na infra principal.",
        "highWebhookTraffic": "muito tr√°fego de webhook"
      },
      "gracefulDegradation": {
        "title": "‚ö° Graceful Degradation: Sistema que n√£o cai",
        "description": "Sob alta carga, o sistema degrada",
        "degradesNonEssential": "features n√£o-essenciais",
        "toKeepCore": "para manter o core funcionando. N√≠veis configur√°veis de degrada√ß√£o.",
        "normal": "NORMAL",
        "normalUsers": "Usu√°rios &lt; 500",
        "normalFeature1": "‚úÖ Full aggregation (5s)",
        "normalFeature2": "‚úÖ Typing detection ativo",
        "normalFeature3": "‚úÖ WebSocket real-time",
        "normalFeature4": "‚úÖ Todas as features",
        "degradedLow": "DEGRADED_LOW",
        "degradedLowUsers": "500-2000 usu√°rios",
        "degradedLowFeature1": "‚ö†Ô∏è Aggregation reduzido (3s)",
        "degradedLowFeature2": "‚ö†Ô∏è Typing detection limitado",
        "degradedLowFeature3": "‚úÖ WebSocket ativo",
        "degradedLowFeature4": "‚ö†Ô∏è M√©tricas reduzidas",
        "degradedHigh": "DEGRADED_HIGH",
        "degradedHighUsers": "&gt; 2000 usu√°rios",
        "degradedHighFeature1": "‚ùå Aggregation m√≠nimo (1s)",
        "degradedHighFeature2": "‚ùå Typing detection off",
        "degradedHighFeature3": "‚ö†Ô∏è WebSocket pooled",
        "degradedHighFeature4": "‚ùå S√≥ m√©tricas cr√≠ticas",
        "configurableThresholds": "Thresholds Configur√°veis",
        "degradationBasedOn": "Degrada√ß√£o baseada em:",
        "pendingUsers": "N√∫mero de usu√°rios pendentes",
        "redisLatency": "Lat√™ncia do Redis",
        "webhookErrorRate": "Taxa de erros de webhook",
        "messageQueueSize": "Tamanho da fila de mensagens"
      },
      "deterministicId": {
        "title": "üéØ 1 Conversa por Telefone (Deterministic ID)",
        "description": "No WhatsApp, cada telefone = uma conversa. N√£o importa qual header chega,",
        "forSamePhone": "Isso elimina sess√µes paralelas e cross-user pollution.",
        "deterministicCalc": "C√°lculo Determin√≠stico",
        "example": "Exemplo:",
        "alwaysSameUuid": "SEMPRE o mesmo UUID para mesmos inputs",
        "ignoresHeaders": "Ignora headers externos completamente",
        "headersIgnored": "Headers de X-Conversation-ID s√£o <strong class=\"text-red-400\">ignorados</strong>.",
        "phoneNormalization": "Normaliza√ß√£o de Telefone",
        "allBecomeSameUuid": "// Todos viram o MESMO UUID:",
        "normalizedBefore": "// Phone √© normalizado antes do hash:",
        "removeSpaces": "// 1. Remove espa√ßos, h√≠fens, par√™nteses",
        "removePrefix": "// 2. Remove \"+\" prefix",
        "ensureNumeric": "// 3. Garante formato num√©rico puro",
        "noMatterHow": "N√£o importa como o telefone chega (WhatsApp, Evolution, manual), a normaliza√ß√£o garante consist√™ncia.",
        "alwaysCalculates": "sempre calcula o mesmo UUID",
        "ignored": "ignorados",
        "preventsHijack": ". Previne que um cliente malicioso \"pule\" para conversa de outro usu√°rio."
      },
      "handoverIntegration": {
        "title": "üë• Integra√ß√£o com Handover",
        "description": "Quando um atendente humano assume a conversa, o comportamento do",
        "duringHandover": "Durante Handover:",
        "aggregationPaused": "‚è∏Ô∏è",
        "aggregationPausedTitle": "Aggregation Pausado",
        "aggregationPausedDesc": "Mensagens do cliente v√£o direto pro operador, sem delay de 5s.",
        "immediateDelivery": "‚ö°",
        "immediateDeliveryTitle": "Immediate Delivery",
        "immediateDeliveryDesc": "Respostas do operador s√£o enviadas instantaneamente.",
        "websocketRealtime": "üîÑ",
        "websocketRealtimeTitle": "WebSocket Real-time",
        "websocketRealtimeDesc": "Frontend do operador recebe mensagens em tempo real.",
        "handoverConfig": "Configura√ß√£o Handover",
        "supportRealtime": "suportar intera√ß√£o em tempo real"
      },
      "evolutionApi": {
        "title": "üöÄ Evolution API Integration",
        "multiTenantInstances": "Multi-tenant Instances",
        "multiTenantDesc": "Cada tenant pode ter m√∫ltiplas inst√¢ncias WhatsApp. O sistema resolve automaticamente qual tenant \"dono\" de cada inst√¢ncia via cache O(1).",
        "instanceMapping": "// Instance ‚Üí Tenant mapping",
        "lookupO1": "// Lookup O(1) via Redis:",
        "webhookSecurity": "Webhook Security",
        "webhookSecurityDesc": "API keys s√£o validadas via HMAC com secret dedicado. Hash do API key (n√£o a key em si) √© cacheada para lookups r√°pidos.",
        "validationFlow": "// API Key validation flow:",
        "step1": "1. Webhook chega com X-API-Key header",
        "step2": "2. HMAC(apikey, EVOLUTION_SECRET) ‚Üí hash",
        "step3": "3. Redis lookup: apikeyhash:tenant:{hash}",
        "step4": "4. Se match ‚Üí autorizado",
        "step5": "5. Se n√£o ‚Üí schema scan (fallback)",
        "audioSupport": "üé§ Audio Message Support",
        "voiceNotes": "üéôÔ∏è",
        "voiceNotesTitle": "Voice Notes",
        "voiceNotesDesc": "Cliente envia √°udio ‚Üí Audio Processor transcreve ‚Üí Texto vai pro AI Engine",
        "audioReply": "üîä",
        "audioReplyTitle": "Audio Reply",
        "audioReplyDesc": "Resposta do AI ‚Üí TTS (Text-to-Speech) ‚Üí √Åudio enviado ao cliente",
        "minioStorage": "üìÅ",
        "minioStorageTitle": "MinIO Storage",
        "minioStorageDesc": "Arquivos de √°udio armazenados no MinIO para processamento ass√≠ncrono"
      },
      "results": {
        "title": "Resultados em Produ√ß√£o",
        "aiReduction": "~80%",
        "aiReductionLabel": "Redu√ß√£o de Chamadas IA",
        "aiReductionDesc": "Via message aggregation",
        "webhookLatency": "&lt;100ms",
        "webhookLatencyLabel": "Lat√™ncia Webhook",
        "webhookLatencyDesc": "P95 end-to-end",
        "redisIsolation": "100%",
        "redisIsolationLabel": "Isolamento Redis",
        "redisIsolationDesc": "Zero cross-pollution",
        "simultaneousUsers": "2000+",
        "simultaneousUsersLabel": "Usu√°rios Simult√¢neos",
        "simultaneousUsersDesc": "Antes de degradation",
        "techStack": "Stack T√©cnico",
        "framework": "Framework",
        "storage": "Storage",
        "realtime": "Real-time",
        "whatsappApi": "WhatsApp API",
        "audio": "Audio",
        "observability": "Observability",
        "rateLimiting": "Rate Limiting",
        "httpClient": "HTTP Client"
      },
      "cta": {
        "title": "Interessado em integra√ß√µes WhatsApp?",
        "description": "Message aggregation, webhooks, multi-tenant instances - tenho experi√™ncia pr√°tica com os desafios reais.",
        "contact": "Entrar em Contato"
      }
    },
    "audio": {
      "backToPortfolio": "Voltar ao Portfolio",
      "badge": "Media Processing",
      "title": "Audio Processor",
      "description": "Microsservi√ßo de processamento de √°udio com multi-provider STT/TTS, processamento ass√≠ncrono via Celery, storage MinIO e fallback inteligente entre providers.",
      "tags": {
        "multiProvider": "Multi-Provider",
        "groqWhisper": "Groq Whisper",
        "elevenLabs": "ElevenLabs",
        "celery": "Celery",
        "minio": "MinIO",
        "formats": "8 Formatos"
      },
      "challenge": {
        "title": "O Desafio: √Åudio em Chatbots Enterprise",
        "voiceNotes": "üé§ Voice Notes no WhatsApp",
        "voiceNotesDesc": "Usu√°rios de WhatsApp adoram enviar √°udios. Em alguns segmentos (cl√≠nicas,",
        "issue1": "√Åudios longos (1-3 minutos) com m√∫ltiplas informa√ß√µes",
        "issue2": "Sotaques regionais, ru√≠do de fundo, g√≠rias",
        "issue3": "Expectativa de resposta em √°udio tamb√©m",
        "commonProblems": "‚ö†Ô∏è Problemas Comuns",
        "problem1": "Single provider",
        "problem1Desc": "- se cair, sistema para",
        "problem2": "Processamento s√≠ncrono",
        "problem2Desc": "- bloqueia a thread",
        "problem3": "Sem fallback",
        "problem3Desc": "- erro = mensagem perdida",
        "problem4": "Custo fixo",
        "problem4Desc": "- mesmo provider pra tudo",
        "problem5": "Formatos limitados",
        "problem5Desc": "- s√≥ MP3/WAV",
        "audioPercentage": "mais de 40% das mensagens s√£o √°udio"
      },
      "architecture": {
        "title": "Arquitetura Multi-Provider",
        "diagramTitle": "Audio Processor Architecture",
        "whatsappVoice": "WhatsApp Voice Note",
        "webMobileAudio": "Web/Mobile Audio",
        "textResponse": "Text Response",
        "stt": "STT",
        "tts": "TTS",
        "primary": "Primary",
        "fallback": "Fallback",
        "storage": "Storage",
        "workers": "Workers",
        "sttTitle": "üé§ STT (Speech-to-Text)",
        "groqWhisperTitle": "Groq Whisper",
        "groqWhisperDesc": "Whisper Large v3 via Groq API. Extremamente r√°pido (hardware dedicado), excelente para portugu√™s brasileiro.",
        "openaiWhisperTitle": "OpenAI Whisper",
        "openaiWhisperDesc": "API oficial da OpenAI. Mais lento que Groq, mas extremamente confi√°vel como backup.",
        "otherProvidersTitle": "Google / Azure / AWS",
        "available": "Dispon√≠vel",
        "otherProvidersDesc": "Providers adicionais configur√°veis para casos espec√≠ficos ou requisitos de compliance.",
        "ttsTitle": "üîä TTS (Text-to-Speech)",
        "elevenLabsTitle": "ElevenLabs",
        "elevenLabsDesc": "Model: eleven_multilingual_v2. Vozes ultra-realistas, excelente entona√ß√£o em portugu√™s.",
        "openaiTtsTitle": "OpenAI TTS",
        "openaiTtsDesc": "Model: tts-1-hd, Voice: shimmer. Qualidade alta, bom backup quando ElevenLabs indispon√≠vel.",
        "edgeTtsTitle": "Edge TTS",
        "freeTier": "Free Tier",
        "edgeTtsDesc": "Voice: pt-BR-FranciscaNeural. Gratuito (Microsoft Edge), usado para desenvolvimento/testes ou fallback de emerg√™ncia."
      },
      "asyncProcessing": {
        "title": "‚ö° Processamento Ass√≠ncrono com Celery",
        "description": "√Åudio √© pesado. Um voice note de 2 minutos pode levar 5-10 segundos para transcrever. Processar sincronamente bloquearia o servidor. A solu√ß√£o: Celery workers dedicados.",
        "wouldBlock": "√Åudio √© pesado. Um voice note de 2 minutos pode levar 5-10 segundos para transcrever. Processar sincronamente bloquearia o servidor. A solu√ß√£o: Celery workers dedicados.",
        "step1Icon": "üì•",
        "step1Title": "1. Recebe √Åudio",
        "step1Desc": "API recebe o arquivo de √°udio (qualquer formato), valida e salva no MinIO. Retorna job_id imediatamente.",
        "step2Icon": "‚öôÔ∏è",
        "step2Title": "2. Celery Processa",
        "step2Desc": "Worker pega da fila, baixa do MinIO, converte formato se necess√°rio, envia pro provider STT, salva resultado.",
        "step3Icon": "üì§",
        "step3Title": "3. Callback/Poll",
        "step3Desc": "Resultado dispon√≠vel via polling (GET /status/job_id) ou webhook callback quando configurado.",
        "flowTitle": "Fluxo de Transcri√ß√£o",
        "clientSends": "# 1. Cliente envia √°udio",
        "immediateResponse": "# Response imediata (~50ms)",
        "workerProcesses": "# 2. Celery worker processa em background",
        "downloadingFrom": "[Worker] Downloading from MinIO:",
        "converting": "[Worker] Converting OGG ‚Üí WAV (ffmpeg)",
        "sendingTo": "[Worker] Sending to Groq Whisper...",
        "savingResult": "[Worker] Saving result to Redis",
        "clientChecks": "# 3. Cliente verifica status",
        "solution": ". A solu√ß√£o: Celery workers dedicados.",
        "transcriptionComplete": "[Worker] Transcription complete: \"Oi, quero marcar uma consulta...\""
      },
      "formats": {
        "title": "üéµ 8 Formatos de √Åudio Suportados",
        "description": "WhatsApp usa OGG/OPUS. Navegadores usam WebM. iPhones usam M4A. O Audio Processor aceita qualquer um e converte internamente via FFmpeg.",
        "mp3": "MP3",
        "mp3Desc": "Mais comum",
        "wav": "WAV",
        "wavDesc": "Sem compress√£o",
        "ogg": "OGG",
        "oggDesc": "WhatsApp Android",
        "opus": "OPUS",
        "opusDesc": "WhatsApp codec",
        "m4a": "M4A",
        "m4aDesc": "iPhone/AAC",
        "flac": "FLAC",
        "flacDesc": "Lossless",
        "aac": "AAC",
        "aacDesc": "Alta qualidade",
        "wma": "WMA",
        "wmaDesc": "Windows legacy",
        "autoConversion": "Convers√£o Autom√°tica",
        "autoConversionDesc": "O sistema detecta o formato automaticamente (magic bytes, n√£o extens√£o). Se o provider STT n√£o suporta o formato, converte para WAV via FFmpeg antes de enviar. Tudo transparente para o chamador."
      },
      "minio": {
        "title": "üì¶ Storage com MinIO",
        "whyMinio": "Por que MinIO?",
        "s3Compatible": "S3-compatible",
        "s3CompatibleDesc": "- mesma API do AWS S3, sem vendor lock",
        "selfHosted": "Self-hosted",
        "selfHostedDesc": "- dados ficam no seu controle",
        "highPerformance": "High performance",
        "highPerformanceDesc": "- otimizado para arquivos m√©dios",
        "webConsole": "Web console",
        "webConsoleDesc": "- UI para debug e gest√£o",
        "configuration": "Configura√ß√£o",
        "managementConsole": "# Console de gest√£o",
        "lifecycle": "Lifecycle do Arquivo",
        "upload": "üì•",
        "uploadTitle": "Upload",
        "uploadDesc": "Cliente envia",
        "store": "üíæ",
        "storeTitle": "Store",
        "storeDesc": "MinIO salva",
        "process": "‚öôÔ∏è",
        "processTitle": "Process",
        "processDesc": "Worker baixa, processa",
        "cleanup": "üóëÔ∏è",
        "cleanupTitle": "Cleanup",
        "cleanupDesc": "TTL expira, deleta"
      },
      "fallback": {
        "title": "üîÑ Fallback Inteligente",
        "description": "Providers de IA falham. Groq pode ter pico de lat√™ncia, ElevenLabs pode estar em manuten√ß√£o. O sistema tenta automaticamente o pr√≥ximo provider na cadeia de fallback.",
        "sttChain": "# Cadeia de fallback STT",
        "sttPrimary": "# Primary",
        "groqFailed": "Groq failed, falling back to OpenAI",
        "allSttFailed": "All STT providers failed",
        "ttsChain": "# Cadeia de fallback TTS",
        "ttsPrimary": "# Primary",
        "elevenLabsFailed": "ElevenLabs failed, falling back to OpenAI",
        "paidTtsFailed": "Paid TTS failed, using free Edge TTS",
        "alwaysAvailable": "# Always available",
        "timeoutIcon": "‚è±Ô∏è",
        "timeoutTitle": "Timeout Detection",
        "timeoutDesc": "Se provider n√£o responde em 30s, assume falha e tenta pr√≥ximo.",
        "quotaIcon": "üí∞",
        "quotaTitle": "Quota Handling",
        "quotaDesc": "Rate limit ou quota excedida? Fallback autom√°tico sem perder a mensagem.",
        "freeIcon": "üÜì",
        "freeTitle": "Free Tier Backup",
        "freeDesc": "Edge TTS √© gratuito e sempre dispon√≠vel como √∫ltimo recurso."
      },
      "tenantConfig": {
        "title": "üè¢ Configura√ß√£o por Tenant",
        "description": "Cada tenant pode ter configura√ß√µes de TTS personalizadas: voz diferente, provider preferido, velocidade de fala. Armazenado no Memory Engine e carregado em runtime.",
        "dentalClinic": "Exemplo: Cl√≠nica Dental",
        "ecommerce": "Exemplo: E-commerce"
      },
      "whatsappIntegration": {
        "title": "üì± Integra√ß√£o com WhatsApp",
        "diagramTitle": "WhatsApp Voice Note Flow",
        "clientSendsAudio": "Cliente envia √°udio",
        "audioProcessor": "Audio Processor",
        "aiEngine": "AI Engine",
        "evolutionApi": "Evolution API",
        "whatsappIntegration": "WhatsApp Integration",
        "celeryProcesses": "[Celery processa]",
        "clientReceivesAudio": "Cliente recebe √°udio",
        "responseMode": "Modo de Resposta Configur√°vel",
        "modeAudio": "audio",
        "modeAudioDesc": "Sempre responde em √°udio. Ideal para usu√°rios que preferem ouvir.",
        "modeText": "text",
        "modeTextDesc": "Sempre responde em texto. Economia de custo de TTS.",
        "modeMatch": "match",
        "modeMatchDesc": "Responde no mesmo formato que recebeu (√°udio ‚Üí √°udio, texto ‚Üí texto)."
      },
      "results": {
        "title": "Resultados",
        "uptime": "99.5%",
        "uptimeLabel": "Uptime Transcri√ß√£o",
        "uptimeDesc": "Com fallback multi-provider",
        "transcriptionTime": "&lt;3s",
        "transcriptionTimeLabel": "Transcri√ß√£o (1min √°udio)",
        "transcriptionTimeDesc": "Groq Whisper P95",
        "formatsCount": "8",
        "formatsCountLabel": "Formatos Suportados",
        "formatsCountDesc": "Convers√£o autom√°tica",
        "providersCount": "5",
        "providersCountLabel": "Providers TTS",
        "providersCountDesc": "Incluindo free tier",
        "techStack": "Stack T√©cnico",
        "framework": "Framework",
        "taskQueue": "Task Queue",
        "storage": "Storage",
        "audioProcessing": "Audio Processing",
        "sttPrimary": "STT Primary",
        "ttsPrimary": "TTS Primary",
        "ttsBackup": "TTS Backup",
        "ttsFree": "TTS Free"
      },
      "cta": {
        "title": "Precisa de processamento de √°udio?",
        "description": "STT, TTS, convers√£o de formatos, integra√ß√£o com chatbots - tenho experi√™ncia com os desafios de produ√ß√£o.",
        "contact": "Entrar em Contato"
      }
    },
    "observability": {
      "backToPortfolio": "‚Üê Voltar",
      "badge": "Observabilidade Enterprise",
      "title": "Observability Stack",
      "description": "Sistema completo de observabilidade com m√©tricas de neg√≥cio, tracing distribu√≠do, monitoramento de custos de tokens, telemetria de decis√µes de IA e alertas em tempo real.",
      "metrics": {
        "meltPillars": "4",
        "meltPillarsLabel": "Pilares MELT",
        "customMetrics": "50+",
        "customMetricsLabel": "M√©tricas Custom",
        "traceCoverage": "100%",
        "traceCoverageLabel": "Trace Coverage",
        "mttrDebug": "&lt;5min",
        "mttrDebugLabel": "MTTR Debug"
      },
      "whyObservability": {
        "intro": "Em sistemas de IA conversacional, \"n√£o funcionou\" n√£o √© um diagn√≥stico. Precisamos responder perguntas espec√≠ficas:",
        "debug": "Debug",
        "debugQ": ": Por que o AI n√£o entendeu \"quero marcar amanh√£\"?",
        "performance": "Performance",
        "performanceQ": ": Qual n√≥ do LangGraph est√° lento?",
        "costs": "Custos",
        "costsQ": ": Quanto estamos gastando em tokens por tenant?",
        "business": "Neg√≥cio",
        "businessQ": ": Qual % das conversas resolvemos sem humano?",
        "quality": "Qualidade",
        "qualityQ": ": O RAG est√° retornando pre√ßos corretos?",
        "title": "Por Que Observabilidade √© Cr√≠tica"
      },
      "stack": {
        "businessMetrics": {
          "title": "üìä Business Metrics (Prometheus)",
          "description": "M√©tricas de neg√≥cio com ownership claro por servi√ßo (evita double counting):",
          "tableMetric": "M√©trica",
          "tableOwner": "Owner",
          "tableLabels": "Labels",
          "ownershipNote": "Ownership Table: Cada m√©trica tem um √∫nico servi√ßo respons√°vel por emiti-la, evitando contagem dupla em sistemas distribu√≠dos.",
          "ownershipDesc": ": Cada m√©trica tem um √∫nico servi√ßo respons√°vel por emiti-la, evitando contagem dupla em sistemas distribu√≠dos."
        },
        "tracing": {
          "title": "üîç Distributed Tracing (OpenTelemetry)",
          "description": "Tracing end-to-end com propaga√ß√£o de contexto entre servi√ßos:",
          "propagatedVia": "trace_id: a1b2c3d4... (propagado via headers)",
          "autoInstrumentation": "Instrumenta√ß√£o Autom√°tica",
          "fastapiRequests": "‚Ä¢ FastAPI requests/responses",
          "httpxCalls": "‚Ä¢ HTTPX client calls",
          "sqlalchemyQueries": "‚Ä¢ SQLAlchemy queries",
          "redisOps": "‚Ä¢ Redis operations",
          "customSpans": "Spans Customizados",
          "langGraphNode": "‚Ä¢ LangGraph node execution",
          "ragDecisions": "‚Ä¢ RAG search decisions",
          "bookingFsm": "‚Ä¢ Booking FSM transitions",
          "llmCalls": "‚Ä¢ LLM API calls + tokens"
        },
        "tokenUsage": {
          "title": "üí∞ Token Usage & Cost Tracking",
          "description": "Relat√≥rios de uso de tokens via Jaeger traces para controle de custos:",
          "dataExtracted": "Dados extra√≠dos de spans OpenTelemetry com atributos"
        },
        "stateSnapshot": {
          "title": "üì∏ State Snapshot Telemetry",
          "description": "Cada response inclui snapshot do estado para debug de conversas:"
        },
        "ragTelemetry": {
          "title": "üéØ RAG Decision Telemetry",
          "description": "Explicabilidade de decis√µes do pipeline de pricing/RAG:",
          "allowsIdentify": "Permite identificar: cat√°logo incompleto, aliases faltando, threshold de score inadequado."
        },
        "usageMonitoring": {
          "title": "üì° Usage Monitoring Middleware",
          "description": "Monitoramento de endpoints para decis√µes de depreca√ß√£o:",
          "nonIntrusive": "Non-intrusive",
          "nonIntrusiveDesc": ": N√£o bloqueia requests, apenas observa",
          "sampleRate": "Sample rate",
          "sampleRateDesc": ": Configur√°vel por ambiente (prod: 1%, dev: 100%)",
          "thirtyDaysData": "30+ days data",
          "thirtyDaysDesc": ": Coleta dados antes de decis√µes de remo√ß√£o",
          "endpointTracking": "Endpoint tracking",
          "endpointTrackingDesc": ": Identifica endpoints legados ainda em uso"
        },
        "performanceThresholds": {
          "title": "üìà Performance Thresholds",
          "description": "Thresholds autom√°ticos para alertas:",
          "warning": "‚ö†Ô∏è Warning",
          "critical": "üö® Critical"
        },
        "title": "Stack Completo"
      },
      "architecture": {
        "stackTitle": "OBSERVABILITY STACK",
        "orchestrator": "Orchestrator",
        "aiEngine": "AI Engine",
        "memoryEngine": "Memory Engine",
        "metricsLabel": "metrics",
        "prometheusSection": "PROMETHEUS",
        "prometheusLine1": "- Business metrics (handover, booking, AI)",
        "prometheusLine2": "- System metrics (latency, errors, cache)",
        "prometheusLine3": "- Custom metrics (RAG, tool budget)",
        "grafanaSection": "GRAFANA DASHBOARDS",
        "grafanaLine1": "- Real-time KPIs per tenant",
        "grafanaLine2": "- Cost tracking & forecasting",
        "grafanaLine3": "- Alert rules & notifications",
        "otelSection": "OPENTELEMETRY + JAEGER",
        "otelLine1": "- Distributed traces across services",
        "otelLine2": "- Token usage extraction from spans",
        "otelLine3": "- Latency breakdown per operation",
        "lokiSection": "LOKI + JSON LOGS",
        "lokiLine1": "- Structured logging with trace correlation",
        "lokiLine2": "- trace_id + span_id in every log entry",
        "lokiLine3": "- Searchable by tenant, operation, error",
        "title": "Arquitetura"
      },
      "decisions": {
        "ownershipQ": "Por que ownership table para m√©tricas?",
        "ownershipA": "Em sistemas distribu√≠dos, m√∫ltiplos servi√ßos podem observar o mesmo evento. Sem ownership claro, m√©tricas de handover seriam emitidas pelo Orchestrator E pelo AI Engine, causando double counting. Ownership table define um √∫nico emissor por m√©trica.",
        "tracesQ": "Por que extrair tokens de traces e n√£o de logs?",
        "tracesA": "Traces t√™m estrutura padronizada (span attributes) e contexto (trace_id liga request a response). Logs s√£o texto livre que requer parsing. Jaeger j√° indexa spans por atributo, facilitando queries como \"total tokens por modelo no √∫ltimo m√™s\".",
        "snapshotQ": "Por que state snapshot em response_metadata?",
        "snapshotA": "Debugging de conversas requer saber o estado exato ap√≥s cada turno. Incluir snapshot no response permite reproduzir problemas sem acessar logs ou traces. Frontend pode mostrar \"estado interno\" em modo debug.",
        "sampleRateQ": "Por que sample rate configur√°vel?",
        "sampleRateA": "Em produ√ß√£o com milh√µes de requests, 100% sampling √© caro (storage, processing). 1-10% sampling captura anomalias suficientes para debug. Em dev/staging, 100% permite debug completo de cada request.",
        "title": "Decis√µes T√©cnicas"
      },
      "techStack": {
        "title": "Stack T√©cnica"
      },
      "cta": {
        "next": "Pr√≥ximo: Backend Orchestrator ‚Üí"
      }
    },
    "optimus": {
      "back": "‚Üê Voltar",
      "title": "Optimus",
      "subtitle": "Plataforma de Chatbots AI para Milh√µes de Usu√°rios",
      "problem": {
        "title": "O Problema Uma empresa precisava de uma plataforma de chatbots que atendesse cl√≠nicas, e-commerces, escrit√≥rios de advocacia ‚Äî qualquer vertical de neg√≥cio. O sistema precisava escalar pra milh√µes de usu√°rios, manter contexto de conversas longas, e isolar completamente os dados entre clientes. Chatbots gen√©ricos n√£o resolvem. Eles esquecem o que voc√™ disse 5 mensagens atr√°s e n√£o entendem que \"dente 36\" numa cl√≠nica √© informa√ß√£o cr√≠tica que n√£o pode sumir.",
        "p1": "O Problema Uma empresa precisava de uma plataforma de chatbots que atendesse cl√≠nicas, e-commerces, escrit√≥rios de advocacia ‚Äî qualquer vertical de neg√≥cio. O sistema precisava escalar pra milh√µes de usu√°rios, manter contexto de conversas longas, e isolar completamente os dados entre clientes. Chatbots gen√©ricos n√£o resolvem. Eles esquecem o que voc√™ disse 5 mensagens atr√°s e n√£o entendem que \"dente 36\" numa cl√≠nica √© informa√ß√£o cr√≠tica que n√£o pode sumir.",
        "p2": "O Problema Uma empresa precisava de uma plataforma de chatbots que atendesse cl√≠nicas, e-commerces, escrit√≥rios de advocacia ‚Äî qualquer vertical de neg√≥cio. O sistema precisava escalar pra milh√µes de usu√°rios, manter contexto de conversas longas, e isolar completamente os dados entre clientes. Chatbots gen√©ricos n√£o resolvem. Eles esquecem o que voc√™ disse 5 mensagens atr√°s e n√£o entendem que \"dente 36\" numa cl√≠nica √© informa√ß√£o cr√≠tica que n√£o pode sumir."
      },
      "solution": {
        "title": "A Solu√ß√£o",
        "intro": "Arquitetura de microservi√ßos do zero, pensada pra produ√ß√£o desde o dia um:",
        "orchestrator": "Gateway √∫nico. Rate limiting, cache, circuit breaker.",
        "aiEngine": "Processa conversas com LangChain. Zero acesso a banco.",
        "memoryEngine": "Dono do PostgreSQL. Mem√≥ria hier√°rquica (hot/warm/cold).",
        "rulesEngine": "Automa√ß√µes de neg√≥cio por vertical."
      },
      "multiTenancy": {
        "title": "Multi-Tenancy de Verdade",
        "p1": "Cada cliente tem seu pr√≥prio schema no PostgreSQL ({clinicExample}, {storeExample}). N√£o √© s√≥ um tenant_id numa tabela compartilhada ‚Äî √© isolamento real. Um bug no c√≥digo de um tenant n√£o vaza dados de outro."
      },
      "forgetting": {
        "title": "O Problema do \"Esquecimento\" Chatbots perdem contexto. Depois de 50 mensagens, esquecem que voc√™ marcou consulta pra ter√ßa √†s 14h. Resolvi com mem√≥ria em tr√™s camadas:",
        "p1": "O Problema do \"Esquecimento\" Chatbots perdem contexto. Depois de 50 mensagens, esquecem que voc√™ marcou consulta pra ter√ßa √†s 14h. Resolvi com mem√≥ria em tr√™s camadas:",
        "p2": "O Problema do \"Esquecimento\" Chatbots perdem contexto. Depois de 50 mensagens, esquecem que voc√™ marcou consulta pra ter√ßa √†s 14h. Resolvi com mem√≥ria em tr√™s camadas:",
        "hot": "Redis, √∫ltimas mensagens, acesso instant√¢neo",
        "warm": "Redis, contexto recente, TTL maior",
        "cold": "PostgreSQL, hist√≥rico completo",
        "p3": "Quando um operador humano devolve pro bot, o sistema gera resumo via GPT-4 com templates espec√≠ficos por vertical. Numa cl√≠nica, ele sabe que \"dente 36\" e \"amoxicilina 500mg\" s√£o cr√≠ticos."
      },
      "numbers": {
        "title": "N√∫meros",
        "latency": "Lat√™ncia P95",
        "cacheHit": "Cache hit",
        "uptime": "Uptime",
        "throughput": "Throughput"
      },
      "stack": {
        "title": "Stack"
      },
      "learnings": {
        "title": "O que aprendi",
        "p1Label": "Separa√ß√£o de responsabilidades n√£o √© frescura.",
        "p1": "Depois de 6 meses, quando voc√™ precisa mudar o cache sem quebrar o AI Engine, agradece.",
        "p2Label": "Multi-tenancy precisa ser pensado desde o dia um.",
        "p2": "Schema por tenant no PostgreSQL √© mais trabalho inicial, mas dorme tranquilo.",
        "p3Label": "Mem√≥ria de chatbot √© subestimada.",
        "p3": "Todo mundo foca no modelo. Ningu√©m fala do que acontece com 200 mensagens."
      },
      "cta": {
        "interested": "Interessado em construir algo parecido?",
        "letsChat": "Vamos conversar"
      }
    },
    "aiEngine": {
      "back": "Voltar",
      "platformName": "Optimus AI Platform",
      "badge1": "Core Service",
      "badge2": "Arquitetura de IA",
      "title": "AI Conversation",
      "titleHighlight": "Engine",
      "subtitle": "Motor de conversa√ß√£o enterprise que separa l√≥gica determin√≠stica de linguagem natural. LangGraph orquestra 20+ n√≥s especializados, FSM de 8 estados garante comportamentos cr√≠ticos, e Semantic Router decide em &lt;10ms quando o LLM pode ser bypassado.",
      "stats": {
        "nodes": "N√≥s LangGraph",
        "states": "Estados FSM",
        "routing": "Semantic Routing",
        "uptime": "Uptime"
      },
      "nav": {
        "problem": "Problema",
        "architecture": "Arquitetura",
        "semanticRouting": "Semantic Routing",
        "fsm": "Booking FSM",
        "contextComposer": "Context Composer",
        "fastLane": "Pricing Fast Lane",
        "reducer": "Flow Reducer",
        "retry": "Retry Policies",
        "results": "Resultados"
      },
      "sections": {
        "problem": {
          "title": "O Problema",
          "content1": "Chatbots baseados puramente em LLMs sofrem de um problema fundamental:",
          "nonDeterminism": "n√£o-determinismo",
          "scenariosTitle": "Cen√°rios Inaceit√°veis",
          "scenarios": {
            "hallucination": {
              "title": "\"Alucina√ß√£o de hor√°rio\":",
              "content": "LLM confirma consulta √†s 14h quando o usu√°rio disse 15h. Paciente perde consulta, cl√≠nica perde receita."
            },
            "ambiguous": {
              "title": "\"Confirma√ß√£o amb√≠gua\":",
              "content": "Usu√°rio diz \"ok\", LLM interpreta como confirma√ß√£o. Mas era \"ok, entendi\" (acknowledgement), n√£o \"ok, confirma\"."
            },
            "drift": {
              "title": "\"Intent drift\":",
              "content": "Conversa sobre pre√ßo vira agendamento sem o usu√°rio pedir. LLM \"ajudando demais\"."
            },
            "loop": {
              "title": "\"Loop infinito\":",
              "content": "LLM chama ferramenta, falha, chama de novo, falha... at√© timeout ou custo explodir."
            }
          },
          "conclusion": "Para um sistema de agendamento m√©dico/odontol√≥gico enterprise, isso √© inaceit√°vel. A solu√ß√£o n√£o √© \"melhorar o prompt\" ‚Äî √© separar o que precisa ser determin√≠stico (decis√µes de neg√≥cio) do que pode ser probabil√≠stico (gera√ß√£o de linguagem natural).",
          "content2": ". O mesmo input pode gerar outputs diferentes, e decis√µes cr√≠ticas de neg√≥cio ficam √† merc√™ de \"temperatura\" e contexto aleat√≥rio."
        },
        "architecture": {
          "title": "Arquitetura H√≠brida",
          "intro1": "O AI Engine implementa uma arquitetura h√≠brida onde a l√≥gica de neg√≥cio √© 100% determin√≠stica (FSM + regras) e o LLM √© usado apenas para tarefas onde criatividade √© desej√°vel (humaniza√ß√£o, clarifica√ß√£o).",
          "introHighlight2": "tarefas onde criatividade √© desej√°vel",
          "diagramTitle": "Fluxo de Execu√ß√£o",
          "langGraphTitle": "LangGraph: Por que n√£o chains simples?",
          "langGraphExplanation": "Chains s√£o lineares ‚Äî entrada ‚Üí processamento ‚Üí sa√≠da. Booking flow precisa de ramifica√ß√µes complexas: usu√°rio pode cancelar no meio de um reschedule, pedir clarifica√ß√£o, ou escalar para humano a qualquer momento. LangGraph permite modelar isso como um grafo real.",
          "intro2": "(FSM + regras) e o LLM √© usado apenas para",
          "intro3": "(humaniza√ß√£o, clarifica√ß√£o).",
          "introHighlight1": "l√≥gica de neg√≥cio √© 100% determin√≠stica"
        },
        "semanticRouting": {
          "title": "Semantic Routing",
          "intro": "Antes de chamar o LLM para an√°lise estruturada (caro, ~200ms), o Semantic Router tenta classificar o intent via embeddings (barato, &lt;10ms). Se a confian√ßa for alta, bypassa o LLM completamente.",
          "hybridAlphaTitle": "Hybrid Alpha: Embeddings + Keywords",
          "hybridAlphaExplanation": "Embeddings puros falham em casos onde palavras-chave s√£o cr√≠ticas (ex: \"cancelar\" vs \"gostaria de remarcar\"). O Semantic Router usa classifica√ß√£o h√≠brida:",
          "hybridAlphaConfig": "Configur√°vel via env:",
          "params": {
            "hybridAlpha": {
              "title": "HYBRID_ALPHA",
              "description": "0.7 = 70% embeddings. Valores menores priorizam keywords."
            },
            "abstainThreshold": {
              "title": "ABSTAIN_THRESHOLD",
              "description": "0.55 = confian√ßa m√≠nima. Abaixo disso, passa pro LLM."
            },
            "biasWeight": {
              "title": "BIAS_WEIGHT",
              "description": "0.03 = boost para intents cr√≠ticos (booking > greeting)."
            }
          },
          "resultTitle": "‚úì Resultado",
          "resultContent": "~40% das requests s√£o classificadas com alta confian√ßa e bypassam o LLM completamente. Economia de ~$0.002/request √ó 40% = redu√ß√£o significativa de custo OpenAI."
        },
        "fsm": {
          "title": "Booking State Machine",
          "intro": "O cora√ß√£o do booking flow √© uma FSM (Finite State Machine) que define exatamente quais transi√ß√µes s√£o v√°lidas. N√£o importa o que o LLM \"ache\" ‚Äî se a transi√ß√£o n√£o est√° na tabela, n√£o acontece.",
          "diagramTitle": "Estados e Transi√ß√µes",
          "transitionsTitle": "Transi√ß√µes V√°lidas (SSoT)",
          "operationsTitle": "Opera√ß√µes Suportadas",
          "operations": {
            "schedule": {
              "title": "schedule",
              "description": "Novo agendamento. Busca slots ‚Üí sele√ß√£o ‚Üí confirma√ß√£o ‚Üí ERP create."
            },
            "reschedule": {
              "title": "reschedule",
              "description": "Remarcar existente. Busca booking ‚Üí slots ‚Üí confirma√ß√£o ‚Üí ERP update."
            },
            "cancel": {
              "title": "cancel",
              "description": "Cancelar existente. Busca booking ‚Üí confirma√ß√£o ‚Üí ERP delete."
            }
          }
        },
        "contextComposer": {
          "title": "Context Composer (ECA)",
          "intro": "O Context Composer implementa a Enhanced Context Architecture (ECA) ‚Äî um sistema de montagem de contexto determin√≠stico que busca dados de m√∫ltiplas fontes, aplica budget de tokens, e formata em blocos ordenados para o LLM.",
          "budgetTitle": "Budget Management",
          "budgetIntro": "Com contexto de 1200 tokens e m√∫ltiplas fontes, √© f√°cil estourar o budget. O Context Composer usa truncation inteligente:",
          "budgetRules": {
            "untouchable": {
              "title": "Blocos intoc√°veis:",
              "content": "IDENTITY, RULES, INPUT nunca s√£o truncados"
            },
            "semantic": {
              "title": "Compress√£o sem√¢ntica:",
              "content": "MEMORY pode ser comprimido (90% redu√ß√£o via Memory Engine)"
            },
            "priority": {
              "title": "Truncation por prioridade:",
              "content": "FOCUS (RAG) √© truncado primeiro se necess√°rio"
            }
          }
        },
        "fastLane": {
          "title": "Pricing Fast Lane",
          "intro": "Consultas de pre√ßo s√£o o caso de uso mais comum (~35% das mensagens) e t√™m um padr√£o previs√≠vel: busca RAG + formata√ß√£o. O Pricing Fast Lane executa isso diretamente, sem passar pelo agent_node (que faz itera√ß√µes LLM caras).",
          "resultTitle": "‚ö° Resultado",
          "resultContent": "Fast lane reduz lat√™ncia de ~2s (agent iteration) para ~200ms (RAG direto). Cache hit: &lt;50ms. Sem custo de tokens LLM para ~35% das requests."
        },
        "reducer": {
          "title": "Booking Flow Reducer",
          "intro": "O Reducer √© o guardi√£o do booking_flow state. Todo update passa por ele, que valida whitelist de sources, monotonicity de turn_seq, e transi√ß√µes v√°lidas. Se algo violar as invariantes, o update √© rejeitado.",
          "whyReducerTitle": "Por que Reducer?",
          "reasons": {
            "raceConditions": {
              "title": "Previne race conditions:",
              "content": "M√∫ltiplos n√≥s podem tentar atualizar o state simultaneamente. Reducer serializa e valida."
            },
            "audit": {
              "title": "Auditoria:",
              "content": "Cada update √© logado com source, turn_seq, e transi√ß√£o. Facilita debugging."
            },
            "metrics": {
              "title": "M√©tricas:",
              "content": "Prometheus counters para updates e rejections por reason."
            }
          }
        },
        "retry": {
          "title": "Retry Policies",
          "intro": "Nem todo erro merece retry. Erros transientes (timeout, rate limit) s√£o retri√°veis. Erros permanentes (auth failure, bad request) n√£o s√£o ‚Äî retry s√≥ gasta tempo e dinheiro.",
          "warningTitle": "‚ö†Ô∏è Por que whitelist e n√£o blacklist?",
          "warningContent": "Blacklist √© perigosa: se um novo tipo de erro permanente aparecer (ex: nova exception do OpenAI SDK), ele seria retriado por default. Whitelist √© fail-safe: s√≥ retria o que conhecemos como transiente."
        },
        "results": {
          "title": "Resultados",
          "metrics": {
            "bypass": {
              "value": "~40%",
              "label": "Requests bypassam LLM via Semantic Routing"
            },
            "classification": {
              "value": "&lt;10ms",
              "label": "Classifica√ß√£o via embeddings (p95)"
            },
            "transitions": {
              "value": "0",
              "label": "Transi√ß√µes inv√°lidas de FSM em produ√ß√£o"
            },
            "fastLane": {
              "value": "~200ms",
              "label": "Pricing Fast Lane (vs ~2s agent)"
            }
          },
          "decisionsTitle": "Decis√µes T√©cnicas Chave",
          "decisions": {
            "fsmSeparated": {
              "title": "FSM separada do LLM:",
              "content": "Decis√µes de neg√≥cio s√£o determin√≠sticas. LLM s√≥ humaniza."
            },
            "semanticPreLlm": {
              "title": "Semantic routing pre-LLM:",
              "content": "Classifica√ß√£o barata antes de gastar tokens."
            },
            "reducerWhitelist": {
              "title": "Reducer com whitelist:",
              "content": "S√≥ sources autorizados atualizam estado cr√≠tico."
            },
            "retryWhitelist": {
              "title": "Retry com whitelist:",
              "content": "S√≥ transient exceptions s√£o retriadas."
            },
            "fastLanes": {
              "title": "Fast lanes para padr√µes conhecidos:",
              "content": "Pricing n√£o precisa de itera√ß√£o LLM."
            }
          }
        }
      },
      "techStack": {
        "title": "Stack T√©cnico"
      },
      "cta": {
        "title": "Explore Outros Case Studies",
        "description": "Veja como outros componentes do Optimus foram constru√≠dos",
        "rulesEngine": "Rules Engine ‚Üí",
        "memoryEngine": "Memory Engine ‚Üí",
        "llmPool": "LLM Pool Management ‚Üí"
      },
      "footer": "Case Study: AI Conversation Engine ‚Äî Optimus AI Platform"
    },
    "mcpServers": {
      "tag": "Developer Tools",
      "title": "MCP Servers",
      "description": "Servidores Model Context Protocol customizados para desenvolvimento com Claude Code. Ferramentas de debugging, valida√ß√£o arquitetural e navega√ß√£o inteligente de codebase.",
      "whatIsMcp": {
        "title": "O que √© MCP?",
        "intro": "<strong class=\"text-white\">Model Context Protocol</strong> √© um padr√£o da Anthropic \nque permite estender assistentes de IA (como Claude) com ferramentas customizadas. \nEm vez do AI \"adivinhar\" sobre seu codebase, voc√™ d√° a ele acesso real √† sua \narquitetura, contratos e conven√ß√µes.",
        "comment": "# Adicionar servidor MCP ao Claude Code"
      },
      "servers": {
        "title": "Servidores Dispon√≠veis",
        "orchestrator": {
          "title": "backend_orchestrator_mcp",
          "intro": "Ferramentas de debugging para o Backend Orchestrator:",
          "diagnoseGateway": "Health check completo do gateway",
          "analyzeCache": "Performance do cache PubSub",
          "analyzeRateLimiting": "Status de rate limiting por tenant",
          "generateRouter": "Template de router seguindo padr√µes"
        },
        "optimus": {
          "title": "optimus_project_mcp",
          "intro": "12 ferramentas para navega√ß√£o inteligente do codebase:",
          "systemOverview": "Vis√£o geral da arquitetura",
          "serviceContract": "Contratos de cada microservi√ßo",
          "validateDiff": "Validar mudan√ßas contra guardrails",
          "planChange": "Orienta√ß√µes arquiteturais para mudan√ßas"
        }
      },
      "validation": {
        "title": "Valida√ß√£o Arquitetural",
        "intro": "O <code class=\"text-cyan-400\">validate_diff verifica se um diff respeita \nos guardrails arquiteturais do projeto:",
        "violationDetected": "‚ùå Viola√ß√£o Detectada ai-engine/src/service.py: Line 42 \"import sqlalchemy\" ‚Üê AI Engine n√£o pode acessar DB diretamente! Guardrail: \"All data operations must go through Memory Engine APIs\"",
        "violationExample": "‚ùå Viola√ß√£o Detectada ai-engine/src/service.py: Line 42 \"import sqlalchemy\" ‚Üê AI Engine n√£o pode acessar DB diretamente! Guardrail: \"All data operations must go through Memory Engine APIs\"",
        "validDiff": "‚úÖ Diff V√°lido ai-engine/src/service.py: Line 42 \"await memory_engine_client.get_data(...)\" ‚úì Respects Memory Engine API boundary",
        "validExample": "‚úÖ Diff V√°lido ai-engine/src/service.py: Line 42 \"await memory_engine_client.get_data(...)\" ‚úì Respects Memory Engine API boundary"
      },
      "hotReload": {
        "title": "Hot Reload",
        "intro": "M√≥dulos s√£o recarregados sem reiniciar o servidor MCP:"
      },
      "stack": {
        "title": "Stack T√©cnica"
      },
      "cta": {
        "next": "Pr√≥ximo: Feed-RSS Monitor ‚Üí"
      }
    },
    "feedRss": {
      "tag": "Automa√ß√£o",
      "title": "Feed-RSS Monitor",
      "description": "Pipeline de automa√ß√£o de conte√∫do que monitora feeds RSS, filtra por keywords, gera roteiros via OpenAI e notifica em Telegram/Discord.",
      "stats": {
        "monitoredFeeds": "Feeds Monitorados",
        "aiKeywords": "Keywords AI",
        "asyncPipeline": "Python Pipeline"
      },
      "overview": {
        "title": "Vis√£o Geral",
        "intro": "Solu√ß√£o para criadores de conte√∫do que precisam acompanhar not√≠cias de IA/tech e transform√°-las rapidamente em conte√∫do para redes sociais.",
        "input": "Input",
        "inputDesc": "TechCrunch, The Verge, Wired, Ars Technica, MIT Tech Review, Engadget",
        "output": "Output",
        "outputDesc": "Roteiros para YouTube Shorts (50s) entregues via Telegram/Discord"
      },
      "architecture": {
        "title": "Arquitetura"
      },
      "services": {
        "title": "Arquitetura Modular",
        "feedService": {
          "title": "FeedService",
          "desc": "Busca ass√≠ncrona de feeds com aiohttp. Timeout configur√°vel, retry em falhas, normaliza√ß√£o de entries para modelo Pydantic."
        },
        "filterService": {
          "title": "FilterService",
          "desc": "Filtra not√≠cias por keywords (case-insensitive). Keywords configur√°veis via .env ou arquivo externo. Combina t√≠tulo + resumo para matching."
        },
        "aiService": {
          "title": "AIService",
          "desc": "Integra√ß√£o OpenAI com prompt otimizado para roteiros de Shorts. Formato estruturado: gancho impactante ‚Üí 3-5 frases de ess√™ncia ‚Üí CTA com pergunta."
        },
        "stateService": {
          "title": "StateService",
          "desc": "Persiste IDs de not√≠cias j√° processadas em JSON. Evita reprocessamento e spam de notifica√ß√µes repetidas."
        }
      },
      "prompt": {
        "title": "Prompt Engineering",
        "intro": "O prompt foi otimizado para gerar roteiros concisos e impactantes:",
        "systemPrompt": "System Prompt:",
        "promptText": "\"Voc√™ √© roteirista do canal Cyber Inteligente. Crie roteiros para YouTube Shorts de at√© 50 segundos, em portugu√™s claro e direto. Tom energ√©tico, futurista, sem enrola√ß√£o. Formato: (1) Gancho em 1 frase; (2) Ess√™ncia em 3-5 frases curtas; (3) CTA com pergunta.\""
      },
      "usage": {
        "title": "Uso",
        "basicExecution": "# Execu√ß√£o b√°sica",
        "withOptions": "# Com op√ß√µes"
      },
      "stack": {
        "title": "Stack T√©cnica"
      },
      "cta": {
        "backToHome": "‚Üê Voltar para Home"
      }
    },
    "common": {
      "personalProject": "Projeto Pessoal",
      "technicalStack": "Stack T√©cnico",
      "results": "Resultados"
    },
    "pvcoach": {
      "tag": "Chess + AI",
      "tagSecondary": "Training Tool",
      "title": "PVCoach",
      "description": "Coach de xadrez que combina Stockfish com LLM para explicar movimentos. An√°lise MultiPV, hints progressivos, explica√ß√µes fundamentadas nas varia√ß√µes do engine, e valida√ß√£o autom√°tica para evitar alucina√ß√µes.",
      "stats": {
        "llmProviders": "LLM Providers",
        "topNAnalysis": "Top-N Analysis",
        "hintLevels": "Hint Levels",
        "groundedExplanations": "Explanations"
      },
      "nav": {
        "problem": "Problema",
        "architecture": "Arquitetura",
        "multipv": "MultiPV",
        "grounded": "Grounded Explanations",
        "hints": "Progressive Hints",
        "providers": "Multi-Provider",
        "api": "API"
      },
      "problem": {
        "title": "O Problema",
        "intro": "Engines de xadrez como Stockfish s√£o extremamente fortes, mas suas \"explica√ß√µes\" s√£o \napenas n√∫meros (centipawns) e varia√ß√µes brutas. Jogadores intermedi√°rios n√£o conseguem \nentender <em>por que</em> um lance √© melhor.",
        "gapTitle": "O Gap de Entendimento",
        "engineSays": "Engine diz:",
        "engineExample": "\"e4 +0.35, d4 +0.20\" ‚Äî Ok, mas por qu√™?",
        "llmHallucinates": "LLM puro alucina:",
        "llmExample": "\"Nf3 ataca a dama\" ‚Äî N√£o, n√£o ataca.",
        "humanExpensive": "An√°lises humanas s√£o caras:",
        "humanExample": "Coaches cobram $50-100/hora.",
        "solution": "A solu√ß√£o foi combinar a precis√£o do Stockfish com a capacidade explicativa do LLM, \nmas <strong class=\"text-white\">ancorando as explica√ß√µes nas varia√ß√µes reais do engine</strong> \npara evitar alucina√ß√µes."
      },
      "architecture": {
        "title": "Arquitetura",
        "pipelineTitle": "Pipeline de An√°lise",
        "fenPosition": "FEN Position",
        "stockfishMultipv": "Stockfish MultiPV",
        "depthMultipv": "depth=14, multipv=3",
        "llmGrounded": "LLM (Grounded Prompt)",
        "explanationPv": "Explica√ß√£o baseada nas PVs",
        "validation": "Validation",
        "crossCheck": "Cross-check com engine"
      },
      "multipv": {
        "title": "MultiPV Analysis",
        "intro": "Em vez de pedir s√≥ o \"melhor lance\", o sistema pede os top-N lances com suas varia√ß√µes \ncompletas. Isso permite comparar alternativas e explicar <em>por que</em> um lance √© \nmelhor que outro.",
        "deltaExplanation": "O <code>delta_cp</code> mostra quanto cada alternativa \"perde\" em rela√ß√£o ao melhor lance. \nEx: se e4 = +35cp e d4 = +20cp, ent√£o delta_cp de d4 = 15cp (perde 0.15 pe√µes)."
      },
      "grounded": {
        "title": "Grounded Explanations",
        "intro": "O segredo para evitar alucina√ß√µes √© <strong class=\"text-white\">ancorar o LLM nas varia√ß√µes \nreais do engine</strong>. O prompt inclui as PVs formatadas, e a valida√ß√£o verifica se a \nexplica√ß√£o menciona lances que realmente existem.",
        "validationTitle": "Valida√ß√£o Autom√°tica",
        "resultTitle": "Resultado",
        "resultText": "Se o LLM menciona um lance que n√£o existe nas PVs, o sistema retorna um warning. Isso permite detectar alucina√ß√µes antes de mostrar ao usu√°rio."
      },
      "hints": {
        "title": "Progressive Hints",
        "intro": "Para treino, revelar o lance imediatamente n√£o ajuda. O sistema oferece dicas progressivas em 3 n√≠veis, do mais vago ao mais espec√≠fico.",
        "level1Title": "Level 1: Pista",
        "level1Example": "\"Pense em mover seu cavalo.\"",
        "level1Desc": "Indica a pe√ßa, n√£o a casa. Se h√° captura ou xeque, adiciona nota.",
        "level2Title": "Level 2: Plano",
        "level2Example": "\"Melhor lance: Nf3. Compare com d4, Nc3.\"",
        "level2Desc": "Revela o lance + alternativas + delta_cp.",
        "level3Title": "Level 3: Variante",
        "level3Example": "\"Nf3 ‚Üí d5 d4 Nf6 c4 e6\"",
        "level3Desc": "PV completa + explica√ß√£o LLM (opcional)."
      },
      "providers": {
        "title": "Multi-Provider LLM",
        "intro": "O sistema suporta 5 providers de LLM, permitindo escolher por custo, velocidade, ou prefer√™ncia. Configur√°vel via env vars ou per-request.",
        "openai": "GPT-4, GPT-3.5 ‚Äî Chat Completions API.",
        "anthropic": "Claude 3.5 Sonnet, Haiku ‚Äî Messages API.",
        "google": "Gemini 1.5 Flash, Pro ‚Äî GenerativeAI.",
        "openrouter": "Proxy para m√∫ltiplos modelos ‚Äî OpenAI-compatible."
      },
      "api": {
        "title": "API Endpoints",
        "evaluatePosition": "Avalia√ß√£o MultiPV pura (sem LLM). Retorna top-N candidatos com PVs e scores.",
        "explainPosition": "Avalia√ß√£o + explica√ß√£o LLM grounded. Inclui warnings de valida√ß√£o.",
        "hintsPosition": "Hints progressivos (level 1-3). Level 3 pode incluir explica√ß√£o.",
        "analyze": "Baixa partidas do Lichess e analisa em batch."
      },
      "results": {
        "hallucinations": "Alucina√ß√µes com valida√ß√£o ativa",
        "providers": "Providers LLM suportados",
        "cache": "TTL para avalia√ß√µes e explica√ß√µes",
        "hintLevels": "N√≠veis de hints progressivos"
      },
      "cta": {
        "title": "Explore Outros Projetos",
        "subtitle": "Veja outros sistemas que constru√≠"
      },
      "footer": "Case Study: PVCoach ‚Äî Chess Training with AI"
    },
    "documentProcessing": {
      "tag": "Document AI",
      "title": "Document Processing Pipeline",
      "description": "Pipeline de processamento de documentos com detec√ß√£o autom√°tica de tabelas de pre√ßo, chunking estrat√©gico e gera√ß√£o autom√°tica de cat√°logos para RAG.",
      "stats": {
        "autoDetect": "Auto-detect Tables",
        "brokenChunks": "Broken Price Chunks",
        "indexUpdate": "Index Update",
        "multiTenant": "Tenant Isolated"
      },
      "problem": {
        "title": "O Problema",
        "intro": "Cl√≠nicas enviam tabelas de pre√ßo em formatos diversos (PDF, Excel, Word). Chunking tradicional quebra tabelas no meio, destruindo a rela√ß√£o entre procedimento e pre√ßo:",
        "brokenChunk": "‚ùå Chunk quebrado no meio da tabela:",
        "chunkEnd": "--- FIM DO CHUNK ---"
      },
      "solution": {
        "title": "A Solu√ß√£o",
        "docling": {
          "title": "Detec√ß√£o Autom√°tica de Tabelas (Docling)",
          "intro": "An√°lise estrutural do documento para identificar tabelas de pre√ßo vs texto corrido (FAQ, pol√≠ticas):",
          "layout": "Heur√≠sticas de layout (colunas, bordas, alinhamento)",
          "currency": "Detec√ß√£o de padr√µes monet√°rios (R$, $, ‚Ç¨)",
          "headers": "Headers t√≠picos (\"Procedimento\", \"Valor\", \"Pre√ßo\")"
        },
        "chunking": {
          "title": "Chunking Estrat√©gico",
          "intro": "Estrat√©gias diferentes para tipos de conte√∫do diferentes:",
          "tables": {
            "title": "üìä Tabelas de Pre√ßo TableRow Strategy: Cada linha da tabela vira um chunk at√¥mico. Nunca quebra no meio de um pre√ßo.",
            "desc": "<p class=\"text-gray-500 text-sm\">\n<strong class=\"text-white\">TableRow Strategy:</strong> Cada linha da tabela \nvira um chunk at√¥mico. Nunca quebra no meio de um pre√ßo."
          },
          "faq": {
            "title": "üìù FAQ / Pol√≠ticas Semantic Chunking: Chunks por par√°grafo ou se√ß√£o sem√¢ntica, com overlap para contexto.",
            "desc": "<p class=\"text-gray-500 text-sm\">\n<strong class=\"text-white\">Semantic Chunking:</strong> Chunks por par√°grafo \nou se√ß√£o sem√¢ntica, com overlap para contexto."
          }
        },
        "catalog": {
          "title": "Cat√°logo Autom√°tico",
          "intro": "Extra√ß√£o estruturada gera cat√°logo JSON pronto para busca:"
        }
      },
      "pipeline": {
        "title": "Pipeline de Processamento"
      },
      "hnsw": {
        "title": "HNSW Index Auto-Update",
        "intro": "√çndices HNSW s√£o atualizados automaticamente via Celery workers, garantindo que novos documentos estejam dispon√≠veis para busca em minutos:",
        "trigger": "Trigger: Upload de documento ou schedule peri√≥dico",
        "rebuild": "Rebuild: Incremental quando poss√≠vel, full rebuild se necess√°rio",
        "zeroDowntime": "Zero-downtime: Novo √≠ndice √© criado em paralelo, swap at√¥mico"
      },
      "stack": {
        "title": "Stack T√©cnica"
      },
      "cta": {
        "next": "Pr√≥ximo: MCP Servers ‚Üí"
      }
    }
  }
}
