{
  "nav": {
    "projects": "Proyectos",
    "stack": "Stack",
    "about": "Acerca de",
    "backToPortfolio": "Volver al Portfolio",
    "back": "Voltar"
  },
  "hero": {
    "title": "Marcelo Marleta",
    "subtitle": "Senior Backend & AI Engineer",
    "description": "Arquitecturas de conversaci√≥n enterprise con LangGraph, RAG optimizado y sistemas multi-tenant. Enfoque en separaci√≥n de l√≥gica determin√≠stica y lenguaje natural.",
    "github": "GitHub",
    "linkedin": "LinkedIn"
  },
  "projects": {
    "title": "Proyectos",
    "description": "Sistemas de producci√≥n enfocados en IA conversacional, procesamiento de documentos y herramientas de desarrollo.",
    "optimusPlatform": "Optimus Platform",
    "otherProjects": "Otros Proyectos",
    "viewMore": "Ver Todos los Proyectos"
  },
  "stack": {
    "title": "Stack",
    "backend": "Backend",
    "ai": "AI/ML",
    "infra": "Infra"
  },
  "cta": {
    "wantToSeeMore": "¬øQuieres ver m√°s proyectos?",
    "exploreOther": "Explora tambi√©n otros case studies en mi portfolio."
  },
  "common": {
    "fullStack": "Plataforma Full-Stack",
    "realTime": "Tiempo Real",
    "multiPlatform": "Multi-Plataforma",
    "back": "‚Üê Voltar",
    "technicalStack": "Stack T√©cnica",
    "next": "Pr√≥ximo",
    "personalProject": "Projeto Pessoal",
    "exploreOtherProjects": "Explore Outros Projetos",
    "seeOtherSystems": "Veja outros sistemas que constru√≠",
    "viewAllProjects": "Ver Todos os Projetos"
  },
  "cards": {
    "aiEngine": {
      "title": "AI Conversation Engine",
      "description": "LangGraph + FSM para separaci√≥n de l√≥gica determin√≠stica y lenguaje natural. 20+ nodos especializados, 8 estados de reserva."
    },
    "llmPool": {
      "title": "LLM Pool Management",
      "description": "Pools separados para chat vs tools, key groups con vault encriptado, rotaci√≥n autom√°tica y fallback inteligente. 40% reducci√≥n de costos."
    },
    "pricing": {
      "title": "Pricing Intelligence",
      "description": "RAG optimizado con threshold adaptativo, request coalescing y cache multi-tier. 95% precision, <100ms cache hit."
    },
    "memory": {
      "title": "Memory Engine",
      "description": "Sistema jer√°rquico Hot/Warm/Cold con compresi√≥n sem√°ntica (90% reducci√≥n), compliance LGPD/HIPAA autom√°tico e inyecci√≥n de contexto."
    },
    "backend": {
      "title": "Backend Orchestrator",
      "description": "Hub central FastAPI con dise√±o fail-closed, aislamiento de tenant, handover a agente, circuit breakers."
    },
    "rules": {
      "title": "Rules Engine",
      "description": "Python Lambda DSL para reglas de negocio, patrones fast-lane, coordinaci√≥n backend + AI engine."
    },
    "whatsapp": {
      "title": "WhatsApp Integration",
      "description": "Redis aislado, procesamiento de webhooks, broadcaster WebSocket, integraci√≥n Memory Engine para historial."
    },
    "audio": {
      "title": "Audio Processor",
      "description": "Multi-proveedor STT/TTS (Whisper, ElevenLabs, Azure), procesamiento async con Celery, diversos formatos."
    },
    "observability": {
      "title": "Observability",
      "description": "Prometheus + OpenTelemetry + structlog. Tracing distribuido, m√©tricas personalizadas, dashboards."
    },
    "frontend": {
      "title": "Frontend Apps",
      "description": "Admin Dashboard (3000) + SuperAdmin Panel (3001). Vue.js 3, WebSocket en tiempo real, gesti√≥n de handover, RBAC."
    },
    "testTools": {
      "title": "AI Testing Tools",
      "description": "Detector de alucinaciones, evaluador de calidad, escenarios real√≠sticos con personalidades, interfaz de simulaci√≥n multi-canal."
    },
    "infraDevops": {
      "title": "Infra & DevOps",
      "description": "Docker Compose overlays, Nginx LB con escalado horizontal, Redis Sentinel HA, CI/CD con guardrails de arquitectura."
    },
    "architecture": {
      "title": "Arquitectura Completa",
      "description": "Vista general de la plataforma: 4 microservicios, multi-tenant, integraci√≥n WhatsApp, Memory Engine jer√°rquico."
    },
    "mcp": {
      "title": "MCP Servers",
      "description": "Servidores Model Context Protocol para Claude Code. Debugging, validaci√≥n arquitectural y navegaci√≥n de codebase."
    },
    "automark": {
      "title": "AutoMark Platform",
      "description": "SaaS multi-tenant para distribuci√≥n de ofertas afiliadas. Shopee ‚Üí WhatsApp con anti-spam, scoring y dedupe."
    },
    "icontei": {
      "title": "iContei",
      "description": "Red social de contadores compartibles. Next.js 16, FastAPI, WebSocket en tiempo real, verificaci√≥n por IA, rankings con Redis."
    },
    "gratidiem": {
      "title": "GratiDiem",
      "description": "App Flutter de gratitud con 508+ archivos, 6 plataformas. Riverpod, persistencia dual (Hive+Firebase), IA con Gemini."
    },
    "pvcoach": {
      "title": "PVCoach",
      "description": "Coach de ajedrez con Stockfish + LLM. An√°lisis MultiPV, explicaciones fundamentadas, hints progresivos."
    },
    "feedRss": {
      "title": "Feed-RSS Monitor",
      "description": "Pipeline de automatizaci√≥n de contenido: RSS ‚Üí Filter ‚Üí OpenAI ‚Üí Telegram/Discord. Scripts de Shorts generados autom√°ticamente."
    }
  },
  "cases": {
    "whatsapp": {
      "backToPortfolio": "Volver al portfolio",
      "badge": "Messaging Infrastructure",
      "title": "WhatsApp Integration",
      "description": "Servicio enterprise para WhatsApp con Message Aggregator inteligente, Redis aislado, graceful degradation e integraci√≥n bidireccional con Evolution API.",
      "tags": {
        "aggregator": "Message Aggregator",
        "debounce": "5s Debounce",
        "evolution": "Evolution API",
        "redis": "Redis aislado",
        "degradation": "Graceful Degradation",
        "websocket": "WebSocket"
      },
      "problem": {
        "title": "El problema: \"Split Messages\" de WhatsApp",
        "naturalBehavior": "‚ùå Comportamiento natural de los usuarios",
        "userFragmented": "Los usuarios env√≠an pensamientos fragmentados en m√∫ltiples mensajes r√°pidos. Esto es un comportamiento normal en WhatsApp.",
        "normalBehavior": "Los usuarios env√≠an pensamientos fragmentados en m√∫ltiples mensajes r√°pidos. Esto es un comportamiento normal en WhatsApp.",
        "inWhatsApp": "Los usuarios env√≠an pensamientos fragmentados en m√∫ltiples mensajes r√°pidos. Esto es un comportamiento normal en WhatsApp.",
        "withoutAggregation": "Sin agregaci√≥n (caos):",
        "issue1": "5 llamadas a la API de IA para UNA intenci√≥n",
        "issue2": "5 respuestas confusas (\"¬°Hola!\", \"¬°Bien!\", \"¬øAgendar qu√©?\"...)",
        "issue3": "Costo de tokens 5x mayor",
        "issue4": "UX horrible para el cliente"
      },
      "solution": {
        "title": "‚úÖ Message Aggregator (5s Debounce)",
        "messagesReceived": "// Mensajes recibidos en 14s...",
        "aggregatedIn": "// Agregados en UN solo mensaje:",
        "aggregatedResult": "\"Hola, ¬øtodo bien? Quer√≠a agendar una consulta para ma√±ana a las 10h\"",
        "description": "El Message Aggregator espera 5 segundos despu√©s de cada mensaje.",
        "withAggregation": "Con agregaci√≥n (elegante):",
        "benefit1": "1 llamada a la API de IA con contexto completo",
        "benefit2": "1 respuesta precisa (\"¬°Perfecto! Agend√© para ma√±ana 10h.\")",
        "benefit3": "Costo de tokens 5x menor",
        "benefit4": "UX natural y fluida",
        "extendsTimeout": "extiende el timeout"
      },
      "aggregatorFlow": {
        "title": "üìä Flujo del Message Aggregator",
        "timeline": "Message Aggregator Timeline",
        "message": "Mensaje",
        "timeout": "Timeout",
        "send": "ENVIAR",
        "timer": "Timer 5s",
        "reset": "RESET!",
        "timerExtended": "Timer extendido",
        "timerExpired": "Timer expir√≥",
        "aggregatedMessage": "Mensaje agregado:",
        "backendOrch": "‚Üí Backend Orch.",
        "aiEngine": "‚Üí AI Engine"
      },
      "typingDetection": {
        "title": "üîÑ Typing Detection: el secreto de la fluidez",
        "description": "WhatsApp env√≠a eventos de \"escribiendo...\" v√≠a webhook. El Message Aggregator",
        "realScenario": "Escenario real:",
        "step1": "Usuario env√≠a \"Hola\" ‚Üí timer 5s inicia",
        "step2": "Webhook: \"usuario escribiendo\" ‚Üí timer pausado",
        "step3": "Usuario env√≠a \"quiero agendar\" ‚Üí timer 5s reinicia",
        "step4": "Sin typing, timer expira ‚Üí mensaje agregado enviado",
        "result": "Resultado: El usuario puede escribir a su ritmo natural. El sistema \"espera\" inteligentemente hasta que termine el pensamiento completo.",
        "safetyLimits": "L√≠mites de seguridad",
        "maxTimeout": "Max Timeout Total",
        "maxMessages": "Max mensajes por agregaci√≥n",
        "debounceBase": "Debounce Base",
        "limitsDesc": "Estos l√≠mites previenen DoS y garantizan que los mensajes no queden \"atascados\" indefinidamente si el usuario sigue escribiendo.",
        "extendIntelligently": "extender el timeout inteligentemente",
        "resultDesc": "El usuario puede escribir a su ritmo natural. El sistema \"espera\" inteligentemente hasta que termine el pensamiento completo."
      },
      "redisIsolated": {
        "title": "üîí Redis aislado: separaci√≥n de tr√°fico",
        "description": "WhatsApp genera <strong class=\"text-green-400\">mucho tr√°fico de webhook</strong> -",
        "mixingBad": "Mezclar esto con el Redis principal es receta para desastre.",
        "archTitle": "REDIS ISOLATED ARCHITECTURE",
        "mainRedis": "üî¥ Redis principal (Puerto 6379/6380)",
        "aiEngineCache": "AI Engine ‚úÖ Cache de conversaciones",
        "orchestratorCache": "Backend Orchestrator ‚úÖ Rate limiting, cache",
        "memoryCache": "Memory Engine ‚úÖ Hot/Warm storage",
        "rulesCache": "Rules Engine ‚úÖ Cache de reglas",
        "celeryQueues": "Celery Workers ‚úÖ Task queues",
        "whatsappRedis": "üü¢ Redis WhatsApp (Puerto 6382) - ISOLATED",
        "whatsappOnly": "WhatsApp Integration ONLY",
        "messageBuffers": "Message buffers (agregaci√≥n)",
        "typingState": "Typing state tracking",
        "webhookDedupe": "Webhook deduplication",
        "instanceMapping": "Instance ‚Üí Tenant mapping",
        "deliveryCache": "Delivery status cache",
        "benefits": "‚ö° Beneficios:",
        "benefit1": "‚Ä¢ WhatsApp broadcast no afecta el cache de conversaciones",
        "benefit2": "‚Ä¢ Falla en Redis WhatsApp no derriba el sistema principal",
        "benefit3": "‚Ä¢ M√©tricas separadas para debugging",
        "benefit4": "‚Ä¢ Escala independiente si es necesario",
        "faultIsolation": "üõ°Ô∏è",
        "faultIsolationTitle": "Aislamiento de fallas",
        "faultIsolationDesc": "Si Redis WhatsApp cae o se vuelve lento, el sistema principal (AI, Memory, Rules) sigue funcionando normalmente.",
        "separateMetrics": "üìä",
        "separateMetricsTitle": "M√©tricas separadas",
        "separateMetricsDesc": "Monitoring independiente: la latencia del Redis WhatsApp no contamina las m√©tricas del sistema core. Debug m√°s f√°cil.",
        "independentScale": "üìà",
        "independentScaleTitle": "Escala independiente",
        "independentScaleDesc": "¬øAlta demanda de WhatsApp? Escala solo el Redis WhatsApp. No necesitas tocar la infra principal.",
        "highWebhookTraffic": "mucho tr√°fico de webhook"
      },
      "gracefulDegradation": {
        "title": "‚ö° Graceful Degradation: sistema que no cae",
        "description": "Bajo alta carga, el sistema degrada features no esenciales para mantener el core funcionando. Niveles configurables de degradaci√≥n.",
        "degradesNonEssential": "Bajo alta carga, el sistema degrada features no esenciales para mantener el core funcionando. Niveles configurables de degradaci√≥n.",
        "toKeepCore": "Bajo alta carga, el sistema degrada features no esenciales para mantener el core funcionando. Niveles configurables de degradaci√≥n.",
        "normal": "NORMAL",
        "normalUsers": "Usuarios &lt; 500",
        "normalFeature1": "‚úÖ Full aggregation (5s)",
        "normalFeature2": "‚úÖ Typing detection activo",
        "normalFeature3": "‚úÖ WebSocket real-time",
        "normalFeature4": "‚úÖ Todas las features",
        "degradedLow": "DEGRADED_LOW",
        "degradedLowUsers": "500-2000 usuarios",
        "degradedLowFeature1": "‚ö†Ô∏è Aggregation reducido (3s)",
        "degradedLowFeature2": "‚ö†Ô∏è Typing detection limitado",
        "degradedLowFeature3": "‚úÖ WebSocket activo",
        "degradedLowFeature4": "‚ö†Ô∏è M√©tricas reducidas",
        "degradedHigh": "DEGRADED_HIGH",
        "degradedHighUsers": "&gt; 2000 usuarios",
        "degradedHighFeature1": "‚ùå Aggregation m√≠nimo (1s)",
        "degradedHighFeature2": "‚ùå Typing detection off",
        "degradedHighFeature3": "‚ö†Ô∏è WebSocket pooled",
        "degradedHighFeature4": "‚ùå Solo m√©tricas cr√≠ticas",
        "configurableThresholds": "Thresholds configurables",
        "degradationBasedOn": "Degradaci√≥n basada en:",
        "pendingUsers": "N√∫mero de usuarios pendientes",
        "redisLatency": "Latencia de Redis",
        "webhookErrorRate": "Tasa de errores de webhook",
        "messageQueueSize": "Tama√±o de la fila de mensajes"
      },
      "deterministicId": {
        "title": "üéØ 1 conversaci√≥n por tel√©fono (Deterministic ID)",
        "description": "En WhatsApp, cada tel√©fono = una conversaci√≥n. No importa qu√© header llega,",
        "forSamePhone": "Esto elimina sesiones paralelas y cross-user pollution.",
        "deterministicCalc": "C√°lculo determin√≠stico",
        "example": "Ejemplo:",
        "alwaysSameUuid": "SIEMPRE el mismo UUID para los mismos inputs",
        "ignoresHeaders": "Ignora headers externos completamente",
        "headersIgnored": "Headers de X-Conversation-ID son <strong class=\"text-red-400\">ignorados</strong>.",
        "phoneNormalization": "Normalizaci√≥n de tel√©fono",
        "allBecomeSameUuid": "// Todos se convierten en el MISMO UUID:",
        "normalizedBefore": "// El tel√©fono se normaliza antes del hash:",
        "removeSpaces": "// 1. Elimina espacios, guiones, par√©ntesis",
        "removePrefix": "// 2. Elimina el prefijo \"+\"",
        "ensureNumeric": "// 3. Garantiza formato num√©rico puro",
        "noMatterHow": "No importa c√≥mo llegue el tel√©fono (WhatsApp, Evolution, manual), la normalizaci√≥n garantiza consistencia.",
        "alwaysCalculates": "siempre calcula el mismo UUID",
        "ignored": "ignorados",
        "preventsHijack": ". Evita que un cliente malicioso \"salte\" a la conversaci√≥n de otro usuario."
      },
      "handoverIntegration": {
        "title": "üë• Integraci√≥n con Handover",
        "description": "Cuando un atendente humano asume la conversaci√≥n, el comportamiento del",
        "duringHandover": "Durante Handover:",
        "aggregationPaused": "‚è∏Ô∏è",
        "aggregationPausedTitle": "Aggregation pausado",
        "aggregationPausedDesc": "Los mensajes del cliente van directo al operador, sin delay de 5s.",
        "immediateDelivery": "‚ö°",
        "immediateDeliveryTitle": "Immediate Delivery",
        "immediateDeliveryDesc": "Las respuestas del operador se env√≠an instant√°neamente.",
        "websocketRealtime": "üîÑ",
        "websocketRealtimeTitle": "WebSocket Real-time",
        "websocketRealtimeDesc": "El frontend del operador recibe mensajes en tiempo real.",
        "handoverConfig": "Configuraci√≥n de Handover",
        "supportRealtime": "soportar interacci√≥n en tiempo real"
      },
      "evolutionApi": {
        "title": "üöÄ Evolution API Integration",
        "multiTenantInstances": "Multi-tenant Instances",
        "multiTenantDesc": "Cada tenant puede tener m√∫ltiples instancias WhatsApp. El sistema resuelve autom√°ticamente qu√© tenant \"due√±o\" de cada instancia via cache O(1).",
        "instanceMapping": "// Instance ‚Üí Tenant mapping",
        "lookupO1": "// Lookup O(1) via Redis:",
        "webhookSecurity": "Webhook Security",
        "webhookSecurityDesc": "Las API keys se validan v√≠a HMAC con secret dedicado. El hash de la API key (no la key en s√≠) se cachea para lookups r√°pidos.",
        "validationFlow": "// API Key validation flow:",
        "step1": "1. Webhook llega con header X-API-Key",
        "step2": "2. HMAC(apikey, EVOLUTION_SECRET) ‚Üí hash",
        "step3": "3. Redis lookup: apikeyhash:tenant:{hash}",
        "step4": "4. Si match ‚Üí autorizado",
        "step5": "5. Si no ‚Üí schema scan (fallback)",
        "audioSupport": "üé§ Audio Message Support",
        "voiceNotes": "üéôÔ∏è",
        "voiceNotesTitle": "Voice Notes",
        "voiceNotesDesc": "El cliente env√≠a audio ‚Üí Audio Processor transcribe ‚Üí Texto va al AI Engine",
        "audioReply": "üîä",
        "audioReplyTitle": "Audio Reply",
        "audioReplyDesc": "Respuesta del AI ‚Üí TTS (Text-to-Speech) ‚Üí Audio enviado al cliente",
        "minioStorage": "üìÅ",
        "minioStorageTitle": "MinIO Storage",
        "minioStorageDesc": "Archivos de audio almacenados en MinIO para procesamiento as√≠ncrono"
      },
      "results": {
        "title": "Resultados en producci√≥n",
        "aiReduction": "~80%",
        "aiReductionLabel": "Reducci√≥n de llamadas IA",
        "aiReductionDesc": "V√≠a message aggregation",
        "webhookLatency": "&lt;100ms",
        "webhookLatencyLabel": "Latencia Webhook",
        "webhookLatencyDesc": "P95 end-to-end",
        "redisIsolation": "100%",
        "redisIsolationLabel": "Aislamiento Redis",
        "redisIsolationDesc": "Zero cross-pollution",
        "simultaneousUsers": "2000+",
        "simultaneousUsersLabel": "Usuarios simult√°neos",
        "simultaneousUsersDesc": "Antes de degradation",
        "techStack": "Stack t√©cnico",
        "framework": "Framework",
        "storage": "Storage",
        "realtime": "Real-time",
        "whatsappApi": "WhatsApp API",
        "audio": "Audio",
        "observability": "Observability",
        "rateLimiting": "Rate Limiting",
        "httpClient": "HTTP Client"
      },
      "cta": {
        "title": "¬øInteresado en integraciones WhatsApp?",
        "description": "Message aggregation, webhooks, multi-tenant instances ‚Äî tengo experiencia pr√°ctica con los desaf√≠os reales.",
        "contact": "Entrar en contacto"
      }
    },
    "audio": {
      "backToPortfolio": "Volver al portfolio",
      "badge": "Media Processing",
      "title": "Audio Processor",
      "description": "Microservicio de procesamiento de audio con STT/TTS multi-provider, procesamiento as√≠ncrono v√≠a Celery, storage MinIO y fallback inteligente entre providers.",
      "tags": {
        "multiProvider": "Multi-Provider",
        "groqWhisper": "Groq Whisper",
        "elevenLabs": "ElevenLabs",
        "celery": "Celery",
        "minio": "MinIO",
        "formats": "8 Formatos"
      },
      "challenge": {
        "title": "El desaf√≠o: audio en chatbots enterprise",
        "voiceNotes": "üé§ Voice Notes en WhatsApp",
        "voiceNotesDesc": "Los usuarios de WhatsApp aman enviar audios. En algunos segmentos (cl√≠nicas,",
        "issue1": "Audios largos (1-3 minutos) con m√∫ltiples informaciones",
        "issue2": "Acentos regionales, ruido de fondo, jerga",
        "issue3": "Expectativa de respuesta en audio tambi√©n",
        "commonProblems": "‚ö†Ô∏è Problemas comunes",
        "problem1": "Single provider",
        "problem1Desc": "- si cae, el sistema se detiene",
        "problem2": "Procesamiento s√≠ncrono",
        "problem2Desc": "- bloquea el thread",
        "problem3": "Sin fallback",
        "problem3Desc": "- error = mensaje perdido",
        "problem4": "Costo fijo",
        "problem4Desc": "- mismo provider para todo",
        "problem5": "Formatos limitados",
        "problem5Desc": "- solo MP3/WAV",
        "audioPercentage": "m√°s del 40% de los mensajes son audio"
      },
      "architecture": {
        "title": "Arquitectura multi-provider",
        "diagramTitle": "Audio Processor Architecture",
        "whatsappVoice": "WhatsApp Voice Note",
        "webMobileAudio": "Web/Mobile Audio",
        "textResponse": "Text Response",
        "stt": "STT",
        "tts": "TTS",
        "primary": "Primary",
        "fallback": "Fallback",
        "storage": "Storage",
        "workers": "Workers",
        "sttTitle": "üé§ STT (Speech-to-Text)",
        "groqWhisperTitle": "Groq Whisper",
        "groqWhisperDesc": "Whisper Large v3 v√≠a Groq API. Extremadamente r√°pido (hardware dedicado), excelente para portugu√©s brasile√±o.",
        "openaiWhisperTitle": "OpenAI Whisper",
        "openaiWhisperDesc": "API oficial de OpenAI. M√°s lento que Groq, pero extremadamente confiable como backup.",
        "otherProvidersTitle": "Google / Azure / AWS",
        "available": "Disponible",
        "otherProvidersDesc": "Providers adicionales configurables para casos espec√≠ficos o requisitos de compliance.",
        "ttsTitle": "üîä TTS (Text-to-Speech)",
        "elevenLabsTitle": "ElevenLabs",
        "elevenLabsDesc": "Model: eleven_multilingual_v2. Voces ultra-realistas, excelente entonaci√≥n en portugu√©s.",
        "openaiTtsTitle": "OpenAI TTS",
        "openaiTtsDesc": "Model: tts-1-hd, Voice: shimmer. Alta calidad, buen backup cuando ElevenLabs no est√° disponible.",
        "edgeTtsTitle": "Edge TTS",
        "freeTier": "Free Tier",
        "edgeTtsDesc": "Voice: pt-BR-FranciscaNeural. Gratuito (Microsoft Edge), usado para desarrollo/pruebas o fallback de emergencia."
      },
      "asyncProcessing": {
        "title": "‚ö° Procesamiento as√≠ncrono con Celery",
        "description": "El audio es pesado. Un voice note de 2 minutos puede tardar 5-10 segundos en transcribirse. Procesar de forma s√≠ncrona bloquear√≠a el servidor. La soluci√≥n: workers de Celery dedicados.",
        "wouldBlock": "El audio es pesado. Un voice note de 2 minutos puede tardar 5-10 segundos en transcribirse. Procesar de forma s√≠ncrona bloquear√≠a el servidor. La soluci√≥n: workers de Celery dedicados.",
        "step1Icon": "üì•",
        "step1Title": "1. Recibe audio",
        "step1Desc": "La API recibe el archivo de audio (cualquier formato), valida y guarda en MinIO. Devuelve job_id inmediatamente.",
        "step2Icon": "‚öôÔ∏è",
        "step2Title": "2. Celery procesa",
        "step2Desc": "El worker toma de la cola, descarga de MinIO, convierte formato si es necesario, env√≠a al provider STT y guarda el resultado.",
        "step3Icon": "üì§",
        "step3Title": "3. Callback/Poll",
        "step3Desc": "Resultado disponible v√≠a polling (GET /status/job_id) o webhook callback cuando est√° configurado.",
        "flowTitle": "Flujo de transcripci√≥n",
        "clientSends": "# 1. El cliente env√≠a audio",
        "immediateResponse": "# Respuesta inmediata (~50ms)",
        "workerProcesses": "# 2. Celery worker procesa en background",
        "downloadingFrom": "[Worker] Downloading from MinIO:",
        "converting": "[Worker] Converting OGG ‚Üí WAV (ffmpeg)",
        "sendingTo": "[Worker] Sending to Groq Whisper...",
        "savingResult": "[Worker] Saving result to Redis",
        "clientChecks": "# 3. El cliente verifica el status",
        "solution": ". La soluci√≥n: workers de Celery dedicados.",
        "transcriptionComplete": "[Worker] Transcription complete: \"Hola, quiero agendar una consulta...\""
      },
      "formats": {
        "title": "üéµ 8 formatos de audio soportados",
        "description": "WhatsApp usa OGG/OPUS. Los navegadores usan WebM. iPhones usan M4A. El Audio Processor acepta cualquiera y convierte internamente v√≠a FFmpeg.",
        "mp3": "MP3",
        "mp3Desc": "M√°s com√∫n",
        "wav": "WAV",
        "wavDesc": "Sin compresi√≥n",
        "ogg": "OGG",
        "oggDesc": "WhatsApp Android",
        "opus": "OPUS",
        "opusDesc": "WhatsApp codec",
        "m4a": "M4A",
        "m4aDesc": "iPhone/AAC",
        "flac": "FLAC",
        "flacDesc": "Lossless",
        "aac": "AAC",
        "aacDesc": "Alta calidad",
        "wma": "WMA",
        "wmaDesc": "Windows legacy",
        "autoConversion": "Conversi√≥n autom√°tica",
        "autoConversionDesc": "El sistema detecta el formato autom√°ticamente (magic bytes, no extensi√≥n). Si el provider STT no soporta el formato, lo convierte a WAV v√≠a FFmpeg antes de enviar. Todo es transparente para el cliente."
      },
      "minio": {
        "title": "üì¶ Storage con MinIO",
        "whyMinio": "¬øPor qu√© MinIO?",
        "s3Compatible": "S3-compatible",
        "s3CompatibleDesc": "- misma API que AWS S3, sin vendor lock",
        "selfHosted": "Self-hosted",
        "selfHostedDesc": "- los datos quedan bajo tu control",
        "highPerformance": "High performance",
        "highPerformanceDesc": "- optimizado para archivos medianos",
        "webConsole": "Web console",
        "webConsoleDesc": "- UI para debug y gesti√≥n",
        "configuration": "Configuraci√≥n",
        "managementConsole": "# Console de gesti√≥n",
        "lifecycle": "Lifecycle del archivo",
        "upload": "üì•",
        "uploadTitle": "Upload",
        "uploadDesc": "El cliente env√≠a",
        "store": "üíæ",
        "storeTitle": "Store",
        "storeDesc": "MinIO guarda",
        "process": "‚öôÔ∏è",
        "processTitle": "Process",
        "processDesc": "Worker descarga, procesa",
        "cleanup": "üóëÔ∏è",
        "cleanupTitle": "Cleanup",
        "cleanupDesc": "TTL expira, elimina"
      },
      "fallback": {
        "title": "üîÑ Fallback inteligente",
        "description": "Los providers de IA fallan. Groq puede tener picos de latencia, ElevenLabs puede estar en mantenimiento. El sistema intenta autom√°ticamente el siguiente provider en la cadena de fallback.",
        "sttChain": "# Cadena de fallback STT",
        "sttPrimary": "# Primary",
        "groqFailed": "Groq failed, falling back to OpenAI",
        "allSttFailed": "All STT providers failed",
        "ttsChain": "# Cadena de fallback TTS",
        "ttsPrimary": "# Primary",
        "elevenLabsFailed": "ElevenLabs failed, falling back to OpenAI",
        "paidTtsFailed": "Paid TTS failed, using free Edge TTS",
        "alwaysAvailable": "# Always available",
        "timeoutIcon": "‚è±Ô∏è",
        "timeoutTitle": "Detecci√≥n de timeout",
        "timeoutDesc": "Si el provider no responde en 30s, asume fallo e intenta el siguiente.",
        "quotaIcon": "üí∞",
        "quotaTitle": "Manejo de cuota",
        "quotaDesc": "¬øRate limit o cuota excedida? Fallback autom√°tico sin perder el mensaje.",
        "freeIcon": "üÜì",
        "freeTitle": "Free Tier Backup",
        "freeDesc": "Edge TTS es gratuito y siempre disponible como √∫ltimo recurso."
      },
      "tenantConfig": {
        "title": "üè¢ Configuraci√≥n por tenant",
        "description": "Cada tenant puede tener configuraciones de TTS personalizadas: voz diferente, provider preferido, velocidad de habla. Se almacena en Memory Engine y se carga en runtime.",
        "dentalClinic": "Ejemplo: Cl√≠nica dental",
        "ecommerce": "Ejemplo: E-commerce"
      },
      "whatsappIntegration": {
        "title": "üì± Integraci√≥n con WhatsApp",
        "diagramTitle": "WhatsApp Voice Note Flow",
        "clientSendsAudio": "El cliente env√≠a audio",
        "audioProcessor": "Audio Processor",
        "aiEngine": "AI Engine",
        "evolutionApi": "Evolution API",
        "whatsappIntegration": "WhatsApp Integration",
        "celeryProcesses": "[Celery processa]",
        "clientReceivesAudio": "El cliente recibe audio",
        "responseMode": "Modo de respuesta configurable",
        "modeAudio": "audio",
        "modeAudioDesc": "Siempre responde en audio. Ideal para usuarios que prefieren escuchar.",
        "modeText": "text",
        "modeTextDesc": "Siempre responde en texto. Ahorro de costo de TTS.",
        "modeMatch": "match",
        "modeMatchDesc": "Responde en el mismo formato que recibi√≥ (audio ‚Üí audio, texto ‚Üí texto)."
      },
      "results": {
        "title": "Resultados",
        "uptime": "99.5%",
        "uptimeLabel": "Uptime de transcripci√≥n",
        "uptimeDesc": "Con fallback multi-provider",
        "transcriptionTime": "&lt;3s",
        "transcriptionTimeLabel": "Transcripci√≥n (1min audio)",
        "transcriptionTimeDesc": "Groq Whisper P95",
        "formatsCount": "8",
        "formatsCountLabel": "Formatos soportados",
        "formatsCountDesc": "Conversi√≥n autom√°tica",
        "providersCount": "5",
        "providersCountLabel": "Providers TTS",
        "providersCountDesc": "Incluye free tier",
        "techStack": "Stack t√©cnico",
        "framework": "Framework",
        "taskQueue": "Task Queue",
        "storage": "Storage",
        "audioProcessing": "Audio Processing",
        "sttPrimary": "STT Primary",
        "ttsPrimary": "TTS Primary",
        "ttsBackup": "TTS Backup",
        "ttsFree": "TTS Free"
      },
      "cta": {
        "title": "¬øNecesitas procesamiento de audio?",
        "description": "STT, TTS, conversi√≥n de formatos, integraci√≥n con chatbots ‚Äî tengo experiencia con los desaf√≠os de producci√≥n.",
        "contact": "Entrar en contacto"
      }
    },
    "observability": {
      "backToPortfolio": "‚Üê Volver",
      "badge": "Observabilidad Enterprise",
      "title": "Observability Stack",
      "description": "Sistema completo de observabilidad con m√©tricas de negocio, tracing distribuido, monitoreo de costos de tokens, telemetr√≠a de decisiones de IA y alertas en tiempo real.",
      "metrics": {
        "meltPillars": "4",
        "meltPillarsLabel": "Pilares MELT",
        "customMetrics": "50+",
        "customMetricsLabel": "M√©tricas custom",
        "traceCoverage": "100%",
        "traceCoverageLabel": "Trace Coverage",
        "mttrDebug": "&lt;5min",
        "mttrDebugLabel": "MTTR Debug"
      },
      "whyObservability": {
        "intro": "En sistemas de IA conversacional, \"no funcion√≥\" no es un diagn√≥stico. Necesitamos responder preguntas espec√≠ficas:",
        "debug": "Debug",
        "debugQ": ": ¬øPor qu√© la IA no entendi√≥ \"quiero agendar ma√±ana\"?",
        "performance": "Performance",
        "performanceQ": ": ¬øQu√© nodo del LangGraph est√° lento?",
        "costs": "Costos",
        "costsQ": ": ¬øCu√°nto gastamos en tokens por tenant?",
        "business": "Negocio",
        "businessQ": ": ¬øQu√© % de conversaciones resolvemos sin humano?",
        "quality": "Calidad",
        "qualityQ": ": ¬øEl RAG devuelve precios correctos?",
        "title": "Por qu√© la observabilidad es cr√≠tica"
      },
      "stack": {
        "businessMetrics": {
          "title": "üìä Business Metrics (Prometheus)",
          "description": "M√©tricas de negocio con ownership claro por servicio (evita double counting):",
          "tableMetric": "M√©trica",
          "tableOwner": "Owner",
          "tableLabels": "Labels",
          "ownershipNote": "Ownership Table: Cada m√©trica tiene un √∫nico servicio responsable por emitirla, evitando double counting en sistemas distribuidos.",
          "ownershipDesc": ": Cada m√©trica tiene un √∫nico servicio responsable por emitirla, evitando double counting en sistemas distribuidos."
        },
        "tracing": {
          "title": "üîç Distributed Tracing (OpenTelemetry)",
          "description": "Tracing end-to-end con propagaci√≥n de contexto entre servicios:",
          "propagatedVia": "trace_id: a1b2c3d4... (propagado v√≠a headers)",
          "autoInstrumentation": "Instrumentaci√≥n autom√°tica",
          "fastapiRequests": "‚Ä¢ FastAPI requests/responses",
          "httpxCalls": "‚Ä¢ HTTPX client calls",
          "sqlalchemyQueries": "‚Ä¢ SQLAlchemy queries",
          "redisOps": "‚Ä¢ Redis operations",
          "customSpans": "Spans customizados",
          "langGraphNode": "‚Ä¢ LangGraph node execution",
          "ragDecisions": "‚Ä¢ RAG search decisions",
          "bookingFsm": "‚Ä¢ Booking FSM transitions",
          "llmCalls": "‚Ä¢ LLM API calls + tokens"
        },
        "tokenUsage": {
          "title": "üí∞ Token Usage & Cost Tracking",
          "description": "Reportes de uso de tokens v√≠a traces de Jaeger para control de costos:",
          "dataExtracted": "Datos extra√≠dos de spans OpenTelemetry con atributos"
        },
        "stateSnapshot": {
          "title": "üì∏ State Snapshot Telemetry",
          "description": "Cada response incluye un snapshot del estado para debug de conversaciones:"
        },
        "ragTelemetry": {
          "title": "üéØ RAG Decision Telemetry",
          "description": "Explicabilidad de decisiones del pipeline de pricing/RAG:",
          "allowsIdentify": "Permite identificar: cat√°logo incompleto, aliases faltando, threshold de score inadecuado."
        },
        "usageMonitoring": {
          "title": "üì° Usage Monitoring Middleware",
          "description": "Monitoreo de endpoints para decisiones de deprecaci√≥n:",
          "nonIntrusive": "Non-intrusive",
          "nonIntrusiveDesc": ": No bloquea requests, solo observa",
          "sampleRate": "Sample rate",
          "sampleRateDesc": ": Configurable por ambiente (prod: 1%, dev: 100%)",
          "thirtyDaysData": "30+ days data",
          "thirtyDaysDesc": ": Recopila datos antes de decisiones de eliminaci√≥n",
          "endpointTracking": "Endpoint tracking",
          "endpointTrackingDesc": ": Identifica endpoints legados a√∫n en uso"
        },
        "performanceThresholds": {
          "title": "üìà Performance Thresholds",
          "description": "Thresholds autom√°ticos para alertas:",
          "warning": "‚ö†Ô∏è Warning",
          "critical": "üö® Critical"
        },
        "title": "Stack completo"
      },
      "architecture": {
        "stackTitle": "OBSERVABILITY STACK",
        "orchestrator": "Orchestrator",
        "aiEngine": "AI Engine",
        "memoryEngine": "Memory Engine",
        "metricsLabel": "metrics",
        "prometheusSection": "PROMETHEUS",
        "prometheusLine1": "- Business metrics (handover, booking, AI)",
        "prometheusLine2": "- System metrics (latency, errors, cache)",
        "prometheusLine3": "- Custom metrics (RAG, tool budget)",
        "grafanaSection": "GRAFANA DASHBOARDS",
        "grafanaLine1": "- Real-time KPIs per tenant",
        "grafanaLine2": "- Cost tracking & forecasting",
        "grafanaLine3": "- Alert rules & notifications",
        "otelSection": "OPENTELEMETRY + JAEGER",
        "otelLine1": "- Distributed traces across services",
        "otelLine2": "- Token usage extraction from spans",
        "otelLine3": "- Latency breakdown per operation",
        "lokiSection": "LOKI + JSON LOGS",
        "lokiLine1": "- Structured logging with trace correlation",
        "lokiLine2": "- trace_id + span_id in every log entry",
        "lokiLine3": "- Searchable by tenant, operation, error",
        "title": "Arquitectura"
      },
      "decisions": {
        "ownershipQ": "¬øPor qu√© una ownership table para m√©tricas?",
        "ownershipA": "En sistemas distribuidos, m√∫ltiples servicios pueden observar el mismo evento. Sin ownership claro, m√©tricas de handover ser√≠an emitidas por el Orchestrator Y por el AI Engine, causando double counting. La ownership table define un √∫nico emisor por m√©trica.",
        "tracesQ": "¬øPor qu√© extraer tokens de traces y no de logs?",
        "tracesA": "Los traces tienen estructura estandarizada (span attributes) y contexto (trace_id enlaza request y response). Los logs son texto libre que requiere parsing. Jaeger ya indexa spans por atributo, facilitando queries como \"total tokens por modelo en el √∫ltimo mes\".",
        "snapshotQ": "¬øPor qu√© state snapshot en response_metadata?",
        "snapshotA": "El debugging de conversaciones requiere conocer el estado exacto despu√©s de cada turno. Incluir el snapshot en el response permite reproducir problemas sin acceder a logs o traces. El frontend puede mostrar \"estado interno\" en modo debug.",
        "sampleRateQ": "¬øPor qu√© sample rate configurable?",
        "sampleRateA": "En producci√≥n con millones de requests, 100% sampling es caro (storage, processing). 1-10% sampling captura anomal√≠as suficientes para debug. En dev/staging, 100% permite debug completo de cada request.",
        "title": "Decisiones t√©cnicas"
      },
      "techStack": {
        "title": "Stack t√©cnica"
      },
      "cta": {
        "next": "Siguiente: Backend Orchestrator ‚Üí"
      }
    },
    "frontend": {
      "backToPortfolio": "Volver al portfolio",
      "badge": "User Interface",
      "title": "Frontend Apps",
      "description": "Dos aplicaciones Vue.js 3 especializadas: Admin Dashboard para operadores de cada tenant y SuperAdmin Panel para gesti√≥n global de la plataforma. WebSocket en tiempo real, gesti√≥n de handover e interfaces responsivas.",
      "architectureTitle": "Arquitectura: 2 Apps, 2 Prop√≥sitos",
      "rbac": {
        "title": "RBAC (Role-Based Access Control)",
        "admin": "admin ‚Üí Acceso al Admin App (3000) de su tenant",
        "superadmin": "superadmin ‚Üí Acceso al SuperAdmin (3001) + todos los tenants"
      },
      "adminDashboard": {
        "title": "Admin Dashboard",
        "port": "Port 3000",
        "description": "Interfaz para operadores y administradores de cada tenant. Enfocada en atenci√≥n al cliente y gesti√≥n del d√≠a a d√≠a.",
        "featuresTitle": "Features:",
        "features": {
          "chat": "Chat en tiempo real con clientes (WebSocket)",
          "handover": "Gesti√≥n de handover (timer auto-return 30min)",
          "dashboard": "Dashboard de m√©tricas del tenant",
          "conversations": "Lista de conversaciones activas",
          "history": "Historial de atenciones",
          "notifications": "Notificaciones de nuevos mensajes"
        }
      },
      "superAdminPanel": {
        "title": "SuperAdmin Panel",
        "port": "Port 3001",
        "description": "Interfaz para la gesti√≥n global de la plataforma. Configuraci√≥n, aprovisionamiento de tenants y monitoreo.",
        "featuresTitle": "Features:",
        "features": {
          "tenants": "Gesti√≥n de tenants (CRUD)",
          "users": "Gesti√≥n de usuarios y permisos",
          "config": "Configuraci√≥n global de la plataforma",
          "monitoring": "Monitoreo cross-tenant",
          "analytics": "Analytics e informes",
          "provisioning": "Aprovisionamiento de nuevos tenants",
          "prompts": "Configuraci√≥n de prompts por tenant",
          "llmPools": "LLM Pools & Key Groups management",
          "preflight": "Preflight panel (health checks)",
          "defaults": "System defaults (global configs)"
        }
      },
      "websocket": {
        "title": "WebSocket en tiempo real",
        "description": "Comunicaci√≥n bidireccional para actualizaciones instant√°neas.",
        "events": {
          "newMessage": "new_message: Nuevo mensaje del cliente",
          "statusChange": "status_change: Cambio de estado de conversaci√≥n",
          "handoverUpdate": "handover_update: Actualizaci√≥n de handover"
        }
      },
      "handover": {
        "title": "Gesti√≥n de Handover",
        "description": "Sistema completo de transferencia IA ‚Üî Humano.",
        "features": {
          "takeover": "Takeover manual por el operador",
          "autoReturn": "Auto-return despu√©s de 30min de inactividad",
          "history": "Historial de transferencias"
        }
      },
      "components": {
        "title": "Componentes reutilizables",
        "description": "Biblioteca de componentes Vue.js compartidos entre las dos aplicaciones."
      },
      "techStack": {
        "title": "Stack t√©cnico",
        "framework": "Framework",
        "styling": "Styling",
        "state": "State",
        "realtime": "Real-time",
        "router": "Router",
        "http": "HTTP",
        "build": "Build",
        "container": "Container",
        "backendIntegration": {
          "title": "Integraci√≥n con Backend",
          "restApis": "REST APIs",
          "websocket": "WebSocket"
        }
      },
      "cta": {
        "title": "Explora otros case studies",
        "description": "Mira c√≥mo se construyeron otros componentes del Optimus",
        "button": "Entrar en contacto"
      },
      "footer": "Case Study: Frontend Apps ‚Äî Optimus AI Platform",
      "meta": {
        "title": "Frontend Apps - Optimus AI | Marcelo Marleta",
        "description": "Case study: Aplicaciones Vue.js 3 para gesti√≥n de atenci√≥n con WebSocket en tiempo real y RBAC."
      },
      "chatRealtime": {
        "title": "Chat en tiempo real con WebSocket",
        "description": "La interfaz de chat usa WebSocket para actualizaciones en tiempo real. Cuando llega un nuevo mensaje (WhatsApp, web, etc.), el operador lo ve instant√°neamente sin refresh.",
        "flowTitle": "Flujo WebSocket",
        "eventsTitle": "Eventos soportados",
        "events": {
          "newMessage": "Nuevo mensaje en la conversaci√≥n",
          "conversationUpdated": "Estado o metadata alterados",
          "handoverStarted": "Operador asumi√≥ la conversaci√≥n",
          "handoverEnded": "La conversaci√≥n volvi√≥ a la IA",
          "typing": "El cliente est√° escribiendo"
        }
      },
      "handoverManagement": {
        "title": "Handover Management",
        "description": "Cuando un operador asume una conversaci√≥n (handover), la UI muestra un timer de 30 minutos. Si no hay interacci√≥n, la conversaci√≥n vuelve autom√°ticamente a la IA.",
        "states": {
          "aiServing": {
            "title": "1. IA Atendiendo",
            "description": "Estado normal. La IA responde autom√°ticamente. El operador puede visualizar pero no interviene."
          },
          "handoverActive": {
            "title": "2. Handover Activo",
            "description": "Operador asumi√≥. Timer de 30 min visible. La IA pausa, los mensajes van directo al operador."
          },
          "timerExpires": {
            "title": "3. El timer expira",
            "description": "Sin acci√≥n en 30min ‚Üí auto-return para la IA. El operador es notificado antes (warning en 5min)."
          }
        },
        "timerUiTitle": "Timer UI Component",
        "extend": "Extender +15min",
        "returningSoon": "¬°Retorno en breve!",
        "timeRemaining": "Tiempo restante"
      },
      "superAdminFeatures": {
        "title": "SuperAdmin: Gesti√≥n global",
        "tenantManagement": {
          "title": "Gesti√≥n de tenants",
          "list": "Lista de tenants con estado, vertical y √∫ltima actividad",
          "create": "Crear tenant v√≠a wizard (elige vertical, configura identity)",
          "edit": "Editar tenant (nombre, timezone, locale, features)",
          "deactivate": "Desactivar/Eliminar con confirmaci√≥n y soft-delete"
        },
        "promptConfig": {
          "title": "Configuraci√≥n de Prompts",
          "systemPrompt": "System prompt customizado por tenant",
          "greeting": "Greeting message (primera mensaje de la IA)",
          "intent": "Intent classification prompt",
          "handoverContext": "Handover context (resumen para operador)",
          "variables": "Variables override (assistant_name, rules, etc.)"
        },
        "llmPools": {
          "title": "LLM Pools & Keys",
          "globalPools": "Pools globales (chat, tools, embeddings)",
          "keyGroups": "Key Groups con m√∫ltiples API keys",
          "reveal": "Reveal protegido (solo superadmin ve keys)",
          "health": "Health status de cada key/pool"
        },
        "preflightPanel": {
          "title": "Preflight Panel",
          "ok": "OK - Todas las configs v√°lidas",
          "warning": "Warning - Usando defaults gen√©ricos",
          "critical": "Critical - Falta assistant_name o template vac√≠o",
          "sourceBadges": "Source badges - Seeded vs Override vs Default"
        }
      },
      "dashboard": {
        "title": "Dashboard multi-tenant",
        "description": "El Admin Dashboard muestra m√©tricas espec√≠ficas del tenant logado. Conversaciones activas, tiempo medio de respuesta, handovers y m√°s.",
        "metrics": {
          "conversationsToday": "Conversaciones hoy",
          "activeNow": "Activas ahora",
          "inHandover": "En handover",
          "responseTime": "Tiempo de respuesta"
        },
        "conversationsList": {
          "title": "Lista de conversaciones",
          "lastMsg": "√öltimo msg",
          "aiResponding": "IA respondiendo",
          "handover": "Handover",
          "operator": "Operador"
        }
      },
      "results": {
        "title": "Resultados",
        "websocketLatency": "Latencia WebSocket",
        "websocketLatencyDesc": "Mensajes en tiempo real",
        "specializedApps": "Apps especializadas",
        "specializedAppsDesc": "Admin + SuperAdmin",
        "accessControl": "Control de acceso",
        "accessControlDesc": "admin vs superadmin",
        "autoReturnHandover": "Auto-return Handover",
        "autoReturnHandoverDesc": "Timer configurable"
      }
    },
    "optimus": {
      "back": "‚Üê Volver",
      "title": "Optimus",
      "subtitle": "Plataforma de chatbots de IA para millones de usuarios",
      "problem": {
        "title": "El Problema Una empresa necesitaba una plataforma de chatbots que atendiera cl√≠nicas, e-commerce, despachos de abogados ‚Äî cualquier vertical de negocio. El sistema deb√≠a escalar a millones de usuarios, mantener el contexto de conversaciones largas y aislar completamente los datos entre clientes. Los chatbots gen√©ricos no sirven. Olvidan lo que dijiste hace 5 mensajes y no entienden que \"diente 36\" en una cl√≠nica es informaci√≥n cr√≠tica que no puede perderse.",
        "p1": "El Problema Una empresa necesitaba una plataforma de chatbots que atendiera cl√≠nicas, e-commerce, despachos de abogados ‚Äî cualquier vertical de negocio. El sistema deb√≠a escalar a millones de usuarios, mantener el contexto de conversaciones largas y aislar completamente los datos entre clientes. Los chatbots gen√©ricos no sirven. Olvidan lo que dijiste hace 5 mensajes y no entienden que \"diente 36\" en una cl√≠nica es informaci√≥n cr√≠tica que no puede perderse.",
        "p2": "El Problema Una empresa necesitaba una plataforma de chatbots que atendiera cl√≠nicas, e-commerce, despachos de abogados ‚Äî cualquier vertical de negocio. El sistema deb√≠a escalar a millones de usuarios, mantener el contexto de conversaciones largas y aislar completamente los datos entre clientes. Los chatbots gen√©ricos no sirven. Olvidan lo que dijiste hace 5 mensajes y no entienden que \"diente 36\" en una cl√≠nica es informaci√≥n cr√≠tica que no puede perderse."
      },
      "solution": {
        "title": "La Soluci√≥n",
        "intro": "Arquitectura de microservicios desde cero, pensada para producci√≥n desde el primer d√≠a:",
        "orchestrator": "Gateway √∫nico. Rate limiting, cach√©, circuit breaker.",
        "aiEngine": "Procesa conversaciones con LangChain. Cero acceso a base de datos.",
        "memoryEngine": "Due√±o de PostgreSQL. Memoria jer√°rquica (hot/warm/cold).",
        "rulesEngine": "Automatizaciones de negocio por vertical."
      },
      "multiTenancy": {
        "title": "Multi-tenancy real",
        "p1": "Cada cliente tiene su propio esquema en PostgreSQL ({clinicExample}, {storeExample}). No es solo un tenant_id en una tabla compartida ‚Äî es aislamiento real. Un bug en el c√≥digo de un tenant no filtra datos de otro."
      },
      "forgetting": {
        "title": "El problema del \"olvido\" Los chatbots pierden contexto. Despu√©s de 50 mensajes, olvidan que reservaste una cita para el martes a las 14h. Lo resolv√≠ con memoria en tres capas:",
        "p1": "El problema del \"olvido\" Los chatbots pierden contexto. Despu√©s de 50 mensajes, olvidan que reservaste una cita para el martes a las 14h. Lo resolv√≠ con memoria en tres capas:",
        "p2": "El problema del \"olvido\" Los chatbots pierden contexto. Despu√©s de 50 mensajes, olvidan que reservaste una cita para el martes a las 14h. Lo resolv√≠ con memoria en tres capas:",
        "hot": "Redis, √∫ltimos mensajes, acceso instant√°neo",
        "warm": "Redis, contexto reciente, TTL mayor",
        "cold": "PostgreSQL, historial completo",
        "p3": "Cuando un operador humano devuelve al bot, el sistema genera un resumen v√≠a GPT-4 con plantillas espec√≠ficas por vertical. En una cl√≠nica, sabe que \"diente 36\" y \"amoxicilina 500mg\" son cr√≠ticos."
      },
      "numbers": {
        "title": "N√∫meros",
        "latency": "Latencia P95",
        "cacheHit": "Cache hit",
        "uptime": "Uptime",
        "throughput": "Throughput"
      },
      "stack": {
        "title": "Stack"
      },
      "learnings": {
        "title": "Lo que aprend√≠",
        "p1Label": "La separaci√≥n de responsabilidades no es un capricho.",
        "p1": "Despu√©s de 6 meses, cuando necesitas cambiar el cach√© sin romper el AI Engine, lo agradeces.",
        "p2Label": "El multi-tenancy debe pensarse desde el d√≠a uno.",
        "p2": "Esquema por tenant en PostgreSQL es m√°s trabajo inicial, pero duermes tranquilo.",
        "p3Label": "La memoria del chatbot est√° subestimada.",
        "p3": "Todo el mundo se enfoca en el modelo. Nadie habla de lo que pasa despu√©s de 200 mensajes."
      },
      "cta": {
        "interested": "¬øTe interesa construir algo parecido?",
        "letsChat": "Hablemos"
      }
    },
    "aiEngine": {
      "back": "Volver",
      "platformName": "Optimus AI Platform",
      "badge1": "Core Service",
      "badge2": "Arquitectura de IA",
      "title": "AI Conversation",
      "titleHighlight": "Engine",
      "subtitle": "Motor de conversaci√≥n enterprise que separa l√≥gica determin√≠stica de lenguaje natural. LangGraph orquesta 20+ nodos especializados, una FSM de 8 estados garantiza comportamientos cr√≠ticos, y el Semantic Router decide en &lt;10ms cu√°ndo el LLM puede ser bypassado.",
      "stats": {
        "nodes": "Nodos LangGraph",
        "states": "Estados FSM",
        "routing": "Semantic Routing",
        "uptime": "Uptime"
      },
      "nav": {
        "problem": "Problema",
        "architecture": "Arquitectura",
        "semanticRouting": "Semantic Routing",
        "fsm": "Booking FSM",
        "contextComposer": "Context Composer",
        "fastLane": "Pricing Fast Lane",
        "reducer": "Flow Reducer",
        "retry": "Retry Policies",
        "results": "Resultados"
      },
      "sections": {
        "problem": {
          "title": "El Problema",
          "content1": "Los chatbots basados puramente en LLMs sufren un problema fundamental:",
          "nonDeterminism": "no determinismo",
          "scenariosTitle": "Escenarios inaceptables",
          "scenarios": {
            "hallucination": {
              "title": "\"Alucinaci√≥n de horario\":",
              "content": "El LLM confirma una consulta a las 14h cuando el usuario dijo 15h. El paciente pierde la cita, la cl√≠nica pierde ingresos."
            },
            "ambiguous": {
              "title": "\"Confirmaci√≥n ambigua\":",
              "content": "El usuario dice \"ok\", el LLM interpreta como confirmaci√≥n. Pero era \"ok, entendido\" (acknowledgement), no \"ok, confirma\"."
            },
            "drift": {
              "title": "\"Intent drift\":",
              "content": "La conversaci√≥n sobre precio se convierte en agendamiento sin que el usuario lo pida. LLM \"ayudando demasiado\"."
            },
            "loop": {
              "title": "\"Bucle infinito\":",
              "content": "El LLM llama una herramienta, falla, llama de nuevo, falla... hasta timeout o explota el costo."
            }
          },
          "conclusion": "Para un sistema enterprise de agendamiento m√©dico/odontol√≥gico, esto es inaceptable. La soluci√≥n no es \"mejorar el prompt\" ‚Äî es separar lo que debe ser determin√≠stico (decisiones de negocio) de lo que puede ser probabil√≠stico (generaci√≥n de lenguaje natural).",
          "content2": ". El mismo input puede generar outputs diferentes, y decisiones cr√≠ticas de negocio quedan a merced de \"temperatura\" y contexto aleatorio."
        },
        "architecture": {
          "title": "Arquitectura h√≠brida",
          "intro1": "El AI Engine implementa una arquitectura h√≠brida donde la",
          "introHighlight2": "tareas donde la creatividad es deseable",
          "diagramTitle": "Flujo de ejecuci√≥n",
          "langGraphTitle": "LangGraph: ¬øPor qu√© no chains simples?",
          "langGraphExplanation": "Las chains son lineales ‚Äî entrada ‚Üí procesamiento ‚Üí salida. El booking flow necesita ramificaciones complejas: el usuario puede cancelar en medio de un reschedule, pedir clarificaci√≥n o escalar a un humano en cualquier momento. LangGraph permite modelar esto como un grafo real.",
          "intro2": "(FSM + reglas) y el LLM se usa solo para",
          "intro3": "(humanizaci√≥n, clarificaci√≥n).",
          "introHighlight1": "l√≥gica de negocio es 100% determin√≠stica"
        },
        "semanticRouting": {
          "title": "Semantic Routing",
          "intro": "Antes de llamar al LLM para an√°lisis estructurado (caro, ~200ms), el Semantic Router intenta clasificar el intent v√≠a embeddings (barato, &lt;10ms). Si la confianza es alta, bypassa el LLM completamente.",
          "hybridAlphaTitle": "Hybrid Alpha: Embeddings + Keywords",
          "hybridAlphaExplanation": "Embeddings puros fallan en casos donde las palabras clave son cr√≠ticas (ej: \"cancelar\" vs \"me gustar√≠a reprogramar\"). El Semantic Router usa clasificaci√≥n h√≠brida:",
          "hybridAlphaConfig": "Configurable v√≠a env:",
          "params": {
            "hybridAlpha": {
              "title": "HYBRID_ALPHA",
              "description": "0.7 = 70% embeddings. Valores menores priorizan keywords."
            },
            "abstainThreshold": {
              "title": "ABSTAIN_THRESHOLD",
              "description": "0.55 = confianza m√≠nima. Debajo de eso, pasa al LLM."
            },
            "biasWeight": {
              "title": "BIAS_WEIGHT",
              "description": "0.03 = boost para intents cr√≠ticos (booking > greeting)."
            }
          },
          "resultTitle": "‚úì Resultado",
          "resultContent": "~40% de las requests se clasifican con alta confianza y bypassan el LLM completamente. Ahorro de ~$0.002/request √ó 40% = reducci√≥n significativa de costo OpenAI."
        },
        "fsm": {
          "title": "Booking State Machine",
          "intro": "El coraz√≥n del booking flow es una FSM (Finite State Machine) que define exactamente qu√© transiciones son v√°lidas. No importa lo que el LLM \"piense\" ‚Äî si la transici√≥n no est√° en la tabla, no ocurre.",
          "diagramTitle": "Estados y transiciones",
          "transitionsTitle": "Transiciones v√°lidas (SSoT)",
          "operationsTitle": "Operaciones soportadas",
          "operations": {
            "schedule": {
              "title": "schedule",
              "description": "Nuevo agendamiento. Busca slots ‚Üí selecci√≥n ‚Üí confirmaci√≥n ‚Üí ERP create."
            },
            "reschedule": {
              "title": "reschedule",
              "description": "Reagendar existente. Busca booking ‚Üí slots ‚Üí confirmaci√≥n ‚Üí ERP update."
            },
            "cancel": {
              "title": "cancel",
              "description": "Cancelar existente. Busca booking ‚Üí confirmaci√≥n ‚Üí ERP delete."
            }
          }
        },
        "contextComposer": {
          "title": "Context Composer (ECA)",
          "intro": "El Context Composer implementa la Enhanced Context Architecture (ECA) ‚Äî un sistema determin√≠stico de ensamblaje de contexto que busca datos de m√∫ltiples fuentes, aplica presupuesto de tokens y formatea en bloques ordenados para el LLM.",
          "budgetTitle": "Gesti√≥n de budget",
          "budgetIntro": "Con 1200 tokens de contexto y m√∫ltiples fuentes, es f√°cil exceder el budget. El Context Composer usa truncation inteligente:",
          "budgetRules": {
            "untouchable": {
              "title": "Bloques intocables:",
              "content": "IDENTITY, RULES, INPUT nunca se truncan"
            },
            "semantic": {
              "title": "Compresi√≥n sem√°ntica:",
              "content": "MEMORY puede comprimirse (90% de reducci√≥n v√≠a Memory Engine)"
            },
            "priority": {
              "title": "Truncation por prioridad:",
              "content": "FOCUS (RAG) se trunca primero si es necesario"
            }
          }
        },
        "fastLane": {
          "title": "Pricing Fast Lane",
          "intro": "Las consultas de precio son el caso de uso m√°s com√∫n (~35% de los mensajes) y tienen un patr√≥n predecible: b√∫squeda RAG + formateo. El Pricing Fast Lane ejecuta esto directamente, sin pasar por agent_node (que hace iteraciones LLM costosas).",
          "resultTitle": "‚ö° Resultado",
          "resultContent": "Fast lane reduce la latencia de ~2s (agent iteration) a ~200ms (RAG directo). Cache hit: &lt;50ms. Sin costo de tokens LLM para ~35% de las requests."
        },
        "reducer": {
          "title": "Booking Flow Reducer",
          "intro": "El Reducer es el guardi√°n del estado booking_flow. Todo update pasa por √©l, que valida whitelist de sources, monotonicity de turn_seq y transiciones v√°lidas. Si algo viola las invariantes, el update se rechaza.",
          "whyReducerTitle": "¬øPor qu√© Reducer?",
          "reasons": {
            "raceConditions": {
              "title": "Previene race conditions:",
              "content": "M√∫ltiples nodos pueden intentar actualizar el estado simult√°neamente. Reducer serializa y valida."
            },
            "audit": {
              "title": "Auditor√≠a:",
              "content": "Cada update se loguea con source, turn_seq y transici√≥n. Facilita el debugging."
            },
            "metrics": {
              "title": "M√©tricas:",
              "content": "Prometheus counters para updates y rejections por reason."
            }
          }
        },
        "retry": {
          "title": "Retry Policies",
          "intro": "No todo error merece retry. Errores transientes (timeout, rate limit) son retriables. Errores permanentes (auth failure, bad request) no lo son ‚Äî retry solo gasta tiempo y dinero.",
          "warningTitle": "‚ö†Ô∏è ¬øPor qu√© whitelist y no blacklist?",
          "warningContent": "Blacklist es peligrosa: si aparece un nuevo tipo de error permanente (ej: nueva exception del OpenAI SDK), ser√≠a retriado por default. Whitelist es fail-safe: solo retria lo que conocemos como transiente."
        },
        "results": {
          "title": "Resultados",
          "metrics": {
            "bypass": {
              "value": "~40%",
              "label": "Requests bypassan el LLM v√≠a Semantic Routing"
            },
            "classification": {
              "value": "&lt;10ms",
              "label": "Clasificaci√≥n v√≠a embeddings (p95)"
            },
            "transitions": {
              "value": "0",
              "label": "Transiciones inv√°lidas de FSM en producci√≥n"
            },
            "fastLane": {
              "value": "~200ms",
              "label": "Pricing Fast Lane (vs ~2s agent)"
            }
          },
          "decisionsTitle": "Decisiones t√©cnicas clave",
          "decisions": {
            "fsmSeparated": {
              "title": "FSM separada del LLM:",
              "content": "Decisiones de negocio son determin√≠sticas. El LLM solo humaniza."
            },
            "semanticPreLlm": {
              "title": "Semantic routing pre-LLM:",
              "content": "Clasificaci√≥n barata antes de gastar tokens."
            },
            "reducerWhitelist": {
              "title": "Reducer con whitelist:",
              "content": "Solo sources autorizados actualizan estado cr√≠tico."
            },
            "retryWhitelist": {
              "title": "Retry con whitelist:",
              "content": "Solo transient exceptions son retriadas."
            },
            "fastLanes": {
              "title": "Fast lanes para patrones conocidos:",
              "content": "Pricing no necesita iteraci√≥n LLM."
            }
          }
        }
      },
      "techStack": {
        "title": "Stack t√©cnico"
      },
      "cta": {
        "title": "Explora otros case studies",
        "description": "Mira c√≥mo se construyeron otros componentes del Optimus",
        "rulesEngine": "Rules Engine ‚Üí",
        "memoryEngine": "Memory Engine ‚Üí",
        "llmPool": "LLM Pool Management ‚Üí"
      },
      "footer": "Case Study: AI Conversation Engine ‚Äî Optimus AI Platform"
    },
    "mcpServers": {
      "tag": "Herramientas de desarrollo",
      "title": "Servidores MCP",
      "description": "Servidores Model Context Protocol personalizados para desarrollo con Claude Code. Herramientas de depuraci√≥n, validaci√≥n arquitectural y navegaci√≥n inteligente del codebase.",
      "whatIsMcp": {
        "title": "¬øQu√© es MCP?",
        "intro": "<strong class=\"text-white\">Model Context Protocol</strong> es un est√°ndar de Anthropic que permite extender asistentes de IA (como Claude) con herramientas personalizadas. En lugar de que la IA \"adivine\" sobre tu codebase, le das acceso real a tu arquitectura, contratos y convenciones.",
        "comment": "# Agregar servidor MCP a Claude Code"
      },
      "servers": {
        "title": "Servidores disponibles",
        "orchestrator": {
          "title": "backend_orchestrator_mcp",
          "intro": "Herramientas de depuraci√≥n para Backend Orchestrator:",
          "diagnoseGateway": "Health check completo del gateway",
          "analyzeCache": "Rendimiento del cach√© PubSub",
          "analyzeRateLimiting": "Estado de rate limiting por tenant",
          "generateRouter": "Plantilla de router siguiendo est√°ndares"
        },
        "optimus": {
          "title": "optimus_project_mcp",
          "intro": "12 herramientas para navegaci√≥n inteligente del codebase:",
          "systemOverview": "Visi√≥n general de la arquitectura",
          "serviceContract": "Contratos de cada microservicio",
          "validateDiff": "Validar cambios contra guardrails",
          "planChange": "Orientaciones arquitecturales para cambios"
        }
      },
      "validation": {
        "title": "Validaci√≥n arquitectural",
        "intro": "El <code class=\"text-cyan-400\">validate_diff verifica si un diff respeta los guardrails arquitecturales del proyecto:",
        "violationDetected": "‚ùå Violaci√≥n Detectada ai-engine/src/service.py: Line 42 \"import sqlalchemy\" ‚Üê ¬°AI Engine no puede acceder a la BD directamente! Guardrail: \"All data operations must go through Memory Engine APIs\"",
        "violationExample": "‚ùå Violaci√≥n Detectada ai-engine/src/service.py: Line 42 \"import sqlalchemy\" ‚Üê ¬°AI Engine no puede acceder a la BD directamente! Guardrail: \"All data operations must go through Memory Engine APIs\"",
        "validDiff": "‚úÖ Diff v√°lido ai-engine/src/service.py: Line 42 \"await memory_engine_client.get_data(...)\" ‚úì Respeta el l√≠mite de la API de Memory Engine",
        "validExample": "‚úÖ Diff v√°lido ai-engine/src/service.py: Line 42 \"await memory_engine_client.get_data(...)\" ‚úì Respeta el l√≠mite de la API de Memory Engine"
      },
      "hotReload": {
        "title": "Hot Reload",
        "intro": "Los m√≥dulos se recargan sin reiniciar el servidor MCP:"
      },
      "stack": {
        "title": "Stack t√©cnica"
      },
      "cta": {
        "next": "Siguiente: Feed-RSS Monitor ‚Üí"
      }
    },
    "feedRss": {
      "tag": "Automatizaci√≥n",
      "title": "Feed-RSS Monitor",
      "description": "Pipeline de automatizaci√≥n de contenido que monitorea feeds RSS, filtra por keywords, genera guiones v√≠a OpenAI y notifica en Telegram/Discord.",
      "stats": {
        "monitoredFeeds": "Feeds monitorizados",
        "aiKeywords": "Keywords de IA",
        "asyncPipeline": "Python Pipeline"
      },
      "overview": {
        "title": "Visi√≥n general",
        "intro": "Soluci√≥n para creadores de contenido que necesitan seguir noticias de IA/tech y transformarlas r√°pidamente en contenido para redes sociales.",
        "input": "Input",
        "inputDesc": "TechCrunch, The Verge, Wired, Ars Technica, MIT Tech Review, Engadget",
        "output": "Output",
        "outputDesc": "Guiones para YouTube Shorts (50s) entregados v√≠a Telegram/Discord"
      },
      "architecture": {
        "title": "Arquitectura"
      },
      "services": {
        "title": "Arquitectura modular",
        "feedService": {
          "title": "FeedService",
          "desc": "B√∫squeda as√≠ncrona de feeds con aiohttp. Timeout configurable, retry en fallos, normalizaci√≥n de entries a modelo Pydantic."
        },
        "filterService": {
          "title": "FilterService",
          "desc": "Filtra noticias por keywords (case-insensitive). Keywords configurables v√≠a .env o archivo externo. Combina t√≠tulo + resumen para matching."
        },
        "aiService": {
          "title": "AIService",
          "desc": "Integraci√≥n OpenAI con prompt optimizado para guiones de Shorts. Formato estructurado: gancho impactante ‚Üí 3-5 frases de esencia ‚Üí CTA con pregunta."
        },
        "stateService": {
          "title": "StateService",
          "desc": "Persiste IDs de noticias ya procesadas en JSON. Evita reprocesamiento y spam de notificaciones repetidas."
        }
      },
      "prompt": {
        "title": "Prompt Engineering",
        "intro": "El prompt fue optimizado para generar guiones concisos e impactantes:",
        "systemPrompt": "System Prompt:",
        "promptText": "\"Eres guionista del canal Cyber Inteligente. Crea guiones para YouTube Shorts de hasta 50 segundos, en espa√±ol claro y directo. Tono en√©rgico, futurista, sin rodeos. Formato: (1) Gancho en 1 frase; (2) Esencia en 3-5 frases cortas; (3) CTA con pregunta.\""
      },
      "usage": {
        "title": "Uso",
        "basicExecution": "# Ejecuci√≥n b√°sica",
        "withOptions": "# Con opciones"
      },
      "stack": {
        "title": "Stack t√©cnica"
      },
      "cta": {
        "backToHome": "‚Üê Volver al Home"
      }
    },
    "common": {
      "personalProject": "Projeto Pessoal",
      "technicalStack": "Stack T√©cnico",
      "results": "Resultados"
    },
    "pvcoach": {
      "tag": "Chess + AI",
      "tagSecondary": "Training Tool",
      "title": "PVCoach",
      "description": "Coach de ajedrez que combina Stockfish con un LLM para explicar movimientos. An√°lisis MultiPV, hints progresivos, explicaciones fundamentadas en las variaciones del engine y validaci√≥n autom√°tica para evitar alucinaciones.",
      "stats": {
        "llmProviders": "Proveedores LLM",
        "topNAnalysis": "An√°lisis Top-N",
        "hintLevels": "Niveles de hints",
        "groundedExplanations": "Explicaciones"
      },
      "nav": {
        "problem": "Problema",
        "architecture": "Arquitectura",
        "multipv": "MultiPV",
        "grounded": "Explicaciones grounded",
        "hints": "Hints progresivos",
        "providers": "Multi-Provider",
        "api": "API"
      },
      "problem": {
        "title": "El Problema",
        "intro": "Los engines de ajedrez como Stockfish son extremadamente fuertes, pero sus \"explicaciones\" son solo n√∫meros (centipawns) y variaciones en bruto. Los jugadores intermedios no consiguen entender <em>por qu√©</em> un movimiento es mejor.",
        "gapTitle": "El Gap de Entendimiento",
        "engineSays": "El engine dice:",
        "engineExample": "\"e4 +0.35, d4 +0.20\" ‚Äî OK, pero ¬øpor qu√©?",
        "llmHallucinates": "LLM puro alucina:",
        "llmExample": "\"Nf3 ataca a la dama\" ‚Äî No, no la ataca.",
        "humanExpensive": "Los an√°lisis humanos son caros:",
        "humanExample": "Los coaches cobran $50-100/hora.",
        "solution": "La soluci√≥n fue combinar la precisi√≥n de Stockfish con la capacidad explicativa del LLM, pero <strong class=\"text-white\">anclando las explicaciones en las variaciones reales del engine</strong> para evitar alucinaciones."
      },
      "architecture": {
        "title": "Arquitectura",
        "pipelineTitle": "Pipeline de an√°lisis",
        "fenPosition": "FEN Position",
        "stockfishMultipv": "Stockfish MultiPV",
        "depthMultipv": "depth=14, multipv=3",
        "llmGrounded": "LLM (Grounded Prompt)",
        "explanationPv": "Explicaci√≥n basada en las PVs",
        "validation": "Validaci√≥n",
        "crossCheck": "Cross-check con el engine"
      },
      "multipv": {
        "title": "MultiPV Analysis",
        "intro": "En lugar de pedir solo el \"mejor movimiento\", el sistema pide los top-N movimientos con sus variaciones completas. Esto permite comparar alternativas y explicar <em>por qu√©</em> un movimiento es mejor que otro.",
        "deltaExplanation": "El <code>delta_cp</code> muestra cu√°nto \"pierde\" cada alternativa en relaci√≥n con el mejor movimiento. Ej: si e4 = +35cp y d4 = +20cp, entonces el delta_cp de d4 = 15cp (pierde 0.15 peones)."
      },
      "grounded": {
        "title": "Grounded Explanations",
        "intro": "El secreto para evitar alucinaciones es <strong class=\"text-white\">anclar el LLM en las variaciones reales del engine</strong>. El prompt incluye las PVs formateadas, y la validaci√≥n verifica si la explicaci√≥n menciona movimientos que realmente existen.",
        "validationTitle": "Validaci√≥n autom√°tica",
        "resultTitle": "Resultado",
        "resultText": "Si el LLM menciona un movimiento que no existe en las PVs, el sistema devuelve un warning. Esto permite detectar alucinaciones antes de mostrarlas al usuario."
      },
      "hints": {
        "title": "Hints progresivos",
        "intro": "Para entrenar, revelar el movimiento inmediatamente no ayuda. El sistema ofrece hints progresivos en 3 niveles, del m√°s vago al m√°s espec√≠fico.",
        "level1Title": "Nivel 1: Pista",
        "level1Example": "\"Piensa en mover tu caballo.\"",
        "level1Desc": "Indica la pieza, no la casilla. Si hay captura o jaque, a√±ade una nota.",
        "level2Title": "Nivel 2: Plan",
        "level2Example": "\"Mejor movimiento: Nf3. Compara con d4, Nc3.\"",
        "level2Desc": "Revela el movimiento + alternativas + delta_cp.",
        "level3Title": "Nivel 3: Variante",
        "level3Example": "\"Nf3 ‚Üí d5 d4 Nf6 c4 e6\"",
        "level3Desc": "PV completa + explicaci√≥n LLM (opcional)."
      },
      "providers": {
        "title": "Multi-Provider LLM",
        "intro": "El sistema soporta 5 proveedores de LLM, permitiendo elegir por costo, velocidad o preferencia. Configurable v√≠a env vars o por request.",
        "openai": "GPT-4, GPT-3.5 ‚Äî Chat Completions API.",
        "anthropic": "Claude 3.5 Sonnet, Haiku ‚Äî Messages API.",
        "google": "Gemini 1.5 Flash, Pro ‚Äî GenerativeAI.",
        "openrouter": "Proxy para m√∫ltiples modelos ‚Äî OpenAI-compatible."
      },
      "api": {
        "title": "API Endpoints",
        "evaluatePosition": "Evaluaci√≥n MultiPV pura (sin LLM). Devuelve top-N candidatos con PVs y scores.",
        "explainPosition": "Evaluaci√≥n + explicaci√≥n LLM grounded. Incluye warnings de validaci√≥n.",
        "hintsPosition": "Hints progresivos (niveles 1-3). El nivel 3 puede incluir explicaci√≥n.",
        "analyze": "Descarga partidas de Lichess y analiza en batch."
      },
      "results": {
        "hallucinations": "Alucinaciones con validaci√≥n activa",
        "providers": "Proveedores LLM soportados",
        "cache": "TTL para evaluaciones y explicaciones",
        "hintLevels": "Niveles de hints progresivos"
      },
      "cta": {
        "title": "Explora otros proyectos",
        "subtitle": "Mira otros sistemas que constru√≠"
      },
      "footer": "Case Study: PVCoach ‚Äî Chess Training with AI"
    },
    "automark": {
      "meta": {
        "title": "AutoMark - Affiliate Marketing Platform | Marcelo Marleta",
        "description": "Case study: Plataforma SaaS multi-tenant de distribui√ß√£o inteligente de ofertas afiliadas. Shopee, WhatsApp, anti-spam, scoring inteligente."
      },
      "header": {
        "back": "Voltar",
        "projectType": "Projeto Pessoal"
      },
      "hero": {
        "tag1": "SaaS Platform",
        "tag2": "Affiliate Marketing",
        "title": "AutoMark",
        "titleHighlight": " Platform",
        "description": "Plataforma SaaS multi-tenant de distribui√ß√£o inteligente de ofertas afiliadas. Conecta marketplaces (Shopee, ML, Amazon) a canais (WhatsApp, Telegram) com automa√ß√µes anti-spam, scoring inteligente e deduplica√ß√£o.",
        "stat1Value": "Multi",
        "stat1Label": "Marketplace",
        "stat2Value": "Multi",
        "stat2Label": "Channel",
        "stat3Value": "48h",
        "stat3Label": "Dedupe Target",
        "stat4Value": "0",
        "stat4Label": "Spam/Ban"
      },
      "nav": {
        "problem": "Problema",
        "architecture": "Arquitetura",
        "providers": "Providers",
        "scoring": "Scoring",
        "dedupe": "Dedupe",
        "antiBan": "Anti-Ban",
        "automations": "Automa√ß√µes",
        "stack": "Stack"
      },
      "problem": {
        "title": "O Problema",
        "intro": "Afiliados enfrentam tr√™s problemas cr√≠ticos na distribui√ß√£o de ofertas:",
        "issue1Title": "Distribui√ß√£o manual n√£o escala:",
        "issue1Desc": "Postar links manualmente em grupos gera repeti√ß√£o, spam e ban. Tempo gasto vs convers√£o n√£o compensa.",
        "issue2Title": "Marketplaces s√£o fragmentados:",
        "issue2Desc": "Shopee, Mercado Livre, Amazon t√™m APIs diferentes, formatos diferentes, regras de afiliado diferentes.",
        "issue3Title": "WhatsApp pune comportamento rob√≥tico:",
        "issue3Desc": "Sem controle de cad√™ncia, dedupe e humaniza√ß√£o: shadow ban, bloqueio, queda de engajamento.",
        "objectiveTitle": "üéØ Objetivo",
        "objectiveDesc": "Criar uma plataforma que pare√ßa humana, poste o que converte, no lugar certo, na hora certa, sem spam."
      },
      "architecture": {
        "title": "Arquitetura Multi-Tenant",
        "intro": "A arquitetura segue princ√≠pios r√≠gidos que permitem evolu√ß√£o sem breaking changes:",
        "principle1Title": "Marketplace nunca hardcoded",
        "principle1Desc": "Shopee √© o primeiro conector, mas ML, Amazon, AliExpress s√£o plug-and-play.",
        "principle2Title": "Canal nunca hardcoded",
        "principle2Desc": "WhatsApp √© o primeiro, mas Telegram, Discord, Instagram seguem a mesma interface.",
        "principle3Title": "Automa√ß√£o gera Post, n√£o envia",
        "principle3Desc": "Separa√ß√£o de concerns: Automa√ß√£o decide O QUE, Dispatcher decide COMO.",
        "principle4Title": "Dedupe obrigat√≥rio",
        "principle4Desc": "Nenhum envio acontece sem passar pelo dedupe. Zero spam garantido.",
        "dataModelTitle": "Modelo de Dados",
        "rolesTitle": "Pap√©is e Permiss√µes",
        "superAdminTitle": "SuperAdmin (Plataforma)",
        "superAdminRole1": "Cria tenants",
        "superAdminRole2": "Define quais marketplaces existem",
        "superAdminRole3": "Controla feature flags",
        "superAdminRole4": "Observa sa√∫de global",
        "tenantAdminTitle": "Tenant Admin (Cliente)",
        "tenantAdminRole1": "Conecta canais (WhatsApp, Telegram)",
        "tenantAdminRole2": "Conecta afiliados (Shopee, ML)",
        "tenantAdminRole3": "Cria automa√ß√µes",
        "tenantAdminRole4": "V√™ hist√≥rico e m√©tricas"
      },
      "providers": {
        "title": "Provider Pattern",
        "intro": "Cada marketplace implementa uma interface comum. O provider n√£o sabe o que √© tenant ‚Äî tudo vem via tenant_connection. Isso permite adicionar novos marketplaces sem tocar no core.",
        "shopeeTitle": "Shopee Provider",
        "dedupeKeyTitle": "‚úì Dedupe Key",
        "dedupeKeyDesc": "O dedupe_key √© a identidade real do produto: shopee:123:456. Nunca usar t√≠tulo para dedupe ‚Äî varia√ß√µes de texto causariam spam."
      },
      "scoring": {
        "title": "Offer Scoring",
        "intro": "Nem toda oferta vale a pena postar. O sistema de scoring ranqueia ofertas por potencial de convers√£o, penalizando produtos suspeitos.",
        "formulaTitle": "F√≥rmula de Score",
        "weightsTitle": "Por que esses pesos?",
        "weight1Pct": "40%",
        "weight1Label": "Desconto:",
        "weight1Desc": "Principal driver de clique. Ofertas com desconto alto convertem mais.",
        "weight2Pct": "25%",
        "weight2Label": "Rating:",
        "weight2Desc": "Confian√ßa do produto. Rating baixo = devolu√ß√£o = comiss√£o cancelada.",
        "weight3Pct": "20%",
        "weight3Label": "Vendas:",
        "weight3Desc": "Prova social. Produto muito vendido tem valida√ß√£o de mercado.",
        "weight4Pct": "15%",
        "weight4Label": "Comiss√£o:",
        "weight4Desc": "Retorno para o afiliado. Mas comiss√£o alta demais √© red flag."
      },
      "dedupe": {
        "title": "Deduplica√ß√£o Anti-Spam",
        "intro": "O sistema de dedupe opera em dois escopos: por target (grupo espec√≠fico) e por channel (todos os grupos do canal). Isso previne spam tanto vertical quanto horizontal.",
        "targetScopeTitle": "Target Scope (48h)",
        "targetScopeDesc": "Mesmo produto n√£o pode ser enviado para o mesmo grupo em 48h. Evita repeti√ß√£o percebida pelos membros.",
        "channelScopeTitle": "Channel Scope (2-5min)",
        "channelScopeDesc": "Gap m√≠nimo entre qualquer envio para qualquer grupo. Evita burst que parece bot.",
        "cleanupTitle": "‚úì Cleanup Autom√°tico",
        "cleanupDesc": "Records expirados s√£o deletados periodicamente via cleanup_expired(). A tabela n√£o cresce indefinidamente."
      },
      "antiBan": {
        "title": "Anti-Ban (WhatsApp)",
        "intro": "WhatsApp detecta bots por padr√µes de envio. O sistema implementa m√∫ltiplas camadas de humaniza√ß√£o para evitar banimento:",
        "feature1Icon": "üñäÔ∏è",
        "feature1Title": "Typing Indicator:",
        "feature1Desc": "Antes de enviar, simula \"digitando...\" por 2-5 segundos (Evolution API).",
        "feature2Icon": "üé≤",
        "feature2Title": "Jitter Humano:",
        "feature2Desc": "Delay aleat√≥rio entre mensagens. Nunca intervalos exatos.",
        "feature3Icon": "üö¶",
        "feature3Title": "Rate Limit por Conta:",
        "feature3Desc": "Sem√°foro Redis limita msgs/minuto por n√∫mero. M√∫ltiplas contas = mais throughput.",
        "feature4Icon": "‚ö°",
        "feature4Title": "Circuit Breaker:",
        "feature4Desc": "Erro 429 ou 503 ‚Üí pausa autom√°tica de 30min para aquela conta.",
        "feature5Icon": "üåô",
        "feature5Title": "Quiet Hours:",
        "feature5Desc": "Configur√°vel por target: n√£o envia entre 23h-8h (ou custom)."
      },
      "automations": {
        "title": "Sistema de Automa√ß√µes",
        "intro": "Automa√ß√µes s√£o o cora√ß√£o do sistema. Definem O QUE buscar, ONDE enviar, e QUANDO executar.",
        "pipelineTitle": "Automation Pipeline",
        "typesTitle": "Tipos de Automa√ß√£o",
        "typeSearchTitle": "search",
        "typeSearchDesc": "Busca ativa no marketplace. Executa a cada intervalo configurado.",
        "typeFeedTitle": "feed",
        "typeFeedDesc": "Usa ofertas j√° no banco (ingest√£o externa). Aplica ranking e distribui.",
        "typeMonitorTitle": "monitor",
        "typeMonitorDesc": "Monitora pre√ßo de produtos espec√≠ficos. Alerta quando desconto atinge threshold.",
        "targetTitle": "AutomationTarget (Limites)",
        "targetConfigTitle": "Configura√ß√£o por Grupo"
      },
      "stack": {
        "title": "Stack T√©cnico",
        "backendTitle": "Backend",
        "frontendTitle": "Frontend",
        "integrationsTitle": "Integra√ß√µes",
        "infraTitle": "Infra"
      },
      "results": {
        "title": "Resultados",
        "stat1Value": "0",
        "stat1Label": "Bans de conta WhatsApp",
        "stat2Value": "100%",
        "stat2Label": "Dedupe coverage (zero spam)",
        "stat3Value": "Plug",
        "stat3Label": "& Play para novos marketplaces",
        "stat4Value": "Multi",
        "stat4Label": "Tenant desde o dia 1"
      },
      "cta": {
        "title": "Explore Outros Projetos",
        "description": "Veja outros sistemas que constru√≠"
      },
      "footer": {
        "caseStudy": "Case Study: AutoMark Platform ‚Äî Affiliate Marketing Automation"
      }
    },
    "icontei": {
      "meta": {
        "title": "iContei - Rede Social de Contadores | Marcelo Marleta",
        "description": "Case study: Plataforma full-stack de contadores compartilh√°veis com Next.js 16, FastAPI, WebSocket real-time, e verifica√ß√£o por IA."
      },
      "hero": {
        "tag1": "Full-Stack Platform",
        "tag2": "Social Network",
        "tag3": "Real-time",
        "title": "iContei",
        "description": "Rede social de contadores compartilh√°veis ‚Äî desde estat√≠sticas esportivas virais at√© marcos pessoais. Plataforma full-stack com Next.js 16, FastAPI, WebSockets, e verifica√ß√£o por IA."
      },
      "overview": {
        "title": "Vis√£o Geral",
        "productTitle": "O Produto",
        "productDesc1": "iContei √© uma plataforma social dedicada a contadores de todos os tipos ‚Äî desde estat√≠sticas esportivas virais (\"H√° 2.847 dias o Flamengo est√° sem t√≠tulo mundial\") at√© marcos pessoais (\"Faltam 127 dias para meu casamento\") e corporativos (\"1.567 dias sem acidentes de trabalho\").",
        "productDesc2": "O foco √© criar contadores visualmente impactantes para compartilhamento em redes sociais (TikTok, Instagram, Twitter) com previews din√¢micos, atualiza√ß√£o em tempo real, e comunidade engajada.",
        "useCasesTitle": "Casos de Uso",
        "publicTitle": "üìä P√∫blicos (Virais)",
        "publicExample1": "\"H√° 2.847 dias o Flamengo est√° sem t√≠tulo mundial\"",
        "publicExample2": "\"Faltam 180 dias para a Copa do Mundo 2026\"",
        "publicExample3": "\"Real Madrid h√° 45 dias sem perder no Bernab√©u\"",
        "personalTitle": "üíë Pessoais",
        "personalExample1": "\"Faltam 127 dias para meu casamento\"",
        "personalExample2": "\"H√° 1.234 dias que nos conhecemos\"",
        "corporateTitle": "üè¢ Corporativos",
        "corporateExample1": "\"1.567 dias sem acidentes de trabalho\"",
        "corporateExample2": "\"890 dias como l√≠der de mercado\""
      },
      "architecture": {
        "title": "Arquitetura Full-Stack",
        "frontendStackTitle": "Frontend Stack",
        "backendStackTitle": "Backend Stack"
      },
      "realtime": {
        "title": "Sistema Real-time",
        "description": "Contadores atualizam a cada segundo no frontend. Para suportar milhares de conex√µes simult√¢neas, implementei um sistema de WebSocket com Redis pub/sub, heartbeat, e rate limiting inteligente.",
        "websocketTitle": "WebSocket Manager",
        "websocketDesc": "Rate limiting dual: por usu√°rio autenticado (5 conex√µes) e por IP para an√¥nimos (20 conex√µes, considerando NAT/CGNAT). Heartbeat via Redis Sorted Set para detectar conex√µes mortas.",
        "pubsubTitle": "Redis Pub/Sub Distribution",
        "pubsubDesc": "Com Redis pub/sub, posso escalar horizontalmente o backend ‚Äî cada inst√¢ncia mant√©m suas conex√µes WebSocket e recebe atualiza√ß√µes via Redis.",
        "presenceTitle": "Sistema de Presen√ßa",
        "presenceStat1Value": "30s",
        "presenceStat1Label": "Heartbeat interval",
        "presenceStat2Value": "45s",
        "presenceStat2Label": "Presence timeout",
        "presenceStat3Value": "ZADD",
        "presenceStat3Label": "Redis Sorted Set",
        "presenceDesc": "Cliente envia heartbeat a cada 30s. Servidor usa ZRANGEBYSCORE para listar conex√µes ativas (timestamp > now - 45s). Conex√µes stale s√£o removidas automaticamente."
      },
      "aiVerification": {
        "title": "Verifica√ß√£o por IA",
        "description": "Contadores oficiais passam por verifica√ß√£o automatizada com IA para garantir que datas e informa√ß√µes est√£o corretas. Sistema multi-provider com fallback.",
        "serviceTitle": "AI Verification Service",
        "pipelineTitle": "Pipeline Brave Search + Groq",
        "pipelineDesc": "Para contadores que precisam de dados externos (ex: \"√∫ltima vit√≥ria do time X\"), uso Brave Search para buscar informa√ß√µes recentes e Groq para extrair dados estruturados."
      },
      "rankings": {
        "title": "Sistema de Rankings",
        "description": "Rankings em tempo real usando Redis Sorted Sets com algoritmo de scoring 60/30/10 que balanceia likes, coment√°rios e visualiza√ß√µes.",
        "algorithmTitle": "Algoritmo de Scoring",
        "redisTitle": "Redis Sorted Sets",
        "redisDesc": "ZADD para inserir, ZREVRANGE para buscar top N, ZREMRANGEBYRANK para manter tamanho controlado. O(log N) para todas as opera√ß√µes."
      },
      "automation": {
        "title": "Sistema de Automa√ß√£o",
        "description": "Contadores podem ser atualizados automaticamente via regras configur√°veis ‚Äî desde agendamentos cron at√© triggers baseados em APIs externas.",
        "scheduledTitle": "Scheduled",
        "scheduledDesc": "Cron expressions para atualiza√ß√£o peri√≥dica. Usa croniter para calcular pr√≥xima execu√ß√£o.",
        "apiTriggerTitle": "API Trigger",
        "apiTriggerDesc": "Integra√ß√£o com APIs externas (API-Football, etc.) para buscar dados automaticamente.",
        "crowdsourcedTitle": "Crowdsourced",
        "crowdsourcedDesc": "Usu√°rios podem sugerir atualiza√ß√µes que passam por aprova√ß√£o antes de serem aplicadas.",
        "sportsProviderTitle": "Sports API Provider",
        "sportsProviderDesc": "Provider Pattern permite adicionar novas fontes de dados facilmente. Cada provider implementa fetch_data() e retorna resposta padronizada."
      },
      "observability": {
        "title": "Observabilidade",
        "description": "Stack completa de observabilidade para monitorar a plataforma em produ√ß√£o.",
        "prometheusTitle": "Prometheus + Metrics",
        "otelTitle": "OpenTelemetry",
        "loggingTitle": "Structured Logging"
      },
      "testing": {
        "title": "Testes Automatizados",
        "description": "Cobertura completa com pytest (backend) e vitest + Playwright (frontend).",
        "backendTitle": "Backend (pytest)",
        "backendTestCount": "267",
        "backendTestLabel": "testes",
        "backendStatus": "‚úì",
        "backendStatusLabel": "passando",
        "frontendTitle": "Frontend (vitest + Playwright)",
        "frontendUnitCount": "21",
        "frontendUnitLabel": "unit tests",
        "frontendE2E": "E2E",
        "frontendE2ELabel": "Playwright"
      },
      "workers": {
        "title": "Background Workers",
        "description": "Processamento ass√≠ncrono para tarefas pesadas, mantendo a API responsiva.",
        "schedulerTitle": "Automation Scheduler",
        "schedulerDesc": "Executa regras de automa√ß√£o a cada 5 minutos. Calcula pr√≥ximo run com croniter.",
        "rankingTitle": "Ranking Worker",
        "rankingDesc": "Atualiza Redis Sorted Sets com scores calculados para cada per√≠odo (24h, 7d, 30d, all).",
        "reviewTitle": "Review Worker",
        "reviewDesc": "Processa filas de verifica√ß√£o de contadores, coordena com AI Verification Service.",
        "monitoringTitle": "AI Monitoring",
        "monitoringDesc": "Monitora contadores marcados para verifica√ß√£o cont√≠nua, atualiza quando dados mudam."
      },
      "roadmap": {
        "title": "Roadmap",
        "phase1Title": "Fase 1 - MVP ‚úÖ",
        "phase1Item1": "‚úì CRUD de contadores",
        "phase1Item2": "‚úì Sistema de temas",
        "phase1Item3": "‚úì Rankings (Trending)",
        "phase1Item4": "‚úì OG images din√¢micas",
        "phase1Item5": "‚úì Autentica√ß√£o",
        "phase1Item6": "‚úì Seguir + rea√ß√µes",
        "phase2Title": "Fase 2 - Social",
        "phase2Item1": "Feed personalizado",
        "phase2Item2": "Coment√°rios e discuss√µes",
        "phase2Item3": "Notifica√ß√µes push",
        "phase2Item4": "Badges e gamifica√ß√£o",
        "phase2Item5": "Perfis p√∫blicos robustos",
        "phase3Title": "Fase 3 - Empresas",
        "phase3Item1": "Perfis corporativos",
        "phase3Item2": "Multi-usu√°rio por org",
        "phase3Item3": "Dashboards analytics",
        "phase3Item4": "SSO corporativo",
        "phase3Item5": "Temas licenciados",
        "phase4Title": "Fase 4 - Creators",
        "phase4Item1": "Gera√ß√£o de v√≠deos (Remotion)",
        "phase4Item2": "SDK para redes sociais",
        "phase4Item3": "API p√∫blica",
        "phase4Item4": "Widgets embeddable",
        "phase4Item5": "Marketplace de templates"
      },
      "stackSection": {
        "title": "Stack Completa"
      },
      "cta": {
        "title": "Quer ver mais projetos?",
        "description": "Este √© um dos meus projetos pessoais. Explore tamb√©m o Optimus (plataforma de IA conversacional) e outros case studies no meu portfolio."
      }
    },
    "gratidiem": {
      "meta": {
        "title": "GratiDiem - App de Gratid√£o Flutter | Marcelo Marleta",
        "description": "Case study: App Flutter multi-plataforma de gratid√£o com Clean Architecture, Riverpod, Firebase, IA integrada com Gemini, e sistema de monetiza√ß√£o √©tica."
      },
      "hero": {
        "tag1": "Flutter App",
        "tag2": "Multi-Platform",
        "tag3": "Firebase",
        "title": "GratiDiem",
        "description": "Aplicativo de gratid√£o e bem-estar com 508+ arquivos Dart, 35+ telas, 86+ servi√ßos. Clean Architecture com Riverpod, dual persistence (Hive + Firebase), IA integrada com Gemini, e sistema de monetiza√ß√£o √©tica gamificado."
      },
      "overview": {
        "title": "Vis√£o Geral",
        "productTitle": "O Produto",
        "productDesc1": "GratiDiem √© um companheiro di√°rio de gratid√£o ‚Äî um aplicativo sofisticado que ajuda usu√°rios a cultivar bem-estar atrav√©s de pr√°ticas de gratid√£o, medita√ß√£o guiada, desafios di√°rios, e comunidade.",
        "productDesc2": "O app suporta 6 plataformas (Android, iOS, Web, macOS, Windows, Linux), 3 idiomas (PT, EN, ES), e √© constru√≠do para escalar para milh√µes de usu√°rios.",
        "metricsTitle": "M√©tricas do Codebase",
        "metricFilesValue": "508+",
        "metricFilesLabel": "Arquivos Dart",
        "metricScreensValue": "35+",
        "metricScreensLabel": "Telas",
        "metricServicesValue": "86+",
        "metricServicesLabel": "Services",
        "metricModelsValue": "126+",
        "metricModelsLabel": "Models"
      },
      "architecture": {
        "title": "Arquitetura Clean + Riverpod",
        "presentationTitle": "Presentation",
        "presentationDesc": "278+ arquivos, Material Design 3, responsive design, ConsumerWidget/ConsumerStatefulWidget",
        "stateTitle": "State Management",
        "stateDesc": "Riverpod com AsyncNotifier/StateNotifier, stream subscriptions, real-time updates",
        "businessTitle": "Business Logic",
        "businessDesc": "Singleton services + Repository pattern, 113 arquivos com responsabilidades claras",
        "dataTitle": "Data Layer",
        "dataDesc": "Dual persistence: Hive CE (local-first) + Firebase Firestore (cloud sync)"
      },
      "features": {
        "title": "Features do App",
        "gratitudeTitle": "üôè Gratitude Journal",
        "gratitudeDesc": "Di√°rio de gratid√£o com entradas di√°rias, categorias, tags, e busca full-text. Suporte a imagens e compartilhamento social.",
        "meditationTitle": "üßò Medita√ß√£o Guiada",
        "meditationDesc": "Player de √°udio com sess√µes de medita√ß√£o (manh√£, dia, ansiedade, noite, profunda). Just Audio + Audio Session para background playback.",
        "circlesTitle": "‚≠ï C√≠rculos (Tribos)",
        "circlesDesc": "Comunidades sociais com rituais em grupo, posts, desafios colaborativos, gamifica√ß√£o, e sync real-time via Firestore.",
        "challengesTitle": "üèÜ Challenges & Progression",
        "challengesDesc": "Desafios di√°rios, streaks, sistema de n√≠veis, √°rvore de progress√£o, achievements, e surprise rewards.",
        "nightRitualTitle": "üåô Night Ritual",
        "nightRitualDesc": "Ritual noturno guiado com medita√ß√£o, reflex√£o, inten√ß√µes para o pr√≥ximo dia. Scheduling com notifica√ß√µes locais.",
        "adversityTitle": "üíä Adversity Support",
        "adversityDesc": "M√≥dulo de sa√∫de mental com jornada de adversidade, pr√°ticas terap√™uticas, hist√≥rias inspiradoras, recursos de emerg√™ncia.",
        "timeCapsuleTitle": "‚è≥ Time Capsule",
        "timeCapsuleDesc": "C√°psulas do tempo para guardar mem√≥rias e gratid√µes a serem abertas no futuro.",
        "valuesTitle": "üéØ Values & Goals",
        "valuesDesc": "Defini√ß√£o de valores pessoais, visualiza√ß√£o de metas, reviews peri√≥dicos.",
        "analyticsTitle": "üìä Wellbeing Analytics",
        "analyticsDesc": "Assessments de bem-estar, gr√°ficos de humor (fl_chart), calend√°rio de atividades (table_calendar)."
      },
      "ai": {
        "title": "Integra√ß√£o com IA",
        "description": "Motor de IA multi-backend com Google Gemini, Hugging Face, e modelos on-device (TensorFlow Lite).",
        "engineTitle": "AI Engine",
        "capabilitiesTitle": "Capacidades de IA",
        "sentimentTitle": "An√°lise de Sentimentos",
        "sentimentDesc": "Detecta emo√ß√µes nas entradas de gratid√£o com cache para performance",
        "themesTitle": "Detec√ß√£o de Temas",
        "themesDesc": "Categoriza automaticamente entradas (fam√≠lia, trabalho, sa√∫de, etc.)",
        "responsesTitle": "Respostas Personalizadas",
        "responsesDesc": "Gera reflex√µes e sugest√µes baseadas no hist√≥rico do usu√°rio",
        "premiumTitle": "AI Premium Service",
        "premiumDesc": "Features avan√ßadas para usu√°rios premium com Gemini Pro",
        "aiAnalyticsTitle": "AI Analytics",
        "aiAnalyticsDesc": "Insights e tend√™ncias derivados das pr√°ticas de gratid√£o"
      },
      "monetization": {
        "title": "Sistema de Monetiza√ß√£o √âtica",
        "description": "Transformando an√∫ncios em \"momentos de gratid√£o\" ‚Äî monetiza√ß√£o integrada ao conceito do app, criando experi√™ncia significativa ao inv√©s de intrusiva.",
        "appealsTitle": "üôè Apelos Contextuais",
        "appealsDesc": "Mensagens de gratid√£o personalizadas baseadas no contexto do usu√°rio.",
        "appealsExample1": "P√≥s-Ritual: \"Se este app te ajudou...\"",
        "appealsExample2": "Streak: \"7 dias de gratid√£o! Retribua...\"",
        "appealsExample3": "Alta Energia: \"Sinta essa vibra√ß√£o positiva?\"",
        "appealsExample4": "Conquistas: \"Conquista desbloqueada!\"",
        "tokensTitle": "üéÆ Economia de Tokens",
        "tokensDesc": "Sistema gamificado com tokens que podem ser ganhos e usados no app.",
        "tokensExample1": "Daily bonus com multiplicadores",
        "tokensExample2": "Streak multipliers",
        "tokensExample3": "Achievement rewards",
        "tokensExample4": "Challenge completion",
        "remoteConfigTitle": "üìä Firebase Remote Config",
        "remoteConfigDesc": "Controle din√¢mico de toda a monetiza√ß√£o sem deploy.",
        "remoteConfigExample1": "Frequ√™ncia de an√∫ncios",
        "remoteConfigExample2": "Cooldown periods",
        "remoteConfigExample3": "A/B testing de mensagens",
        "remoteConfigExample4": "M√©tricas de convers√£o",
        "triggersTitle": "Gratitude Triggers Service"
      },
      "firebase": {
        "title": "Firebase Full Stack",
        "authTitle": "üîê Authentication",
        "storageTitle": "üì¶ Storage",
        "analyticsTitle": "üìä Analytics",
        "messagingTitle": "üîî Messaging"
      },
      "persistence": {
        "title": "Dual Persistence: Local-First",
        "description": "Arquitetura local-first com Hive CE para performance e offline, sincronizando automaticamente com Firebase Firestore.",
        "hiveTitle": "Hive CE (Local)",
        "hiveDesc": "197 TypeIDs registrados, c√≥digo gerado via build_runner, adapter registry centralizado.",
        "syncTitle": "Sync Strategy",
        "syncDesc": "Last-write-wins com detec√ß√£o de conflitos, queue de retry para offline, recovery service para reconex√£o."
      },
      "navigation": {
        "title": "Navega√ß√£o com GoRouter",
        "description": "100+ rotas declarativas com GoRouter, deep linking, redirect guards, e par√¢metros tipados."
      },
      "i18n": {
        "title": "Internacionaliza√ß√£o",
        "portuguese": "Portugu√™s",
        "portugueseDesc": "Idioma base (app_pt.arb)",
        "english": "English",
        "englishDesc": "app_en.arb",
        "spanish": "Espa√±ol",
        "spanishDesc": "app_es.arb",
        "summary": "200+ strings traduzidas usando ARB format (Application Resource Bundle), gera√ß√£o autom√°tica via flutter gen-l10n, script Python para tradu√ß√£o em lote."
      },
      "platforms": {
        "title": "6 Plataformas Suportadas",
        "android": "Android",
        "ios": "iOS",
        "web": "Web",
        "macos": "macOS",
        "windows": "Windows",
        "linux": "Linux"
      },
      "testing": {
        "title": "Testing & Quality",
        "unitTitle": "Unit Tests",
        "widgetTitle": "Widget Tests",
        "integrationTitle": "Integration Tests",
        "qualityTitle": "Code Quality"
      },
      "stackSection": {
        "title": "Stack Completa"
      },
      "cta": {
        "title": "Quer ver mais projetos?",
        "description": "Este √© um dos meus projetos pessoais mais completos em Flutter. Explore tamb√©m o iContei (rede social de contadores) e os projetos do Optimus."
      }
    },
    "memory": {
      "badge": "Sistema de Mem√≥ria",
      "title": "Memory Engine",
      "description": "Sistema de mem√≥ria hier√°rquico multi-tier (Hot/Warm/Cold) com compress√£o sem√¢ntica inteligente, compliance autom√°tico LGPD/HIPAA, e context injection para continuidade AI ‚Üî Humano.",
      "metrics": {
        "latency": "Lat√™ncia p99",
        "tokenReduction": "Redu√ß√£o de Tokens",
        "complianceRules": "Compliance Rules",
        "durability": "Durabilidade"
      },
      "problem": {
        "title": "O Problema",
        "intro": "Chatbots enterprise precisam de mem√≥ria de contexto. Quando um cliente retorna dias depois, o bot precisa lembrar conversas anteriores, prefer√™ncias e hist√≥rico de atendimentos.",
        "tokensCost": "Tokens s√£o caros",
        "tokensCostDesc": "Injetar todo o hist√≥rico no prompt explode os custos",
        "latencyKillsUx": "Lat√™ncia mata UX",
        "latencyKillsUxDesc": "Busca em banco relacional adiciona 200-500ms",
        "complianceMandatory": "Compliance obrigat√≥rio",
        "complianceMandatoryDesc": "LGPD, CFM, CFO t√™m regras r√≠gidas de reten√ß√£o",
        "handoverComplicates": "Handover complica",
        "handoverComplicatesDesc": "AI precisa saber o que aconteceu quando humano atendeu"
      },
      "solution": {
        "title": "A Solu√ß√£o",
        "hotWarmCold": {
          "title": "Arquitetura Hot/Warm/Cold",
          "intro": "Sistema de armazenamento em 3 tiers com estrat√©gia Write-Through:",
          "hot": "HOT",
          "hotDesc": "Redis ¬∑ TTL 1min",
          "hotLatency": "<10ms lat√™ncia",
          "warm": "WARM",
          "warmDesc": "Redis ¬∑ TTL 1h",
          "warmLatency": "<50ms lat√™ncia",
          "cold": "COLD",
          "coldDesc": "PostgreSQL",
          "coldLatency": "~100ms ¬∑ Permanente",
          "writeThrough": "Write-Through",
          "writeThroughDesc": "Toda escrita vai primeiro para PostgreSQL (durabilidade garantida), depois replica para Redis (performance)."
        },
        "customerFacts": {
          "title": "Customer Facts Temporais",
          "intro": "Em vez de armazenar conversas brutas, extra√≠mos fatos estruturados com janela de validade temporal:",
          "footer": "Hist√≥rico temporal completo para auditoria. Consulta O(1) para fatos atuais via √≠ndice parcial."
        },
        "semanticCompression": {
          "title": "Compress√£o Sem√¢ntica com LLM",
          "intro": "Conversas longas s√£o comprimidas usando OpenAI com templates verticais espec√≠ficos (dental, m√©dico, jur√≠dico):",
          "preserves": "Preserva",
          "preservesDesc": "Fatos cr√≠ticos, decis√µes, pr√≥ximos passos",
          "removes": "Remove",
          "removesDesc": "Sauda√ß√µes, confirma√ß√µes redundantes, detalhes operacionais",
          "result": "Resultado",
          "resultDesc": "90% redu√ß√£o com 100% preserva√ß√£o de informa√ß√£o relevante"
        },
        "compliance": {
          "title": "Compliance Autom√°tico",
          "intro": "Classifica√ß√£o e tratamento autom√°tico baseado no vertical:",
          "lgpd": "LGPD",
          "lgpdDesc": "Brasil",
          "hipaa": "HIPAA",
          "hipaaDesc": "EUA - Sa√∫de",
          "cfo": "CFO",
          "cfoDesc": "Odontologia",
          "cfm": "CFM",
          "cfmDesc": "Medicina",
          "oab": "OAB",
          "oabDesc": "Advocacia",
          "gdpr": "GDPR",
          "gdprDesc": "Europa",
          "footer": "Anonimiza√ß√£o inteligente: CPF -> ***.***.***.00 | Email -> ***{'@'}domain.com"
        },
        "handover": {
          "title": "Handover Summary",
          "intro": "Continuidade perfeita quando atendente humano interv√©m:",
          "step1": "Mensagens do operador ‚Üí Buffer Redis (hot path)",
          "step2": "Encerramento ‚Üí Celery worker gera resumo com OpenAI",
          "step3": "AI retoma ‚Üí Recebe resumo estruturado injetado no contexto"
        }
      },
      "architecture": {
        "title": "Arquitetura",
        "lastMsg": "√öltima msg",
        "activeSession": "Sess√£o Ativa",
        "completeHistory": "Hist√≥rico Completo",
        "writeThroughStrategy": "Write-Through Strategy",
        "sourceOfTruth": "(PostgreSQL = Source of Truth)",
        "contextComposer": "CONTEXT COMPOSER v2",
        "factsLogic": "Facts (L√≥gica)",
        "summaryLanguage": "Summary (Linguagem)",
        "recentChat": "Recent (Chat)",
        "lastMsgs": "[√∫ltimas 5 msgs]"
      },
      "decisions": {
        "title": "Decis√µes T√©cnicas",
        "writeThrough": {
          "question": "Por que Write-Through e n√£o Write-Behind?",
          "answer": "Write-Behind (async write to DB) √© mais perform√°tico mas arriscado. Em atendimento ao cliente, perder uma mensagem √© inaceit√°vel. Write-Through garante durabilidade imediata com performance aceit√°vel."
        },
        "schemaIsolation": {
          "question": "Por que schema isolation e n√£o row-level security?",
          "answer": "RLS adiciona overhead em cada query. Com schemas separados (t_{tenant_id}), o isolamento √© f√≠sico e a performance √© m√°xima. Trade-off: mais complexidade operacional."
        },
        "temporalFacts": {
          "question": "Por que Customer Facts temporais?",
          "answer": "LLMs s√£o p√©ssimos em \"esquecer\". Se o cliente mudou de prefer√™ncia, o modelo com hist√≥rico completo continuaria usando a prefer√™ncia antiga. Facts temporais com valid_at/invalid_at resolvem isso elegantemente."
        },
        "factsSummary": {
          "question": "Por que separar Facts vs Summary no Context Composer?",
          "answer": "Facts s√£o para l√≥gica (o sistema usa para tomar decis√µes). Summary √© para linguagem (o LLM usa para gerar respostas naturais). Essa separa√ß√£o evita que o LLM \"alucine\" sobre dados estruturados."
        }
      },
      "nextProject": "Pr√≥ximo: AI Conversation Engine ‚Üí"
    },
    "backend": {
      "badge": "Gateway Inteligente",
      "title": "Backend Orchestrator",
      "description": "Gateway enterprise multi-tenant com rate limiting distribu√≠do, circuit breaker, handover dual-mode (operator + AI-initiated), WebSocket real-time e fail-closed resilience.",
      "metrics": {
        "gatewayLatency": "Gateway Latency",
        "reqPerMinTenant": "Req/min/tenant",
        "retryStrategies": "Retry Strategies",
        "uptime": "Uptime"
      },
      "problem": {
        "title": "O Problema",
        "intro": "Em sistemas de atendimento multi-tenant, o gateway √© o ponto cr√≠tico de falha. Problemas comuns:",
        "noisyNeighbor": "Noisy Neighbor",
        "noisyNeighborDesc": "Um tenant com tr√°fego alto derruba todos os outros",
        "cascadingFailures": "Cascading Failures",
        "cascadingFailuresDesc": "AI Engine lento bloqueia todo o sistema",
        "handoverChaos": "Handover Chaos",
        "handoverChaosDesc": "AI responde quando humano est√° atendendo",
        "idempotencyBugs": "Idempotency Bugs",
        "idempotencyBugsDesc": "Mesma mensagem processada m√∫ltiplas vezes",
        "frontendDesync": "Frontend Desync",
        "frontendDesyncDesc": "UI n√£o reflete estado real das conversas"
      },
      "solution": {
        "title": "A Solu√ß√£o",
        "rateLimiting": {
          "title": "Enterprise Rate Limiting",
          "intro": "Sistema de rate limiting multi-camada com algoritmos adaptativos:",
          "slidingWindow": "Sliding Window",
          "slidingWindowDesc": "Precis√£o temporal com Redis ZSET",
          "tokenBucket": "Token Bucket",
          "tokenBucketDesc": "Burst handling com Lua scripts at√¥micos",
          "localFallback": "Local Fallback",
          "localFallbackDesc": "Cache local quando Redis indispon√≠vel",
          "tenantTiers": "Tenant Tiers",
          "tenantTiersDesc": "FREE (10 req/min) ‚Üí BASIC (50) ‚Üí PROFESSIONAL (200) ‚Üí ENTERPRISE (unlimited)"
        },
        "circuitBreaker": {
          "title": "Circuit Breaker Pattern",
          "intro": "Prote√ß√£o contra cascading failures com 3 estados:",
          "closed": "CLOSED",
          "open": "OPEN",
          "halfOpen": "HALF_OPEN",
          "failureThreshold": "failure_threshold",
          "failureThresholdDesc": "5 falhas consecutivas abrem o circuito",
          "recoveryTimeout": "recovery_timeout",
          "recoveryTimeoutDesc": "60s antes de testar novamente",
          "halfOpenMaxCalls": "half_open_max_calls",
          "halfOpenMaxCallsDesc": "10 requests de teste antes de fechar"
        },
        "handover": {
          "title": "Handover Dual-Mode",
          "intro": "Dois modos de transi√ß√£o AI ‚Üî Humano:",
          "operatorTakeover": "Operator Takeover",
          "operatorTakeoverList": [
            "Operador clica \"assumir conversa\"",
            "Redis latch bloqueia AI instantaneamente",
            "Timer auto-resume configur√°vel por tenant",
            "Lazy finalize: summary gerado ao retomar"
          ],
          "aiInitiated": "AI-Initiated",
          "aiInitiatedList": [
            "AI detecta problema (ERP failure, complexidade)",
            "Context injection com prioridade m√°xima",
            "Mensagem natural para cliente",
            "Hist√≥rico multi-handover preservado"
          ]
        },
        "failClosed": {
          "title": "Fail-Closed Resilience",
          "intro": "Quando Redis est√° indispon√≠vel, o sistema bloqueia AI (n√£o fica silencioso):",
          "comment": "# Fail-closed",
          "customerReceives": "# Cliente recebe: \"Um momento, estamos te transferindo...\"",
          "notSilent": "# N√ÉO: sil√™ncio total (fail-open)",
          "retryStrategy": "Retry Strategy",
          "retryStrategyDesc": "3 tentativas com exponential backoff (50ms base) + jitter aleat√≥rio"
        },
        "websocket": {
          "title": "WebSocket Real-Time",
          "intro": "Broadcasting de eventos para sincroniza√ß√£o frontend:",
          "conversationUpdate": "conversation_update",
          "conversationUpdateDesc": "Nova conversa ou mudan√ßa de status",
          "newMessage": "new_message",
          "newMessageDesc": "Mensagem cliente/AI normalizada",
          "operatorMessage": "operator_message",
          "operatorMessageDesc": "Mensagem do operador (WhatsApp/Web)",
          "cacheInvalidation": "cache_invalidation",
          "cacheInvalidationDesc": "Trigger de refetch no frontend"
        },
        "idempotency": {
          "title": "Idempotency Gate",
          "intro": "Prote√ß√£o contra processamento duplicado:",
          "step1": "Request chega com",
          "step2": "Check Redis: j√° processado? ‚Üí retorna cached response",
          "step3": "Slot reservado ‚Üí processa request",
          "step4": "Response cacheada com TTL de 24h"
        }
      },
      "architecture": {
        "title": "Arquitetura",
        "gatewayEnterprise": "(Gateway Enterprise)",
        "rateLimiter": "Rate Limiter",
        "multiTier": "(Multi-tier)",
        "circuitBreaker": "Circuit Breaker",
        "threeStates": "(3 states)",
        "handoverGate": "Handover Gate",
        "failClosed": "(Fail-closed)",
        "chatOrchestrator": "Chat Orchestrator",
        "idempotency": "+ Idempotency",
        "aiEngine": "AI Engine",
        "langGraph": "(LangGraph)",
        "memoryEngine": "Memory Engine",
        "postgresql": "(PostgreSQL)",
        "websocketBroadcast": "WebSocket Broadcast",
        "requestFlow": "Request Flow:",
        "step1": "1. Rate Limit Check (per-tenant tier)",
        "step2": "2. Circuit Breaker (protect downstream)",
        "step3": "3. Handover Gate (AI blocking)",
        "step4": "4. Idempotency Check (dedupe)",
        "step5": "5. AI Engine Call (with timeout)",
        "step6": "6. WebSocket Broadcast (real-time)",
        "step7": "7. Cache Response (24h TTL)"
      },
      "decisions": {
        "title": "Decis√µes T√©cnicas",
        "failClosed": {
          "question": "Por que fail-closed e n√£o fail-open?",
          "answer": "Em atendimento ao cliente, sil√™ncio √© pior que resposta de fallback. Fail-closed garante que o cliente sempre receba feedback (\"estamos te transferindo\") mesmo quando Redis est√° indispon√≠vel. Fail-open deixaria o cliente esperando indefinidamente."
        },
        "redisLatch": {
          "question": "Por que Redis latch e n√£o database flag?",
          "answer": "Redis latch com TTL autom√°tico elimina a necessidade de cleanup workers. Se o operador esquecer de \"devolver\" a conversa, o TTL expira e AI retoma automaticamente. Database flags precisariam de cron jobs para timeout."
        },
        "slidingWindow": {
          "question": "Por que sliding window e n√£o fixed window?",
          "answer": "Fixed window tem o problema de \"boundary burst\": 100 requests no segundo 59 + 100 no segundo 0 = 200 requests em 2 segundos. Sliding window distribui uniformemente e evita esse pico."
        },
        "luaScripts": {
          "question": "Por que Lua scripts para token bucket?",
          "answer": "Token bucket precisa de opera√ß√µes at√¥micas (read-modify-write). Sem Lua, ter√≠amos race conditions entre GET e SET. Lua scripts executam atomicamente no servidor Redis, garantindo consist√™ncia mesmo com milhares de requests concorrentes."
        }
      },
      "nextProject": "Pr√≥ximo: Memory Engine ‚Üí"
    },
    "rules": {
      "badge": "Optimus Platform",
      "badgeSecondary": "Business Intelligence",
      "title": "Rules Engine",
      "description": "Motor de regras Python-native que elimina o overhead interpretado do JSONLogic. Avalia√ß√£o em sub-millisegundo, regras criadas em runtime por tenant, type safety completo.",
      "tags": {
        "pythonLambda": "Python Lambda",
        "subMillisecond": "Sub-millisecond",
        "multiTenant": "Multi-tenant",
        "eventDriven": "Event-driven",
        "typeSafe": "Type Safe",
        "cacheCoherence": "Cache Coherence"
      },
      "problem": {
        "title": "O Problema: Por que JSONLogic n√£o escala",
        "jsonLogicTrap": "JSONLogic - A Armadilha",
        "simpleRule": "// Regra \"simples\" em JSONLogic",
        "issues": {
          "interpreted": "Interpretado recursivamente",
          "interpretedDesc": "cada operador √© uma chamada de fun√ß√£o aninhada",
          "limitedOps": "Operadores limitados",
          "limitedOpsDesc": "s√≥ suporta {'<'}, {'>'}, ==, in, and, or",
          "noTypeCheck": "Sem type checking",
          "noTypeCheckDesc": "erros s√≥ aparecem em runtime",
          "debugImpossible": "Debug imposs√≠vel",
          "debugImpossibleDesc": "stack traces incompreens√≠veis",
          "slowPerf": "~50-200ms",
          "slowPerfDesc": "para avaliar 100 regras complexas"
        },
        "pythonNativeSolution": "Python-Native - A Solu√ß√£o",
        "sameRule": "# Mesma regra em Python-native",
        "benefits": {
          "compiledOnce": "Compilado uma vez",
          "compiledOnceDesc": "bytecode Python nativo",
          "fullPower": "Full Python power",
          "fullPowerDesc": "regex, datetime, math, tudo",
          "typeHints": "Type hints + mypy",
          "typeHintsDesc": "erros antes do deploy",
          "normalDebug": "Debug normal",
          "normalDebugDesc": "pdb, breakpoints, stack traces",
          "fastPerf": "<0.5ms",
          "fastPerfDesc": "para avaliar 100 regras - 1000x mais r√°pido"
        },
        "benchmark": {
          "title": "Benchmark Real: JSONLogic vs Python-Native",
          "jsonLogic": "JSONLogic (100 regras)",
          "pythonNative": "Python-Native (100 regras)",
          "fasterCold": "Mais r√°pido (cold)",
          "fasterCached": "Mais r√°pido (cached)"
        }
      },
      "architecture": {
        "title": "Arquitetura: Rules Engine + Coordinator",
        "requestFlow": "Request Flow (sub-ms target)",
        "clientRequest": "Client Request",
        "backendOrchestrator": "Backend Orchestrator",
        "rulesCoordinator": "Rules Coordinator",
        "cacheFallback": "(Cache + Fallback)",
        "rulesEngine": "Rules Engine",
        "port": "(Port 8040)",
        "redisCache": "Redis Cache",
        "ttl15min": "(15 min)",
        "postgresql": "PostgreSQL",
        "rulesDb": "(Rules DB)",
        "fallbackHierarchy": "Fallback Hierarchy (never fails)",
        "primary": "1. Rules Engine API ‚Üí Primary (target <50ms)",
        "secondary": "2. Redis Cache      ‚Üí Secondary (target <5ms)",
        "basic": "3. Basic Fallback   ‚Üí Always available (keyword-based)",
        "components": {
          "rulesEngine": {
            "title": "Rules Engine",
            "desc": "Microsservi√ßo dedicado que compila e executa regras Python-native. Cada tenant tem suas pr√≥prias regras isoladas.",
            "items": [
              "Compila√ß√£o de lambdas Python",
              "Sandboxing de execu√ß√£o",
              "M√©tricas por regra",
              "Multi-vertical support"
            ]
          },
          "rulesCoordinator": {
            "title": "Rules Coordinator",
            "desc": "Proxy inteligente no Backend Orchestrator com cache, circuit breaker e fallback multi-tier.",
            "items": [
              "Cache de avalia√ß√µes (15min TTL)",
              "Memory context enrichment",
              "Circuit breaker protection",
              "Graceful degradation"
            ]
          },
          "contextEnrichment": {
            "title": "Context Enrichment",
            "desc": "Integra√ß√£o com Memory Engine para enriquecer fatos com contexto hist√≥rico do cliente.",
            "items": [
              "Frequ√™ncia de intera√ß√£o",
              "N√≠vel de urg√™ncia detectado",
              "Indicadores de dor/emerg√™ncia",
              "Padr√µes inteligentes"
            ]
          }
        }
      },
      "runtimeCreation": {
        "title": "Runtime Rule Creation: Cada Neg√≥cio √© √önico",
        "intro": "O grande diferencial do Rules Engine √© permitir que cada tenant crie suas pr√≥prias regras em tempo real, sem deploy, sem downtime, sem c√≥digo.",
        "apiTitle": "API de Cria√ß√£o de Regras",
        "examples": {
          "dental": {
            "title": "ü¶∑ Regra Dental",
            "desc": "Lembrete de limpeza baseado em √∫ltima visita + status do seguro. Se passou 6 meses e tem cobertura ‚Üí agenda preventiva."
          },
          "ecommerce": {
            "title": "üõí Regra E-commerce",
            "desc": "Carrinho abandonado h√° 2h + valor > R$200 + cliente recorrente ‚Üí oferta de 10% desconto + frete gr√°tis."
          },
          "legal": {
            "title": "‚öñÔ∏è Regra Legal",
            "desc": "Prazo processual em 48h + cliente n√£o respondeu √∫ltima mensagem ‚Üí alerta urgente + escala√ß√£o para advogado respons√°vel."
          }
        },
        "multiTenant": {
          "title": "üîí Isolamento Multi-tenant Completo",
          "clinic": {
            "name": "Cl√≠nica ABC",
            "rules": "47 regras ativas",
            "vertical": "Vertical: dental",
            "focus": "Foco: agendamento"
          },
          "store": {
            "name": "Loja XYZ",
            "rules": "89 regras ativas",
            "vertical": "Vertical: e-commerce",
            "focus": "Foco: convers√£o"
          },
          "law": {
            "name": "Advocacia 123",
            "rules": "23 regras ativas",
            "vertical": "Vertical: legal",
            "focus": "Foco: prazos"
          },
          "footer": "Cada tenant tem regras completamente isoladas. Nenhuma regra da Cl√≠nica ABC afeta a Loja XYZ. Zero vazamento de l√≥gica de neg√≥cio entre clientes."
        }
      },
      "deepDive": {
        "title": "Deep Dive: Como Funciona",
        "coordinator": {
          "title": "Rules Coordinator: Cache + Fallback Inteligente",
          "docstring": "üéØ Coordenador Central de Regras",
          "responsibilities": [
            "1. Proxy inteligente para Rules Engine com <50ms target",
            "2. Cache Redis para performance otimizada",
            "3. Integra√ß√£o com Memory Coordinator para contexto enriquecido",
            "4. Fallback quando Rules Engine falha",
            "5. Circuit breaker para prote√ß√£o contra falhas"
          ],
          "comment1": "# 1. üß† Enriquecer dados com Memory Coordinator",
          "comment2": "# 2. üéØ Tentar Rules Engine (primary)",
          "comment3": "# Cache para reuso futuro",
          "comment4": "# 3. üîÑ Fallback para Redis cache",
          "comment5": "# 4. üö® Basic fallback (keyword-based, nunca falha)",
          "responsibilities[0]": "1. Proxy inteligente para Rules Engine com &lt;50ms target",
          "responsibilities[1]": "2. Cache Redis para performance otimizada",
          "responsibilities[2]": "3. Integra√ß√£o com Memory Coordinator para contexto enriquecido",
          "responsibilities[3]": "4. Fallback quando Rules Engine falha",
          "responsibilities[4]": "5. Circuit breaker para prote√ß√£o contra falhas"
        },
        "enrichment": {
          "title": "Context Enrichment: Regras com Contexto Hist√≥rico",
          "docstring": "Extrai padr√µes inteligentes do contexto de mem√≥ria para regras mais sofisticadas",
          "comments": {
            "detectsUrgency": "# Detecta urg√™ncia (dor, emerg√™ncia, sangramento)",
            "detectsScheduling": "# Detecta necessidade de agendamento",
            "analyzesFrequency": "# Analisa frequ√™ncia de intera√ß√£o",
            "result": "# Resultado: regras podem usar facts enriquecidos"
          }
        },
        "eventTypes": {
          "title": "Event-Driven: Triggers Autom√°ticos",
          "messageReceived": "message_received",
          "messageReceivedDesc": "Nova mensagem do cliente",
          "conversationStarted": "conversation_started",
          "conversationStartedDesc": "In√≠cio de conversa",
          "handoverCompleted": "handover_completed",
          "handoverCompletedDesc": "Atendente finalizou",
          "appointmentScheduled": "appointment_scheduled",
          "appointmentScheduledDesc": "Agendamento confirmado",
          "cartAbandoned": "cart_abandoned",
          "cartAbandonedDesc": "Carrinho abandonado",
          "deadlineApproaching": "deadline_approaching",
          "deadlineApproachingDesc": "Prazo se aproximando",
          "sentimentNegative": "sentiment_negative",
          "sentimentNegativeDesc": "Cliente insatisfeito",
          "timeBased": "time_based",
          "timeBasedDesc": "Trigger por hor√°rio"
        }
      },
      "results": {
        "title": "Resultados: Regras que Escalam",
        "latencyP95": "Lat√™ncia P95",
        "latencyP95Desc": "Target de performance",
        "vsJsonLogic": "vs JSONLogic",
        "vsJsonLogicDesc": "Com cache aquecido",
        "rulesInProduction": "Regras em Produ√ß√£o",
        "rulesInProductionDesc": "Dental + E-commerce + Medical",
        "evaluationUptime": "Uptime Avalia√ß√£o",
        "evaluationUptimeDesc": "Fallback nunca falha",
        "decisions": {
          "title": "üí° Decis√µes T√©cnicas Chave",
          "pythonLambda": {
            "title": "Python Lambda vs DSL Customizada",
            "desc": "Consideramos criar uma DSL (Domain-Specific Language) para regras, mas decidimos usar Python lambda diretamente. Raz√£o: desenvolvedores j√° conhecem Python, debugging normal, type hints funcionam, ecosystem inteiro dispon√≠vel. O sandboxing √© feito via AST parsing + restricted builtins."
          },
          "cache15min": {
            "title": "Cache de 15 minutos (n√£o infinito)",
            "desc": "Regras s√£o cacheadas por 15 minutos, n√£o infinitamente. Isso permite que altera√ß√µes em regras (via API) sejam refletidas em tempo razo√°vel sem necessidade de invalida√ß√£o manual. O tradeoff entre performance e freshness foi calibrado em produ√ß√£o."
          },
          "keywordFallback": {
            "title": "Fallback Keyword-Based (Sempre Funciona)",
            "desc": "O √∫ltimo n√≠vel de fallback usa an√°lise simples de keywords. N√£o √© sofisticado, mas garante que o sistema NUNCA falha em avaliar uma mensagem. \"Dor\" ‚Üí urg√™ncia, \"agendar\" ‚Üí appointment. Simples, mas funcional como √∫ltimo recurso."
          },
          "separateMicroservice": {
            "title": "Microsservi√ßo Separado (n√£o library)",
            "desc": "Rules Engine √© um microsservi√ßo independente, n√£o uma library importada. Isso permite escalar horizontalmente, deploy independente, e isolamento de falhas. Se o Rules Engine crashar, o Coordinator usa cache/fallback."
          }
        }
      },
      "technicalStack": {
        "title": "Stack T√©cnico",
        "runtime": "Runtime",
        "runtimeDesc": "Python 3.11+ (bytecode optimized)",
        "framework": "Framework",
        "frameworkDesc": "FastAPI + Pydantic",
        "cache": "Cache",
        "cacheDesc": "Redis (cache + pub/sub)",
        "storage": "Storage",
        "storageDesc": "PostgreSQL (rules metadata)",
        "isolation": "Isolation",
        "isolationDesc": "Per-tenant rule namespaces",
        "circuitBreaker": "Circuit Breaker",
        "circuitBreakerDesc": "5 failures ‚Üí 60s recovery",
        "httpClient": "HTTP Client",
        "httpClientDesc": "HTTPX async pooling",
        "metrics": "Metrics",
        "metricsDesc": "Prometheus + per-rule tracking"
      },
      "cta": {
        "title": "Quer discutir mais sobre Rules Engines?",
        "desc": "JSONLogic vs Python-native, DSLs customizadas, ou como fazer regras escalarem - adoro falar sobre esses temas.",
        "contact": "Entrar em Contato"
      },
      "meta": {
        "title": "Rules Engine - Python-Native 1000x mais r√°pido que JSONLogic | Marcelo Marleta",
        "description": "Motor de regras Python-native que elimina JSONLogic. Avalia√ß√£o sub-millisecond, regras em runtime por tenant, type safety completo."
      }
    },
    "testTools": {
      "back": "Voltar",
      "platformName": "Optimus AI Platform",
      "badge": "Quality Assurance",
      "badgeSecondary": "AI Testing",
      "title": "AI Testing",
      "titleHighlight": "Tools",
      "description": "Suite completa de testes para AI conversacional: interface de simula√ß√£o multi-canal, detector de alucina√ß√µes, quality scorer multi-dimensional, e cen√°rios real√≠sticos com personalidades de cliente configur√°veis.",
      "metrics": {
        "analyzers": "Analyzers",
        "personalities": "Personalidades",
        "realtime": "Real-time",
        "multichannel": "Multi",
        "websocket": "WebSocket",
        "channel": "Channel"
      },
      "nav": {
        "problem": "Problema",
        "interface": "Interface",
        "hallucination": "Hallucination Detector",
        "quality": "Quality Scorer",
        "scenarios": "Cen√°rios",
        "runner": "Test Runner"
      },
      "problem": {
        "title": "O Problema",
        "description": "Testar sistemas de AI conversacional √© fundamentalmente diferente de testar software tradicional. Outputs s√£o probabil√≠sticos, contexto importa, e \"correto\" √© subjetivo.",
        "challengesTitle": "Desafios Espec√≠ficos de AI Testing",
        "challenges": {
          "hallucinations": "AI inventa informa√ß√µes que parecem plaus√≠veis mas s√£o falsas. Em contexto m√©dico/dental, isso √© perigoso.",
          "consistency": "Mesma pergunta pode gerar respostas diferentes. Como testar isso?",
          "multiTurn": "Resposta no turno 5 depende dos turnos 1-4. Testes isolados n√£o capturam isso.",
          "subjectivity": "\"Boa resposta\" depende de tom, empatia, completude ‚Äî m√©tricas dif√≠ceis de quantificar."
        },
        "solution": "A solu√ß√£o foi criar uma suite de ferramentas especializadas: interface de simula√ß√£o para testes manuais, analisadores autom√°ticos para detec√ß√£o de problemas, e um framework de cen√°rios real√≠sticos para testes de regress√£o."
      },
      "interface": {
        "title": "Interface de Simula√ß√£o",
        "description": "Interface web Flask + SocketIO para testes manuais interativos. Simula diferentes canais (WhatsApp, Web, API) com headers corretos, gerencia handover, e mostra m√©tricas em tempo real.",
        "features": {
          "channelProfiles": {
            "title": "Channel Profiles",
            "description": "WhatsApp, Web, API ‚Äî cada um com headers espec√≠ficos (X-Request-Source)."
          },
          "handover": {
            "title": "Handover Management",
            "description": "Takeover, Return to AI, Operator Messages ‚Äî testa fluxo completo."
          },
          "multiSession": {
            "title": "Multi-Session",
            "description": "M√∫ltiplas sess√µes simult√¢neas para simular carga."
          },
          "realtime": {
            "title": "Real-time",
            "description": "WebSocket para feedback instant√¢neo de respostas."
          }
        },
        "scenariosTitle": "Cen√°rios de Teste Embutidos"
      },
      "hallucination": {
        "title": "Hallucination Detector",
        "description": "Detecta alucina√ß√µes e erros factuais nas respostas. Cr√≠tico para contexto m√©dico/dental onde informa√ß√£o falsa pode causar danos reais.",
        "typesTitle": "Tipos de Alucina√ß√£o Detectados",
        "types": {
          "factualError": {
            "title": "factual_error",
            "description": "Informa√ß√£o contradiz fatos conhecidos (ex: \"limpeza custa R$5000\")."
          },
          "inventedInfo": {
            "title": "invented_info",
            "description": "AI inventa detalhes espec√≠ficos n√£o fornecidos (ex: nome do dentista)."
          },
          "impossibleClaim": {
            "title": "impossible_claim",
            "description": "Afirma√ß√µes logicamente imposs√≠veis (ex: \"consulta de 5 minutos\")."
          },
          "medicalMisinfo": {
            "title": "medical_misinformation",
            "description": "Informa√ß√£o m√©dica incorreta ou perigosa."
          }
        },
        "knowledgeBaseTitle": "Knowledge Base para Valida√ß√£o"
      },
      "quality": {
        "title": "Quality Scorer",
        "description": "Avalia qualidade das respostas em m√∫ltiplas dimens√µes. N√£o √© s√≥ \"certo ou errado\" ‚Äî √© legibilidade, relev√¢ncia, empatia, completude, tom.",
        "dimensionsTitle": "Dimens√µes de Qualidade",
        "dimensions": {
          "readability": "N√≠vel Flesch-Kincaid de leitura. Respostas devem ser acess√≠veis ao p√∫blico geral.",
          "empathy": "Detecta indicadores de empatia: \"entendo\", \"compreendo\", \"sinto muito\".",
          "callToAction": "Resposta leva a pr√≥ximos passos? \"agende\", \"ligue\", \"visite\".",
          "professionalLanguage": "Uso de termos profissionais: \"consulta\", \"tratamento\", \"procedimento\"."
        },
        "detractorsTitle": "Detratores de Qualidade (reduzem score)"
      },
      "scenarios": {
        "title": "Cen√°rios Real√≠sticos",
        "description": "Gera√ß√£o de cen√°rios de teste com diferentes n√≠veis de complexidade e personalidades de cliente. Permite testes sistem√°ticos de edge cases e regress√µes.",
        "validationsTitle": "Valida√ß√µes de Cen√°rio"
      },
      "runner": {
        "title": "Test Suite Runner",
        "description": "Orquestrador de testes com suporte a paraleliza√ß√£o, coverage, e relat√≥rios HTML. Integra com pytest e oferece CLI rica via Rich.",
        "markersTitle": "Custom Pytest Markers",
        "markers": {
          "slow": {
            "title": "{'@'}pytest.mark.slow",
            "description": "Testes lentos, pulados por padr√£o. Use --runslow para incluir."
          },
          "integration": {
            "title": "{'@'}pytest.mark.integration",
            "description": "Testes que precisam de servi√ßos rodando."
          },
          "aiQuality": {
            "title": "{'@'}pytest.mark.ai_quality",
            "description": "Testes de qualidade AI (alucina√ß√£o, quality score)."
          },
          "security": {
            "title": "{'@'}pytest.mark.security",
            "description": "Testes de seguran√ßa (SQL injection, XSS)."
          }
        }
      },
      "techStack": "Stack T√©cnico",
      "results": {
        "title": "Resultados",
        "metrics": {
          "analyzers": "Analisadores especializados",
          "coverage": "Cobertura de cen√°rios cr√≠ticos",
          "hallucinations": "Alucina√ß√µes em produ√ß√£o",
          "realtime": "Feedback via WebSocket"
        }
      },
      "cta": {
        "title": "Explore Outros Case Studies",
        "description": "Veja como outros componentes do Optimus foram constru√≠dos"
      },
      "footer": "Case Study: AI Testing Tools ‚Äî Optimus AI Platform",
      "meta": {
        "title": "AI Testing Tools - Optimus AI | Marcelo Marleta",
        "description": "Case study: Suite de testes para AI conversacional com detector de alucina√ß√µes, quality scorer, cen√°rios real√≠sticos e interface de simula√ß√£o multi-canal."
      }
    },
    "infraDevops": {
      "back": "Voltar",
      "platformName": "Optimus AI Platform",
      "badge": "Infrastructure & DevOps",
      "badgeSecondary": "Platform Engineering",
      "title": "Infrastructure &",
      "titleHighlight": "DevOps Pipeline",
      "description": "Arquitetura containerizada production-grade com scaling horizontal autom√°tico, alta disponibilidade via Redis Sentinel, e CI/CD com valida√ß√£o de arquitetura integrada. Da prototipa√ß√£o ao scaling de m√∫ltiplas inst√¢ncias sem downtime.",
      "metrics": {
        "microservices": "Microservi√ßos",
        "composeOverlays": "Compose Overlays",
        "sentinelsHa": "Sentinels HA",
        "workflowsCicd": "Workflows CI/CD"
      },
      "nav": {
        "problem": "Problema",
        "containers": "Containers",
        "scaling": "Scaling",
        "ha": "Alta Disponibilidade",
        "cicd": "CI/CD",
        "security": "Seguran√ßa",
        "operations": "Opera√ß√µes",
        "results": "Resultados"
      },
      "problem": {
        "title": "O Problema",
        "description": "Plataformas AI multi-tenant t√™m caracter√≠sticas √∫nicas que complicam infraestrutura tradicional: workloads altamente vari√°veis (um prompt pode levar 100ms ou 30s), depend√™ncia cr√≠tica de servi√ßos externos (LLMs, WhatsApp), e a necessidade de isolar tenants enquanto compartilha recursos eficientemente.",
        "challengesTitle": "Desafios Espec√≠ficos",
        "challenges": {
          "spikyTraffic": "Campanhas de marketing podem 10x o tr√°fego em minutos ‚Äî precisa escalar r√°pido e voltar sem desperdi√ßar recursos",
          "statefulServices": "Memory Engine e pgvector precisam de connection pools controlados ‚Äî n√£o √© s√≥ \"spawn more containers\" e pronto",
          "redisSPOF": "Cache, sessions, queues, rate limiting ‚Äî tudo passa pelo Redis. Precisa de HA real",
          "microservices": "Orquestrar deploys coordenados sem breaking changes entre servi√ßos de vers√µes diferentes",
          "secretsSprawl": "40+ API keys de LLMs, webhooks, databases ‚Äî precisam de rota√ß√£o sem downtime"
        },
        "solution": "A solu√ß√£o foi constru√≠da iterativamente: come√ßou com docker-compose monol√≠tico, evoluiu para overlays por ambiente, depois scaling horizontal com nginx LB, e finalmente Redis Sentinel para HA. Cada passo foi motivado por necessidades reais de produ√ß√£o."
      },
      "containers": {
        "title": "Arquitetura de Containers",
        "description": "Dockerfiles seguem padr√µes production-grade: multi-stage builds para imagens menores, usu√°rios non-root para seguran√ßa, BuildKit cache mounts para builds r√°pidos, e health checks que realmente testam a aplica√ß√£o (n√£o s√≥ se o processo existe).",
        "dockerfileTitle": "Production Patterns",
        "overlaysTitle": "Docker Compose Overlays",
        "overlaysDescription": "Em vez de um docker-compose.yml monol√≠tico, usamos overlays que comp√µem configura√ß√µes. Isso permite que desenvolvimento, staging e produ√ß√£o compartilhem a base mas customizem o que precisam ‚Äî sem duplica√ß√£o e sem drift acidental.",
        "overlays": {
          "base": "Base: todos os servi√ßos, volumes, networks. Configura√ß√£o comum que funciona em qualquer ambiente.",
          "scale": "Overlay: nginx-lb, job de migrations separado, portas removidas (tudo via LB), WEB_CONCURRENCY configur√°vel.",
          "sentinel": "Overlay: topologia Redis master/replica/sentinel para HA. Servi√ßos recebem vars REDIS_SENTINEL_*.",
          "dev": "Overlay: volumes de c√≥digo montados, debug habilitado, hot reload, portas expostas diretamente."
        },
        "compositionTitle": "Composi√ß√£o de Overlays",
        "resourceLimitsTitle": "Resource Limits & Reservations"
      },
      "scaling": {
        "title": "Scaling Horizontal",
        "description": "Sistema de scaling que vai de 1 a N inst√¢ncias sem mudan√ßa de c√≥digo. Load balancer nginx distribui tr√°fego, session affinity via Redis, e health checks determinam routing.",
        "nginxTitle": "Nginx Load Balancer",
        "scriptTitle": "Script de Scaling",
        "sessionAffinityTitle": "Session Affinity",
        "architectureTitle": "Arquitetura de Scaling",
        "externalTraffic": "External Traffic",
        "dynamicDns": "least_conn + dynamic DNS",
        "nginxLbTitle": "Nginx Load Balancer",
        "migrationJobTitle": "Migration Job Isolado",
        "migrationJobDescription": "Quando voc√™ escala servi√ßos, todos tentam rodar migrations ao iniciar ‚Äî race condition garantida. A solu√ß√£o foi um job dedicado que roda ANTES das replicas subirem, usando depends_on: condition: service_completed_successfully.",
        "scaleUpScriptTitle": "Scale-Up Script",
        "statefulConsiderations": {
          "title": "Considera√ß√µes Stateful",
          "description": "Memory Engine √© stateful ‚Äî mant√©m connection pools com PostgreSQL. Escalar de 2 para 6 replicas cria 6x mais conex√µes ao banco. Por isso configuramos DB_POOL_SIZE e DB_MAX_OVERFLOW via env vars, permitindo ajuste din√¢mico: DB_POOL_SIZE=5 DB_MAX_OVERFLOW=10 = m√°x 15 conex√µes/replica."
        }
      },
      "ha": {
        "title": "Alta Disponibilidade",
        "description": "Redis Sentinel para failover autom√°tico. Tr√™s sentinels monitoram o master e promovem replica automaticamente em caso de falha.",
        "topologyTitle": "Topologia Sentinel",
        "failoverTitle": "Failover Autom√°tico",
        "clientConfigTitle": "Configura√ß√£o do Cliente",
        "quorum": "quorum: 2 (2 de 3 precisam concordar)",
        "monitors": "monitora",
        "writes": "(writes)",
        "reads": "(reads)",
        "failoverSteps": {
          "step1": "Master fica inacess√≠vel (crash, network partition, ou qualquer falha)",
          "step2": "Sentinels detectam (configurable timeout, default 30s)",
          "step3": "Quorum de 2 sentinels concorda que master est√° down",
          "step4": "Elei√ß√£o de novo master entre replicas (baseia-se em replication offset)",
          "step5": "Sentinels atualizam configura√ß√£o; clientes reconectam automaticamente"
        },
        "whyThreeSentinels": {
          "title": "Por que 3 Sentinels?",
          "description": "Com quorum de 2, voc√™ precisa de no m√≠nimo 3 sentinels para tolerar 1 falha. Se tiver s√≥ 2 sentinels e 1 falhar, n√£o atinge quorum e failover n√£o acontece. N√∫mero √≠mpar evita split-brain (empate de votos)."
        }
      },
      "cicd": {
        "title": "CI/CD Pipeline",
        "description": "GitHub Actions com 12 workflows especializados. Cada PR passa por lint, type check, testes unit√°rios, e valida√ß√£o de arquitetura antes de merge.",
        "workflowsTitle": "Workflows Principais",
        "workflows": {
          "lint": "Lint & Format: black, isort, flake8, mypy",
          "test": "Testes: pytest com coverage m√≠nimo de 80%",
          "build": "Build: Docker multi-stage com cache",
          "deploy": "Deploy: Rolling update com health checks",
          "ci": {
            "title": "ci.yml",
            "description": "Ruff lint, mypy type-check, pytest, Docker build. Roda em todo push/PR."
          },
          "guardrails": {
            "title": "guardrails.yml",
            "description": "Valida√ß√£o de arquitetura. Bloqueia PRs que violam patterns definidos em policy.yaml."
          },
          "e2e": {
            "title": "e2e-tests.yml",
            "description": "Testes end-to-end com pgvector + Redis reais. Valida fluxos multi-ERP."
          },
          "llmEval": {
            "title": "llm-eval.yml",
            "description": "Avalia√ß√£o de qualidade de outputs do AI Engine. Detecta regress√µes em prompts."
          }
        },
        "archGuardsTitle": "Architecture Guards",
        "guardrailsTitle": "Architecture Guardrails",
        "guardrailsDescription": "O sistema de guardrails usa um MCP server que analisa diffs e valida contra regras. Se um PR viola um pattern (ex: import direto entre camadas, SQL raw em controllers), o workflow falha e posta um coment√°rio detalhado no PR.",
        "e2eTestsTitle": "E2E Tests com Services"
      },
      "security": {
        "title": "Seguran√ßa",
        "description": "M√∫ltiplas camadas de seguran√ßa: secrets management, network isolation, e scanning automatizado.",
        "secretsTitle": "Secrets Management",
        "networkTitle": "Network Isolation",
        "scanningTitle": "Scanning Automatizado",
        "secretsSeparationTitle": "Separa√ß√£o de Secrets",
        "secretsFiles": {
          "secrets": "API keys, passwords, tokens. Nunca commitado. Gitignore'd.",
          "models": "Configura√ß√µes de modelos LLM. Pode ser commitado (sem keys).",
          "example": "Template com placeholders. Commitado para documenta√ß√£o."
        },
        "containerSecurityTitle": "Container Security",
        "containerSecurity": {
          "nonRoot": "Todos os containers rodam como usu√°rio n√£o-root (appuser:1001 ou similar). Mitiga privilege escalation.",
          "slimImages": "python:3.12-slim em vez de full. Menos pacotes = menos superf√≠cie de ataque.",
          "readOnlyConfigs": "Arquivos de config montados como :ro (read-only). Containers n√£o podem modificar.",
          "networkIsolation": "Rede bridge dedicada (optimus). Services s√≥ acess√≠veis via LB.",
          "internalEngine": "Puerto 8050 no expuesto al host ‚Äî solo accesible internamente v√≠a nginx-lb."
        }
      },
      "operations": {
        "title": "Opera√ß√µes",
        "description": "Ferramentas de opera√ß√£o para gerenciar o ciclo de vida dos servi√ßos.",
        "backupTitle": "Backup & Restore",
        "logsTitle": "Log Aggregation",
        "monitoringTitle": "Monitoring",
        "scripts": {
          "scaleUp": {
            "title": "scale-up.sh",
            "description": "Scaling completo com build, migrations, e tail de logs."
          },
          "validateRedis": {
            "title": "validate_redis.sh",
            "description": "Health check de Redis: ping, memory, connected clients."
          },
          "loadTests": {
            "title": "run_load_tests.sh",
            "description": "Load testing com k6 ou locust. Gera relat√≥rio."
          },
          "traceSmokeTest": {
            "title": "trace_smoke_test.sh",
            "description": "Valida tracing E2E: gera trace, verifica no Tempo."
          }
        },
        "healthChecksTitle": "Health Checks √öteis"
      },
      "techStack": "Stack T√©cnico",
      "results": {
        "title": "Resultados",
        "metrics": {
          "uptime": "Uptime",
          "deployTime": "Deploy Time",
          "scalingTime": "Scaling Time",
          "mttr": "MTTR",
          "secretsExposed": "Secrets expostos (valida√ß√£o autom√°tica)",
          "failover": "Failover autom√°tico Redis"
        },
        "lessonsLearned": {
          "title": "Li√ß√µes Aprendidas",
          "overlays": "Compose overlays > monol√≠tico: Mantenimiento mucho m√°s f√°cil cuando cada concern est√° aislado",
          "migrations": "Migrations job separado: Evita race conditions y permite escalar r√©plicas libremente",
          "healthChecks": "Health checks reales: Probar el endpoint /health, no solo si el proceso existe",
          "dynamicDns": "DNS din√°mico en el LB: Sin eso, nginx no descubre nuevas r√©plicas",
          "sentinelQuorum": "Quorum impar en Sentinel: 3 sentinels con quorum 2 es el m√≠nimo para HA real"
        }
      },
      "cta": {
        "title": "Explore Outros Case Studies",
        "description": "Veja como outros componentes do Optimus foram constru√≠dos"
      },
      "footer": "Case Study: Infrastructure & DevOps ‚Äî Optimus AI Platform",
      "meta": {
        "title": "Infrastructure & DevOps - Optimus AI | Marcelo Marleta",
        "description": "Case study: Arquitetura containerizada com scaling horizontal, Redis Sentinel HA, e CI/CD com valida√ß√£o de arquitetura."
      }
    },
    "pricing": {
      "back": "‚Üê Voltar",
      "badge": "RAG + ML",
      "title": "Pricing Intelligence",
      "description": "Sistema de consulta de pre√ßos com RAG otimizado, threshold adaptativo, request coalescing e cache multi-tier para respostas sub-segundo.",
      "metrics": {
        "precision": "Precis√£o",
        "cacheHit": "Cache Hit",
        "cacheRate": "Cache Rate",
        "embeddingDim": "Embedding Dim"
      },
      "problem": {
        "title": "O Problema",
        "intro": "Consultas de pre√ßo em cl√≠nicas s√£o complexas: pacientes perguntam usando nomes diferentes (\"raio-x\", \"radiografia\", \"rx dental\"), com erros de digita√ß√£o, e esperam respostas instant√¢neas. RAG tradicional falha em:",
        "fuzzyMatching": "Matching fuzzy de nomes de procedimentos",
        "multipleItems": "M√∫ltiplos itens na mesma pergunta (\"quanto custa limpeza e clareamento?\")",
        "acceptableLatency": "Lat√™ncia aceit√°vel sob carga (thundering herd)"
      },
      "solution": {
        "title": "A Solu√ß√£o",
        "pricingFastLane": {
          "title": "Pricing Fast Lane",
          "description": "Bypass otimizado que detecta inten√ß√£o de pre√ßo e executa busca direta, sem passar pelo loop completo do agent:",
          "fastLaneComment": "# Fast Lane Flow",
          "normalFlowComment": "# vs Normal Flow"
        },
        "adaptiveThreshold": {
          "title": "Adaptive Threshold v2",
          "description": "Threshold de similaridade din√¢mico baseado nas caracter√≠sticas da query:",
          "shortQuery": "Query curta",
          "mediumQuery": "Query m√©dia",
          "longQuery": "Query longa",
          "shortQueryDesc": "(&lt;3 palavras): threshold mais baixo (0.75)",
          "numbersQuery": "Query com n√∫meros",
          "numbersQueryDesc": "threshold ajustado para abbreviations",
          "multiItemQuery": "Query multi-item",
          "multiItemQueryDesc": "threshold relaxado + diversifica√ß√£o",
          "llmOverride": "LLM override",
          "llmOverrideDesc": "modelo pode sugerir threshold espec√≠fico"
        },
        "requestCoalescing": {
          "title": "Request Coalescing",
          "description": "M√∫ltiplas requests para o mesmo procedimento s√£o agrupadas em uma √∫nica busca:",
          "intro": "Quando m√∫ltiplas requests chegam para a mesma query:",
          "step1": "Primeira request adquire lock e computa resultado",
          "step2": "Requests subsequentes aguardam (com timeout)",
          "step3": "Resultado √© compartilhado entre todas",
          "step4": "Cache √© populado para pr√≥ximas requests"
        }
      },
      "cacheArchitecture": {
        "title": "Arquitetura de Cache",
        "description": "Cache multi-tier com TTLs diferenciados por tipo de dado."
      },
      "intelligentCacheKey": {
        "title": "Cache Key Inteligente",
        "description": "Normaliza√ß√£o de queries para maximizar cache hits.",
        "intro": "En lugar de hash de la query bruta (que falla con variaciones), usamos",
        "semanticSignature": "firma sem√°ntica",
        "basedOnItems": "basada en los elementos detectados:",
        "traditional": "Cache Key Tradicional",
        "semantic": "Cache Key Sem√¢ntica"
      },
      "techStack": "Stack T√©cnico",
      "cta": {
        "title": "Explore Outros Case Studies",
        "description": "Veja como outros componentes do Optimus foram constru√≠dos"
      },
      "footer": "Case Study: Pricing Intelligence ‚Äî Optimus AI Platform",
      "meta": {
        "title": "Pricing Intelligence - Optimus AI | Marcelo Marleta",
        "description": "Case study: Sistema de consulta de pre√ßos com RAG otimizado, threshold adaptativo e cache multi-tier."
      },
      "nextProject": "Pr√≥ximo: Document Processing ‚Üí"
    },
    "llmPool": {
      "back": "‚Üê Voltar",
      "badge": "Cost Optimization",
      "title": "LLM Pool Management",
      "description": "Sistema de gest√£o de pools LLM com separa√ß√£o tool-calling vs chat, rota√ß√£o autom√°tica de keys, fallback inteligente e 40% de redu√ß√£o de custos com lat√™ncia otimizada.",
      "metrics": {
        "costReduction": "Redu√ß√£o de Custo",
        "latencyP95": "Lat√™ncia p95",
        "availability": "Disponibilidade",
        "simultaneousProviders": "Providers Simult√¢neos"
      },
      "problem": {
        "title": "O Problema",
        "intro": "Sistemas de AI conversacional enterprise enfrentam desafios cr√≠ticos de custo e lat√™ncia:",
        "explosiveCosts": "Custos explosivos",
        "explosiveCostsDesc": "GPT-4 para tudo √© caro. Nem toda tarefa precisa do modelo mais poderoso",
        "toolCallingExpensive": "Tool-calling √© caro",
        "toolCallingExpensiveDesc": "Modelos que suportam function calling custam mais que modelos simples",
        "rateLimits": "Rate limits",
        "rateLimitsDesc": "Uma √∫nica API key atinge limites rapidamente em produ√ß√£o",
        "vendorLockIn": "Vendor lock-in",
        "vendorLockInDesc": "Depend√™ncia de um √∫nico provider (OpenAI) √© arriscado",
        "keyManagement": "Gest√£o de keys",
        "keyManagementDesc": "API keys em c√≥digo ou env vars √© inseguro"
      },
      "solution": {
        "title": "A Solu√ß√£o",
        "poolArchitecture": {
          "title": "Arquitetura de Pools Separados",
          "intro": "Sistema de pools com separa√ß√£o expl√≠cita entre",
          "chatPool": "Chat Pool",
          "chatPoolOptimized": "Modelo otimizado para conversa√ß√£o",
          "chatPoolLowerCost": "Custo mais baixo (gpt-4o-mini)",
          "chatPoolHumanized": "Usado para respostas humanizadas",
          "toolsPool": "Tools Pool",
          "toolsPoolFunctionCalling": "Modelo com function calling",
          "toolsPoolHigherCost": "Custo mais alto (gpt-4o)",
          "toolsPoolOnlyWhenNeeded": "Usado s√≥ quando precisa chamar tools",
          "resultLabel": "Resultado",
          "chat": "chat",
          "chatDesc": "(conversaci√≥n)",
          "and": "y",
          "tools": "tools",
          "toolsDesc": "(function calling)",
          "resultText": "40% de reducci√≥n de costos usando un modelo barato para chat y un modelo premium solo para operaciones que realmente necesitan tool calling."
        },
        "keyGroups": {
          "title": "Key Groups",
          "description": "Agrupamento de API keys com rota√ß√£o autom√°tica e rate limiting distribu√≠do.",
          "intro": "Separa√ß√£o entre pools (configura√ß√£o de modelo) e key groups (vault de chaves):",
          "fernetEncryption": "Criptografia Fernet",
          "fernetEncryptionDesc": "Chaves armazenadas criptografadas em repouso",
          "fingerprint": "Fingerprint",
          "fingerprintDesc": "UI mostra apenas fingerprint (sk-...7f2a), nunca a chave completa",
          "autoValidation": "Valida√ß√£o autom√°tica",
          "autoValidationDesc": "Sistema valida chaves periodicamente e marca status",
          "pools": "pools",
          "poolsDesc": "(configuraci√≥n de modelo)",
          "and": "y",
          "keyGroupsLabel": "key groups",
          "keyGroupsDesc": "(vault de claves)"
        },
        "automaticSelection": {
          "title": "Sele√ß√£o Autom√°tica",
          "description": "Escolha inteligente de modelo baseada em tipo de tarefa, custo e disponibilidade.",
          "step1": "Request chega para pool",
          "step2": "Sistema busca key_group",
          "step3": "Filtra apenas chaves com",
          "step4": "Seleciona chave (round-robin ou random)",
          "step5": "Se rate limit ‚Üí marca cooldown ‚Üí tenta pr√≥xima chave"
        },
        "globalDefaults": {
          "title": "Defaults Globais",
          "description": "Configura√ß√£o centralizada com override por tenant."
        },
        "crossPoolFallback": {
          "title": "Fallback Cross-Pool",
          "description": "Se um pool falha, o sistema tenta automaticamente outro.",
          "exhausted": "Chat pool exausto (todas as chaves em rate limit)",
          "tryTools": "Tenta tools_pool (se suporta chat)",
          "tryGlobal": "Tenta global defaults",
          "success": "Request completa com lat√™ncia m√≠nima adicional",
          "quotaEnforcerLabel": "QuotaEnforcer",
          "quotaEnforcerText": "Tracked provider health com cooldown de 60s por chave."
        },
        "frontendIntegration": {
          "title": "Integra√ß√£o Frontend",
          "description": "Dashboard para monitoramento de custos e uso em tempo real.",
          "poolManagement": "Pool Management",
          "poolCrud": "CRUD de pools",
          "toggleTools": "Toggle <code>supports_tools</code>",
          "toggleActive": "Toggle <code>is_active</code>",
          "keyGroupSelection": "Sele√ß√£o de key_group",
          "keyManagement": "Key Management",
          "addRemoveKeys": "Adicionar/remover chaves",
          "revealVault": "Reveal com vault password",
          "batchValidation": "Valida√ß√£o em batch",
          "statusPerKey": "Status por chave (valid/invalid)"
        }
      },
      "architecture": {
        "title": "Arquitetura",
        "description": "Vis√£o geral do sistema de pools."
      },
      "decisions": {
        "title": "Decis√µes T√©cnicas",
        "separatePools": {
          "question": "Por que pools separados para chat vs tools?",
          "answer": "Modelos de tool-calling (GPT-4, Claude) custam 10-20x mais que modelos simples. Separar permite usar GPT-3.5 para conversa√ß√£o e reservar GPT-4 s√≥ para quando precisa chamar ferramentas."
        },
        "keyRotation": {
          "question": "Por que rota√ß√£o de keys?",
          "answer": "Rate limits s√£o por key. Com m√∫ltiplas keys rotacionando, o throughput efetivo multiplica. Tamb√©m permite revogar keys comprometidas sem downtime."
        },
        "vault": {
          "question": "Por que vault criptografado?",
          "answer": "API keys s√£o segredos cr√≠ticos. Armazenar em env vars ou c√≥digo √© vulner√°vel. Vault com encryption at-rest e audit logging √© enterprise-grade."
        },
        "fallback": {
          "question": "Por que fallback inteligente?",
          "answer": "Providers t√™m outages. Fallback autom√°tico para outro provider garante disponibilidade mesmo quando OpenAI est√° fora."
        }
      },
      "techStack": "Stack T√©cnico",
      "cta": {
        "title": "Explore Outros Case Studies",
        "description": "Veja como outros componentes do Optimus foram constru√≠dos"
      },
      "footer": "Case Study: LLM Pool Management ‚Äî Optimus AI Platform",
      "meta": {
        "title": "LLM Pool Management - Optimus AI | Marcelo Marleta",
        "description": "Case study: Sistema de gest√£o de pools LLM com separa√ß√£o tool-calling vs chat, rota√ß√£o de keys e 40% de redu√ß√£o de custos."
      },
      "technicalDecisions": {
        "title": "Decis√µes T√©cnicas",
        "whySeparate": "Por que separar pools e key groups?",
        "whySeparateAnswer": "Pools definem configura√ß√£o de modelo (model, temperature, supports_tools). Key groups definem credenciais (provider_type, base_url, keys). Essa separa√ß√£o permite reusar o mesmo vault de chaves em m√∫ltiplos pools com modelos diferentes.",
        "whyFailFast": "Por que fail-fast e n√£o fallback para env vars?",
        "whyFailFastAnswer": "Em produ√ß√£o, chaves em c√≥digo/env vars s√£o anti-pattern de seguran√ßa. Fail-fast for√ßa configura√ß√£o correta no sistema e evita \"funciona na minha m√°quina\" com chaves diferentes.",
        "whyCache60s": "Por que cache de 60s para provider configs?",
        "whyCache60sAnswer": "Balance entre consist√™ncia e performance. 60s √© suficiente para propagar mudan√ßas de configura√ß√£o sem bombardear Memory Engine a cada request. TTLCache com lock thread-safe.",
        "whyCooldown60s": "Por que QuotaEnforcer com cooldown de 60s?",
        "whyCooldown60sAnswer": "Rate limits de providers (OpenAI, Groq) tipicamente resetam em 60s. Cooldown evita retry storms que piorariam o rate limit. Cross-pool fallback garante continuidade."
      },
      "nextProject": "Pr√≥ximo: AI Conversation Engine ‚Üí"
    },
    "documentProcessing": {
      "tag": "Document AI",
      "title": "Document Processing Pipeline",
      "description": "Pipeline de processamento de documentos com detec√ß√£o autom√°tica de tabelas de pre√ßo, chunking estrat√©gico e gera√ß√£o autom√°tica de cat√°logos para RAG.",
      "stats": {
        "autoDetect": "Auto-detect Tables",
        "brokenChunks": "Broken Price Chunks",
        "indexUpdate": "Index Update",
        "multiTenant": "Tenant Isolated"
      },
      "problem": {
        "title": "O Problema",
        "intro": "Cl√≠nicas enviam tabelas de pre√ßo em formatos diversos (PDF, Excel, Word). Chunking tradicional quebra tabelas no meio, destruindo a rela√ß√£o entre procedimento e pre√ßo:",
        "brokenChunk": "‚ùå Chunk quebrado no meio da tabela:",
        "chunkEnd": "--- FIM DO CHUNK ---"
      },
      "solution": {
        "title": "A Solu√ß√£o",
        "docling": {
          "title": "Detec√ß√£o Autom√°tica de Tabelas (Docling)",
          "intro": "An√°lise estrutural do documento para identificar tabelas de pre√ßo vs texto corrido (FAQ, pol√≠ticas):",
          "layout": "Heur√≠sticas de layout (colunas, bordas, alinhamento)",
          "currency": "Detec√ß√£o de padr√µes monet√°rios (R$, $, ‚Ç¨)",
          "headers": "Headers t√≠picos (\"Procedimento\", \"Valor\", \"Pre√ßo\")"
        },
        "chunking": {
          "title": "Chunking Estrat√©gico",
          "intro": "Estrat√©gias diferentes para tipos de conte√∫do diferentes:",
          "tables": {
            "title": "üìä Tabelas de Pre√ßo TableRow Strategy: Cada linha da tabela vira um chunk at√¥mico. Nunca quebra no meio de um pre√ßo.",
            "desc": "<p class=\"text-gray-500 text-sm\">\n<strong class=\"text-white\">TableRow Strategy:</strong> Cada linha da tabela \nvira um chunk at√¥mico. Nunca quebra no meio de um pre√ßo."
          },
          "faq": {
            "title": "üìù FAQ / Pol√≠ticas Semantic Chunking: Chunks por par√°grafo ou se√ß√£o sem√¢ntica, com overlap para contexto.",
            "desc": "<p class=\"text-gray-500 text-sm\">\n<strong class=\"text-white\">Semantic Chunking:</strong> Chunks por par√°grafo \nou se√ß√£o sem√¢ntica, com overlap para contexto."
          }
        },
        "catalog": {
          "title": "Cat√°logo Autom√°tico",
          "intro": "Extra√ß√£o estruturada gera cat√°logo JSON pronto para busca:"
        }
      },
      "pipeline": {
        "title": "Pipeline de Processamento"
      },
      "hnsw": {
        "title": "HNSW Index Auto-Update",
        "intro": "√çndices HNSW s√£o atualizados automaticamente via Celery workers, garantindo que novos documentos estejam dispon√≠veis para busca em minutos:",
        "trigger": "Trigger: Carga de documento o schedule peri√≥dico",
        "rebuild": "Rebuild: Incremental cuando es posible, full rebuild si es necesario",
        "zeroDowntime": "Zero-downtime: Nuevo √≠ndice creado en paralelo, swap at√≥mico"
      },
      "stack": {
        "title": "Stack T√©cnica"
      },
      "cta": {
        "next": "Pr√≥ximo: MCP Servers ‚Üí"
      }
    }
  }
}
