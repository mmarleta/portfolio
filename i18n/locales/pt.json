{
  "nav": {
    "projects": "Projetos",
    "stack": "Stack",
    "about": "Sobre",
    "backToPortfolio": "Voltar ao Portfolio"
  },
  "hero": {
    "title": "Marcelo Marleta",
    "subtitle": "Senior Backend & AI Engineer",
    "description": "Arquiteturas de conversa√ß√£o enterprise com LangGraph, RAG otimizado e sistemas multi-tenant. Foco em separa√ß√£o de l√≥gica determin√≠stica e linguagem natural.",
    "github": "GitHub",
    "linkedin": "LinkedIn"
  },
  "projects": {
    "title": "Projetos",
    "description": "Sistemas de produ√ß√£o com foco em IA conversacional, processamento de documentos e ferramentas de desenvolvimento.",
    "optimusPlatform": "Optimus Platform",
    "otherProjects": "Outros Projetos",
    "viewMore": "Ver Todos os Projetos"
  },
  "stack": {
    "title": "Stack",
    "backend": "Backend",
    "ai": "AI/ML",
    "infra": "Infra"
  },
  "cta": {
    "wantToSeeMore": "Quer ver mais projetos?",
    "exploreOther": "Explore tamb√©m outros case studies no meu portfolio."
  },
  "common": {
    "fullStack": "Full-Stack Platform",
    "realTime": "Real-time",
    "multiPlatform": "Multi-Platform",
    "back": "‚Üê Voltar",
    "technicalStack": "Stack T√©cnica",
    "next": "Pr√≥ximo",
    "personalProject": "Projeto Pessoal",
    "exploreOtherProjects": "Explore Outros Projetos",
    "seeOtherSystems": "Veja outros sistemas que constru√≠",
    "viewAllProjects": "Ver Todos os Projetos"
  },
  "cards": {
    "aiEngine": {
      "title": "AI Conversation Engine",
      "description": "LangGraph + FSM para separa√ß√£o de l√≥gica determin√≠stica e linguagem natural. 20+ n√≥s especializados, 8 estados de booking."
    },
    "llmPool": {
      "title": "LLM Pool Management",
      "description": "Pools separados chat vs tools, key groups com vault criptografado, rota√ß√£o autom√°tica e fallback inteligente. 40% redu√ß√£o de custos."
    },
    "pricing": {
      "title": "Pricing Intelligence",
      "description": "RAG otimizado com threshold adaptativo, request coalescing e cache multi-tier. 95% precision, <100ms cache hit."
    },
    "memory": {
      "title": "Memory Engine",
      "description": "Sistema hier√°rquico Hot/Warm/Cold com compress√£o sem√¢ntica (90% redu√ß√£o), compliance LGPD/HIPAA autom√°tico e context injection."
    },
    "backend": {
      "title": "Backend Orchestrator",
      "description": "Central hub FastAPI com fail-closed design, tenant isolation, handover atendente, circuit breakers."
    },
    "rules": {
      "title": "Rules Engine",
      "description": "Python Lambda DSL para regras de neg√≥cio, fast-lane patterns, coordena√ß√£o backend + AI engine."
    },
    "whatsapp": {
      "title": "WhatsApp Integration",
      "description": "Redis isolado, webhook processing, WebSocket broadcaster, integra√ß√£o Memory Engine para hist√≥rico."
    },
    "audio": {
      "title": "Audio Processor",
      "description": "Multi-provider STT/TTS (Whisper, ElevenLabs, Azure), async processing com Celery, formatos diversos."
    },
    "observability": {
      "title": "Observability",
      "description": "Prometheus + OpenTelemetry + structlog. Distributed tracing, m√©tricas customizadas, dashboards."
    },
    "frontend": {
      "title": "Frontend Apps",
      "description": "Admin Dashboard (3000) + SuperAdmin Panel (3001). Vue.js 3, WebSocket real-time, handover management, RBAC."
    },
    "testTools": {
      "title": "AI Testing Tools",
      "description": "Hallucination detector, quality scorer, cen√°rios real√≠sticos com personalidades, interface de simula√ß√£o multi-canal."
    },
    "infraDevops": {
      "title": "Infra & DevOps",
      "description": "Docker Compose overlays, Nginx LB com scaling horizontal, Redis Sentinel HA, CI/CD com guardrails de arquitetura."
    },
    "architecture": {
      "title": "Arquitetura Completa",
      "description": "Vis√£o geral da plataforma: 4 microservi√ßos, multi-tenant, integra√ß√£o WhatsApp, Memory Engine hier√°rquico."
    },
    "mcp": {
      "title": "MCP Servers",
      "description": "Servidores Model Context Protocol para Claude Code. Debugging, valida√ß√£o arquitetural e navega√ß√£o de codebase."
    },
    "automark": {
      "title": "AutoMark Platform",
      "description": "SaaS multi-tenant de distribui√ß√£o de ofertas afiliadas. Shopee ‚Üí WhatsApp com anti-spam, scoring e dedupe."
    },
    "icontei": {
      "title": "iContei",
      "description": "Rede social de contadores compartilh√°veis. Next.js 16, FastAPI, WebSocket real-time, verifica√ß√£o por IA, rankings com Redis."
    },
    "gratidiem": {
      "title": "GratiDiem",
      "description": "App Flutter de gratid√£o com 508+ arquivos, 6 plataformas. Riverpod, dual persistence (Hive+Firebase), IA com Gemini."
    },
    "pvcoach": {
      "title": "PVCoach",
      "description": "Chess coach com Stockfish + LLM. MultiPV analysis, explica√ß√µes grounded, hints progressivos."
    },
    "feedRss": {
      "title": "Feed-RSS Monitor",
      "description": "Pipeline de automa√ß√£o de conte√∫do: RSS ‚Üí Filter ‚Üí OpenAI ‚Üí Telegram/Discord. Roteiros de Shorts gerados automaticamente."
    }
  },
  "cases": {
    "automark": {
      "meta": {
        "title": "AutoMark - Affiliate Marketing Platform | Marcelo Marleta",
        "description": "Case study: Plataforma SaaS multi-tenant de distribui√ß√£o inteligente de ofertas afiliadas. Shopee, WhatsApp, anti-spam, scoring inteligente."
      },
      "header": {
        "back": "Voltar",
        "projectType": "Projeto Pessoal"
      },
      "hero": {
        "tag1": "SaaS Platform",
        "tag2": "Affiliate Marketing",
        "title": "AutoMark",
        "titleHighlight": " Platform",
        "description": "Plataforma SaaS multi-tenant de distribui√ß√£o inteligente de ofertas afiliadas. Conecta marketplaces (Shopee, ML, Amazon) a canais (WhatsApp, Telegram) com automa√ß√µes anti-spam, scoring inteligente e deduplica√ß√£o.",
        "stat1Value": "Multi",
        "stat1Label": "Marketplace",
        "stat2Value": "Multi",
        "stat2Label": "Channel",
        "stat3Value": "48h",
        "stat3Label": "Dedupe Target",
        "stat4Value": "0",
        "stat4Label": "Spam/Ban"
      },
      "nav": {
        "problem": "Problema",
        "architecture": "Arquitetura",
        "providers": "Providers",
        "scoring": "Scoring",
        "dedupe": "Dedupe",
        "antiBan": "Anti-Ban",
        "automations": "Automa√ß√µes",
        "stack": "Stack"
      },
      "problem": {
        "title": "O Problema",
        "intro": "Afiliados enfrentam tr√™s problemas cr√≠ticos na distribui√ß√£o de ofertas:",
        "issue1Title": "Distribui√ß√£o manual n√£o escala:",
        "issue1Desc": "Postar links manualmente em grupos gera repeti√ß√£o, spam e ban. Tempo gasto vs convers√£o n√£o compensa.",
        "issue2Title": "Marketplaces s√£o fragmentados:",
        "issue2Desc": "Shopee, Mercado Livre, Amazon t√™m APIs diferentes, formatos diferentes, regras de afiliado diferentes.",
        "issue3Title": "WhatsApp pune comportamento rob√≥tico:",
        "issue3Desc": "Sem controle de cad√™ncia, dedupe e humaniza√ß√£o: shadow ban, bloqueio, queda de engajamento.",
        "objectiveTitle": "üéØ Objetivo",
        "objectiveDesc": "Criar uma plataforma que pare√ßa humana, poste o que converte, no lugar certo, na hora certa, sem spam."
      },
      "architecture": {
        "title": "Arquitetura Multi-Tenant",
        "intro": "A arquitetura segue princ√≠pios r√≠gidos que permitem evolu√ß√£o sem breaking changes:",
        "principle1Title": "Marketplace nunca hardcoded",
        "principle1Desc": "Shopee √© o primeiro conector, mas ML, Amazon, AliExpress s√£o plug-and-play.",
        "principle2Title": "Canal nunca hardcoded",
        "principle2Desc": "WhatsApp √© o primeiro, mas Telegram, Discord, Instagram seguem a mesma interface.",
        "principle3Title": "Automa√ß√£o gera Post, n√£o envia",
        "principle3Desc": "Separa√ß√£o de concerns: Automa√ß√£o decide O QUE, Dispatcher decide COMO.",
        "principle4Title": "Dedupe obrigat√≥rio",
        "principle4Desc": "Nenhum envio acontece sem passar pelo dedupe. Zero spam garantido.",
        "dataModelTitle": "Modelo de Dados",
        "rolesTitle": "Pap√©is e Permiss√µes",
        "superAdminTitle": "SuperAdmin (Plataforma)",
        "superAdminRole1": "Cria tenants",
        "superAdminRole2": "Define quais marketplaces existem",
        "superAdminRole3": "Controla feature flags",
        "superAdminRole4": "Observa sa√∫de global",
        "tenantAdminTitle": "Tenant Admin (Cliente)",
        "tenantAdminRole1": "Conecta canais (WhatsApp, Telegram)",
        "tenantAdminRole2": "Conecta afiliados (Shopee, ML)",
        "tenantAdminRole3": "Cria automa√ß√µes",
        "tenantAdminRole4": "V√™ hist√≥rico e m√©tricas"
      },
      "providers": {
        "title": "Provider Pattern",
        "intro": "Cada marketplace implementa uma interface comum. O provider n√£o sabe o que √© tenant ‚Äî tudo vem via tenant_connection. Isso permite adicionar novos marketplaces sem tocar no core.",
        "shopeeTitle": "Shopee Provider",
        "dedupeKeyTitle": "‚úì Dedupe Key",
        "dedupeKeyDesc": "O dedupe_key √© a identidade real do produto: shopee:123:456. Nunca usar t√≠tulo para dedupe ‚Äî varia√ß√µes de texto causariam spam."
      },
      "scoring": {
        "title": "Offer Scoring",
        "intro": "Nem toda oferta vale a pena postar. O sistema de scoring ranqueia ofertas por potencial de convers√£o, penalizando produtos suspeitos.",
        "formulaTitle": "F√≥rmula de Score",
        "weightsTitle": "Por que esses pesos?",
        "weight1Pct": "40%",
        "weight1Label": "Desconto:",
        "weight1Desc": "Principal driver de clique. Ofertas com desconto alto convertem mais.",
        "weight2Pct": "25%",
        "weight2Label": "Rating:",
        "weight2Desc": "Confian√ßa do produto. Rating baixo = devolu√ß√£o = comiss√£o cancelada.",
        "weight3Pct": "20%",
        "weight3Label": "Vendas:",
        "weight3Desc": "Prova social. Produto muito vendido tem valida√ß√£o de mercado.",
        "weight4Pct": "15%",
        "weight4Label": "Comiss√£o:",
        "weight4Desc": "Retorno para o afiliado. Mas comiss√£o alta demais √© red flag."
      },
      "dedupe": {
        "title": "Deduplica√ß√£o Anti-Spam",
        "intro": "O sistema de dedupe opera em dois escopos: por target (grupo espec√≠fico) e por channel (todos os grupos do canal). Isso previne spam tanto vertical quanto horizontal.",
        "targetScopeTitle": "Target Scope (48h)",
        "targetScopeDesc": "Mesmo produto n√£o pode ser enviado para o mesmo grupo em 48h. Evita repeti√ß√£o percebida pelos membros.",
        "channelScopeTitle": "Channel Scope (2-5min)",
        "channelScopeDesc": "Gap m√≠nimo entre qualquer envio para qualquer grupo. Evita burst que parece bot.",
        "cleanupTitle": "‚úì Cleanup Autom√°tico",
        "cleanupDesc": "Records expirados s√£o deletados periodicamente via cleanup_expired(). A tabela n√£o cresce indefinidamente."
      },
      "antiBan": {
        "title": "Anti-Ban (WhatsApp)",
        "intro": "WhatsApp detecta bots por padr√µes de envio. O sistema implementa m√∫ltiplas camadas de humaniza√ß√£o para evitar banimento:",
        "feature1Icon": "üñäÔ∏è",
        "feature1Title": "Typing Indicator:",
        "feature1Desc": "Antes de enviar, simula \"digitando...\" por 2-5 segundos (Evolution API).",
        "feature2Icon": "üé≤",
        "feature2Title": "Jitter Humano:",
        "feature2Desc": "Delay aleat√≥rio entre mensagens. Nunca intervalos exatos.",
        "feature3Icon": "üö¶",
        "feature3Title": "Rate Limit por Conta:",
        "feature3Desc": "Sem√°foro Redis limita msgs/minuto por n√∫mero. M√∫ltiplas contas = mais throughput.",
        "feature4Icon": "‚ö°",
        "feature4Title": "Circuit Breaker:",
        "feature4Desc": "Erro 429 ou 503 ‚Üí pausa autom√°tica de 30min para aquela conta.",
        "feature5Icon": "üåô",
        "feature5Title": "Quiet Hours:",
        "feature5Desc": "Configur√°vel por target: n√£o envia entre 23h-8h (ou custom)."
      },
      "automations": {
        "title": "Sistema de Automa√ß√µes",
        "intro": "Automa√ß√µes s√£o o cora√ß√£o do sistema. Definem O QUE buscar, ONDE enviar, e QUANDO executar.",
        "pipelineTitle": "Automation Pipeline",
        "typesTitle": "Tipos de Automa√ß√£o",
        "typeSearchTitle": "search",
        "typeSearchDesc": "Busca ativa no marketplace. Executa a cada intervalo configurado.",
        "typeFeedTitle": "feed",
        "typeFeedDesc": "Usa ofertas j√° no banco (ingest√£o externa). Aplica ranking e distribui.",
        "typeMonitorTitle": "monitor",
        "typeMonitorDesc": "Monitora pre√ßo de produtos espec√≠ficos. Alerta quando desconto atinge threshold.",
        "targetTitle": "AutomationTarget (Limites)",
        "targetConfigTitle": "Configura√ß√£o por Grupo"
      },
      "stack": {
        "title": "Stack T√©cnico",
        "backendTitle": "Backend",
        "frontendTitle": "Frontend",
        "integrationsTitle": "Integra√ß√µes",
        "infraTitle": "Infra"
      },
      "results": {
        "title": "Resultados",
        "stat1Value": "0",
        "stat1Label": "Bans de conta WhatsApp",
        "stat2Value": "100%",
        "stat2Label": "Dedupe coverage (zero spam)",
        "stat3Value": "Plug",
        "stat3Label": "& Play para novos marketplaces",
        "stat4Value": "Multi",
        "stat4Label": "Tenant desde o dia 1"
      },
      "cta": {
        "title": "Explore Outros Projetos",
        "description": "Veja outros sistemas que constru√≠"
      },
      "footer": {
        "caseStudy": "Case Study: AutoMark Platform ‚Äî Affiliate Marketing Automation"
      }
    },
    "icontei": {
      "meta": {
        "title": "iContei - Rede Social de Contadores | Marcelo Marleta",
        "description": "Case study: Plataforma full-stack de contadores compartilh√°veis com Next.js 16, FastAPI, WebSocket real-time, e verifica√ß√£o por IA."
      },
      "hero": {
        "tag1": "Full-Stack Platform",
        "tag2": "Social Network",
        "tag3": "Real-time",
        "title": "iContei",
        "description": "Rede social de contadores compartilh√°veis ‚Äî desde estat√≠sticas esportivas virais at√© marcos pessoais. Plataforma full-stack com Next.js 16, FastAPI, WebSockets, e verifica√ß√£o por IA."
      },
      "overview": {
        "title": "Vis√£o Geral",
        "productTitle": "O Produto",
        "productDesc1": "iContei √© uma plataforma social dedicada a contadores de todos os tipos ‚Äî desde estat√≠sticas esportivas virais (\"H√° 2.847 dias o Flamengo est√° sem t√≠tulo mundial\") at√© marcos pessoais (\"Faltam 127 dias para meu casamento\") e corporativos (\"1.567 dias sem acidentes de trabalho\").",
        "productDesc2": "O foco √© criar contadores visualmente impactantes para compartilhamento em redes sociais (TikTok, Instagram, Twitter) com previews din√¢micos, atualiza√ß√£o em tempo real, e comunidade engajada.",
        "useCasesTitle": "Casos de Uso",
        "publicTitle": "üìä P√∫blicos (Virais)",
        "publicExample1": "\"H√° 2.847 dias o Flamengo est√° sem t√≠tulo mundial\"",
        "publicExample2": "\"Faltam 180 dias para a Copa do Mundo 2026\"",
        "publicExample3": "\"Real Madrid h√° 45 dias sem perder no Bernab√©u\"",
        "personalTitle": "üíë Pessoais",
        "personalExample1": "\"Faltam 127 dias para meu casamento\"",
        "personalExample2": "\"H√° 1.234 dias que nos conhecemos\"",
        "corporateTitle": "üè¢ Corporativos",
        "corporateExample1": "\"1.567 dias sem acidentes de trabalho\"",
        "corporateExample2": "\"890 dias como l√≠der de mercado\""
      },
      "architecture": {
        "title": "Arquitetura Full-Stack",
        "frontendStackTitle": "Frontend Stack",
        "backendStackTitle": "Backend Stack"
      },
      "realtime": {
        "title": "Sistema Real-time",
        "description": "Contadores atualizam a cada segundo no frontend. Para suportar milhares de conex√µes simult√¢neas, implementei um sistema de WebSocket com Redis pub/sub, heartbeat, e rate limiting inteligente.",
        "websocketTitle": "WebSocket Manager",
        "websocketDesc": "Rate limiting dual: por usu√°rio autenticado (5 conex√µes) e por IP para an√¥nimos (20 conex√µes, considerando NAT/CGNAT). Heartbeat via Redis Sorted Set para detectar conex√µes mortas.",
        "pubsubTitle": "Redis Pub/Sub Distribution",
        "pubsubDesc": "Com Redis pub/sub, posso escalar horizontalmente o backend ‚Äî cada inst√¢ncia mant√©m suas conex√µes WebSocket e recebe atualiza√ß√µes via Redis.",
        "presenceTitle": "Sistema de Presen√ßa",
        "presenceStat1Value": "30s",
        "presenceStat1Label": "Heartbeat interval",
        "presenceStat2Value": "45s",
        "presenceStat2Label": "Presence timeout",
        "presenceStat3Value": "ZADD",
        "presenceStat3Label": "Redis Sorted Set",
        "presenceDesc": "Cliente envia heartbeat a cada 30s. Servidor usa ZRANGEBYSCORE para listar conex√µes ativas (timestamp > now - 45s). Conex√µes stale s√£o removidas automaticamente."
      },
      "aiVerification": {
        "title": "Verifica√ß√£o por IA",
        "description": "Contadores oficiais passam por verifica√ß√£o automatizada com IA para garantir que datas e informa√ß√µes est√£o corretas. Sistema multi-provider com fallback.",
        "serviceTitle": "AI Verification Service",
        "pipelineTitle": "Pipeline Brave Search + Groq",
        "pipelineDesc": "Para contadores que precisam de dados externos (ex: \"√∫ltima vit√≥ria do time X\"), uso Brave Search para buscar informa√ß√µes recentes e Groq para extrair dados estruturados."
      },
      "rankings": {
        "title": "Sistema de Rankings",
        "description": "Rankings em tempo real usando Redis Sorted Sets com algoritmo de scoring 60/30/10 que balanceia likes, coment√°rios e visualiza√ß√µes.",
        "algorithmTitle": "Algoritmo de Scoring",
        "redisTitle": "Redis Sorted Sets",
        "redisDesc": "ZADD para inserir, ZREVRANGE para buscar top N, ZREMRANGEBYRANK para manter tamanho controlado. O(log N) para todas as opera√ß√µes."
      },
      "automation": {
        "title": "Sistema de Automa√ß√£o",
        "description": "Contadores podem ser atualizados automaticamente via regras configur√°veis ‚Äî desde agendamentos cron at√© triggers baseados em APIs externas.",
        "scheduledTitle": "Scheduled",
        "scheduledDesc": "Cron expressions para atualiza√ß√£o peri√≥dica. Usa croniter para calcular pr√≥xima execu√ß√£o.",
        "apiTriggerTitle": "API Trigger",
        "apiTriggerDesc": "Integra√ß√£o com APIs externas (API-Football, etc.) para buscar dados automaticamente.",
        "crowdsourcedTitle": "Crowdsourced",
        "crowdsourcedDesc": "Usu√°rios podem sugerir atualiza√ß√µes que passam por aprova√ß√£o antes de serem aplicadas.",
        "sportsProviderTitle": "Sports API Provider",
        "sportsProviderDesc": "Provider Pattern permite adicionar novas fontes de dados facilmente. Cada provider implementa fetch_data() e retorna resposta padronizada."
      },
      "observability": {
        "title": "Observabilidade",
        "description": "Stack completa de observabilidade para monitorar a plataforma em produ√ß√£o.",
        "prometheusTitle": "Prometheus + Metrics",
        "otelTitle": "OpenTelemetry",
        "loggingTitle": "Structured Logging"
      },
      "testing": {
        "title": "Testes Automatizados",
        "description": "Cobertura completa com pytest (backend) e vitest + Playwright (frontend).",
        "backendTitle": "Backend (pytest)",
        "backendTestCount": "267",
        "backendTestLabel": "testes",
        "backendStatus": "‚úì",
        "backendStatusLabel": "passando",
        "frontendTitle": "Frontend (vitest + Playwright)",
        "frontendUnitCount": "21",
        "frontendUnitLabel": "unit tests",
        "frontendE2E": "E2E",
        "frontendE2ELabel": "Playwright"
      },
      "workers": {
        "title": "Background Workers",
        "description": "Processamento ass√≠ncrono para tarefas pesadas, mantendo a API responsiva.",
        "schedulerTitle": "Automation Scheduler",
        "schedulerDesc": "Executa regras de automa√ß√£o a cada 5 minutos. Calcula pr√≥ximo run com croniter.",
        "rankingTitle": "Ranking Worker",
        "rankingDesc": "Atualiza Redis Sorted Sets com scores calculados para cada per√≠odo (24h, 7d, 30d, all).",
        "reviewTitle": "Review Worker",
        "reviewDesc": "Processa filas de verifica√ß√£o de contadores, coordena com AI Verification Service.",
        "monitoringTitle": "AI Monitoring",
        "monitoringDesc": "Monitora contadores marcados para verifica√ß√£o cont√≠nua, atualiza quando dados mudam."
      },
      "roadmap": {
        "title": "Roadmap",
        "phase1Title": "Fase 1 - MVP ‚úÖ",
        "phase1Item1": "‚úì CRUD de contadores",
        "phase1Item2": "‚úì Sistema de temas",
        "phase1Item3": "‚úì Rankings (Trending)",
        "phase1Item4": "‚úì OG images din√¢micas",
        "phase1Item5": "‚úì Autentica√ß√£o",
        "phase1Item6": "‚úì Seguir + rea√ß√µes",
        "phase2Title": "Fase 2 - Social",
        "phase2Item1": "Feed personalizado",
        "phase2Item2": "Coment√°rios e discuss√µes",
        "phase2Item3": "Notifica√ß√µes push",
        "phase2Item4": "Badges e gamifica√ß√£o",
        "phase2Item5": "Perfis p√∫blicos robustos",
        "phase3Title": "Fase 3 - Empresas",
        "phase3Item1": "Perfis corporativos",
        "phase3Item2": "Multi-usu√°rio por org",
        "phase3Item3": "Dashboards analytics",
        "phase3Item4": "SSO corporativo",
        "phase3Item5": "Temas licenciados",
        "phase4Title": "Fase 4 - Creators",
        "phase4Item1": "Gera√ß√£o de v√≠deos (Remotion)",
        "phase4Item2": "SDK para redes sociais",
        "phase4Item3": "API p√∫blica",
        "phase4Item4": "Widgets embeddable",
        "phase4Item5": "Marketplace de templates"
      },
      "stackSection": {
        "title": "Stack Completa"
      },
      "cta": {
        "title": "Quer ver mais projetos?",
        "description": "Este √© um dos meus projetos pessoais. Explore tamb√©m o Optimus (plataforma de IA conversacional) e outros case studies no meu portfolio."
      }
    },
    "gratidiem": {
      "meta": {
        "title": "GratiDiem - App de Gratid√£o Flutter | Marcelo Marleta",
        "description": "Case study: App Flutter multi-plataforma de gratid√£o com Clean Architecture, Riverpod, Firebase, IA integrada com Gemini, e sistema de monetiza√ß√£o √©tica."
      },
      "hero": {
        "tag1": "Flutter App",
        "tag2": "Multi-Platform",
        "tag3": "Firebase",
        "title": "GratiDiem",
        "description": "Aplicativo de gratid√£o e bem-estar com 508+ arquivos Dart, 35+ telas, 86+ servi√ßos. Clean Architecture com Riverpod, dual persistence (Hive + Firebase), IA integrada com Gemini, e sistema de monetiza√ß√£o √©tica gamificado."
      },
      "overview": {
        "title": "Vis√£o Geral",
        "productTitle": "O Produto",
        "productDesc1": "GratiDiem √© um companheiro di√°rio de gratid√£o ‚Äî um aplicativo sofisticado que ajuda usu√°rios a cultivar bem-estar atrav√©s de pr√°ticas de gratid√£o, medita√ß√£o guiada, desafios di√°rios, e comunidade.",
        "productDesc2": "O app suporta 6 plataformas (Android, iOS, Web, macOS, Windows, Linux), 3 idiomas (PT, EN, ES), e √© constru√≠do para escalar para milh√µes de usu√°rios.",
        "metricsTitle": "M√©tricas do Codebase",
        "metricFilesValue": "508+",
        "metricFilesLabel": "Arquivos Dart",
        "metricScreensValue": "35+",
        "metricScreensLabel": "Telas",
        "metricServicesValue": "86+",
        "metricServicesLabel": "Services",
        "metricModelsValue": "126+",
        "metricModelsLabel": "Models"
      },
      "architecture": {
        "title": "Arquitetura Clean + Riverpod",
        "presentationTitle": "Presentation",
        "presentationDesc": "278+ arquivos, Material Design 3, responsive design, ConsumerWidget/ConsumerStatefulWidget",
        "stateTitle": "State Management",
        "stateDesc": "Riverpod com AsyncNotifier/StateNotifier, stream subscriptions, real-time updates",
        "businessTitle": "Business Logic",
        "businessDesc": "Singleton services + Repository pattern, 113 arquivos com responsabilidades claras",
        "dataTitle": "Data Layer",
        "dataDesc": "Dual persistence: Hive CE (local-first) + Firebase Firestore (cloud sync)"
      },
      "features": {
        "title": "Features do App",
        "gratitudeTitle": "üôè Gratitude Journal",
        "gratitudeDesc": "Di√°rio de gratid√£o com entradas di√°rias, categorias, tags, e busca full-text. Suporte a imagens e compartilhamento social.",
        "meditationTitle": "üßò Medita√ß√£o Guiada",
        "meditationDesc": "Player de √°udio com sess√µes de medita√ß√£o (manh√£, dia, ansiedade, noite, profunda). Just Audio + Audio Session para background playback.",
        "circlesTitle": "‚≠ï C√≠rculos (Tribos)",
        "circlesDesc": "Comunidades sociais com rituais em grupo, posts, desafios colaborativos, gamifica√ß√£o, e sync real-time via Firestore.",
        "challengesTitle": "üèÜ Challenges & Progression",
        "challengesDesc": "Desafios di√°rios, streaks, sistema de n√≠veis, √°rvore de progress√£o, achievements, e surprise rewards.",
        "nightRitualTitle": "üåô Night Ritual",
        "nightRitualDesc": "Ritual noturno guiado com medita√ß√£o, reflex√£o, inten√ß√µes para o pr√≥ximo dia. Scheduling com notifica√ß√µes locais.",
        "adversityTitle": "üíä Adversity Support",
        "adversityDesc": "M√≥dulo de sa√∫de mental com jornada de adversidade, pr√°ticas terap√™uticas, hist√≥rias inspiradoras, recursos de emerg√™ncia.",
        "timeCapsuleTitle": "‚è≥ Time Capsule",
        "timeCapsuleDesc": "C√°psulas do tempo para guardar mem√≥rias e gratid√µes a serem abertas no futuro.",
        "valuesTitle": "üéØ Values & Goals",
        "valuesDesc": "Defini√ß√£o de valores pessoais, visualiza√ß√£o de metas, reviews peri√≥dicos.",
        "analyticsTitle": "üìä Wellbeing Analytics",
        "analyticsDesc": "Assessments de bem-estar, gr√°ficos de humor (fl_chart), calend√°rio de atividades (table_calendar)."
      },
      "ai": {
        "title": "Integra√ß√£o com IA",
        "description": "Motor de IA multi-backend com Google Gemini, Hugging Face, e modelos on-device (TensorFlow Lite).",
        "engineTitle": "AI Engine",
        "capabilitiesTitle": "Capacidades de IA",
        "sentimentTitle": "An√°lise de Sentimentos",
        "sentimentDesc": "Detecta emo√ß√µes nas entradas de gratid√£o com cache para performance",
        "themesTitle": "Detec√ß√£o de Temas",
        "themesDesc": "Categoriza automaticamente entradas (fam√≠lia, trabalho, sa√∫de, etc.)",
        "responsesTitle": "Respostas Personalizadas",
        "responsesDesc": "Gera reflex√µes e sugest√µes baseadas no hist√≥rico do usu√°rio",
        "premiumTitle": "AI Premium Service",
        "premiumDesc": "Features avan√ßadas para usu√°rios premium com Gemini Pro",
        "aiAnalyticsTitle": "AI Analytics",
        "aiAnalyticsDesc": "Insights e tend√™ncias derivados das pr√°ticas de gratid√£o"
      },
      "monetization": {
        "title": "Sistema de Monetiza√ß√£o √âtica",
        "description": "Transformando an√∫ncios em \"momentos de gratid√£o\" ‚Äî monetiza√ß√£o integrada ao conceito do app, criando experi√™ncia significativa ao inv√©s de intrusiva.",
        "appealsTitle": "üôè Apelos Contextuais",
        "appealsDesc": "Mensagens de gratid√£o personalizadas baseadas no contexto do usu√°rio.",
        "appealsExample1": "P√≥s-Ritual: \"Se este app te ajudou...\"",
        "appealsExample2": "Streak: \"7 dias de gratid√£o! Retribua...\"",
        "appealsExample3": "Alta Energia: \"Sinta essa vibra√ß√£o positiva?\"",
        "appealsExample4": "Conquistas: \"Conquista desbloqueada!\"",
        "tokensTitle": "üéÆ Economia de Tokens",
        "tokensDesc": "Sistema gamificado com tokens que podem ser ganhos e usados no app.",
        "tokensExample1": "Daily bonus com multiplicadores",
        "tokensExample2": "Streak multipliers",
        "tokensExample3": "Achievement rewards",
        "tokensExample4": "Challenge completion",
        "remoteConfigTitle": "üìä Firebase Remote Config",
        "remoteConfigDesc": "Controle din√¢mico de toda a monetiza√ß√£o sem deploy.",
        "remoteConfigExample1": "Frequ√™ncia de an√∫ncios",
        "remoteConfigExample2": "Cooldown periods",
        "remoteConfigExample3": "A/B testing de mensagens",
        "remoteConfigExample4": "M√©tricas de convers√£o",
        "triggersTitle": "Gratitude Triggers Service"
      },
      "firebase": {
        "title": "Firebase Full Stack",
        "authTitle": "üîê Authentication",
        "storageTitle": "üì¶ Storage",
        "analyticsTitle": "üìä Analytics",
        "messagingTitle": "üîî Messaging"
      },
      "persistence": {
        "title": "Dual Persistence: Local-First",
        "description": "Arquitetura local-first com Hive CE para performance e offline, sincronizando automaticamente com Firebase Firestore.",
        "hiveTitle": "Hive CE (Local)",
        "hiveDesc": "197 TypeIDs registrados, c√≥digo gerado via build_runner, adapter registry centralizado.",
        "syncTitle": "Sync Strategy",
        "syncDesc": "Last-write-wins com detec√ß√£o de conflitos, queue de retry para offline, recovery service para reconex√£o."
      },
      "navigation": {
        "title": "Navega√ß√£o com GoRouter",
        "description": "100+ rotas declarativas com GoRouter, deep linking, redirect guards, e par√¢metros tipados."
      },
      "i18n": {
        "title": "Internacionaliza√ß√£o",
        "portuguese": "Portugu√™s",
        "portugueseDesc": "Idioma base (app_pt.arb)",
        "english": "English",
        "englishDesc": "app_en.arb",
        "spanish": "Espa√±ol",
        "spanishDesc": "app_es.arb",
        "summary": "200+ strings traduzidas usando ARB format (Application Resource Bundle), gera√ß√£o autom√°tica via flutter gen-l10n, script Python para tradu√ß√£o em lote."
      },
      "platforms": {
        "title": "6 Plataformas Suportadas",
        "android": "Android",
        "ios": "iOS",
        "web": "Web",
        "macos": "macOS",
        "windows": "Windows",
        "linux": "Linux"
      },
      "testing": {
        "title": "Testing & Quality",
        "unitTitle": "Unit Tests",
        "widgetTitle": "Widget Tests",
        "integrationTitle": "Integration Tests",
        "qualityTitle": "Code Quality"
      },
      "stackSection": {
        "title": "Stack Completa"
      },
      "cta": {
        "title": "Quer ver mais projetos?",
        "description": "Este √© um dos meus projetos pessoais mais completos em Flutter. Explore tamb√©m o iContei (rede social de contadores) e os projetos do Optimus."
      }
    },
    "memory": {
      "badge": "Sistema de Mem√≥ria",
      "title": "Memory Engine",
      "description": "Sistema de mem√≥ria hier√°rquico multi-tier (Hot/Warm/Cold) com compress√£o sem√¢ntica inteligente, compliance autom√°tico LGPD/HIPAA, e context injection para continuidade AI ‚Üî Humano.",
      "metrics": {
        "latency": "Lat√™ncia p99",
        "tokenReduction": "Redu√ß√£o de Tokens",
        "complianceRules": "Compliance Rules",
        "durability": "Durabilidade"
      },
      "problem": {
        "title": "O Problema",
        "intro": "Chatbots enterprise precisam de mem√≥ria de contexto. Quando um cliente retorna dias depois, o bot precisa lembrar conversas anteriores, prefer√™ncias e hist√≥rico de atendimentos.",
        "tokensCost": "Tokens s√£o caros",
        "tokensCostDesc": "Injetar todo o hist√≥rico no prompt explode os custos",
        "latencyKillsUx": "Lat√™ncia mata UX",
        "latencyKillsUxDesc": "Busca em banco relacional adiciona 200-500ms",
        "complianceMandatory": "Compliance obrigat√≥rio",
        "complianceMandatoryDesc": "LGPD, CFM, CFO t√™m regras r√≠gidas de reten√ß√£o",
        "handoverComplicates": "Handover complica",
        "handoverComplicatesDesc": "AI precisa saber o que aconteceu quando humano atendeu"
      },
      "solution": {
        "title": "A Solu√ß√£o",
        "hotWarmCold": {
          "title": "Arquitetura Hot/Warm/Cold",
          "intro": "Sistema de armazenamento em 3 tiers com estrat√©gia Write-Through:",
          "hot": "HOT",
          "hotDesc": "Redis ¬∑ TTL 1min",
          "hotLatency": "<10ms lat√™ncia",
          "warm": "WARM",
          "warmDesc": "Redis ¬∑ TTL 1h",
          "warmLatency": "<50ms lat√™ncia",
          "cold": "COLD",
          "coldDesc": "PostgreSQL",
          "coldLatency": "~100ms ¬∑ Permanente",
          "writeThrough": "Write-Through",
          "writeThroughDesc": "Toda escrita vai primeiro para PostgreSQL (durabilidade garantida), depois replica para Redis (performance)."
        },
        "customerFacts": {
          "title": "Customer Facts Temporais",
          "intro": "Em vez de armazenar conversas brutas, extra√≠mos fatos estruturados com janela de validade temporal:",
          "footer": "Hist√≥rico temporal completo para auditoria. Consulta O(1) para fatos atuais via √≠ndice parcial."
        },
        "semanticCompression": {
          "title": "Compress√£o Sem√¢ntica com LLM",
          "intro": "Conversas longas s√£o comprimidas usando OpenAI com templates verticais espec√≠ficos (dental, m√©dico, jur√≠dico):",
          "preserves": "Preserva",
          "preservesDesc": "Fatos cr√≠ticos, decis√µes, pr√≥ximos passos",
          "removes": "Remove",
          "removesDesc": "Sauda√ß√µes, confirma√ß√µes redundantes, detalhes operacionais",
          "result": "Resultado",
          "resultDesc": "90% redu√ß√£o com 100% preserva√ß√£o de informa√ß√£o relevante"
        },
        "compliance": {
          "title": "Compliance Autom√°tico",
          "intro": "Classifica√ß√£o e tratamento autom√°tico baseado no vertical:",
          "lgpd": "LGPD",
          "lgpdDesc": "Brasil",
          "hipaa": "HIPAA",
          "hipaaDesc": "EUA - Sa√∫de",
          "cfo": "CFO",
          "cfoDesc": "Odontologia",
          "cfm": "CFM",
          "cfmDesc": "Medicina",
          "oab": "OAB",
          "oabDesc": "Advocacia",
          "gdpr": "GDPR",
          "gdprDesc": "Europa",
          "footer": "Anonimiza√ß√£o inteligente: CPF -> ***.***.***.00 | Email -> ***{'@'}domain.com"
        },
        "handover": {
          "title": "Handover Summary",
          "intro": "Continuidade perfeita quando atendente humano interv√©m:",
          "step1": "Mensagens do operador ‚Üí Buffer Redis (hot path)",
          "step2": "Encerramento ‚Üí Celery worker gera resumo com OpenAI",
          "step3": "AI retoma ‚Üí Recebe resumo estruturado injetado no contexto"
        }
      },
      "architecture": {
        "title": "Arquitetura",
        "lastMsg": "√öltima msg",
        "activeSession": "Sess√£o Ativa",
        "completeHistory": "Hist√≥rico Completo",
        "writeThroughStrategy": "Write-Through Strategy",
        "sourceOfTruth": "(PostgreSQL = Source of Truth)",
        "contextComposer": "CONTEXT COMPOSER v2",
        "factsLogic": "Facts (L√≥gica)",
        "summaryLanguage": "Summary (Linguagem)",
        "recentChat": "Recent (Chat)",
        "lastMsgs": "[√∫ltimas 5 msgs]"
      },
      "decisions": {
        "title": "Decis√µes T√©cnicas",
        "writeThrough": {
          "question": "Por que Write-Through e n√£o Write-Behind?",
          "answer": "Write-Behind (async write to DB) √© mais perform√°tico mas arriscado. Em atendimento ao cliente, perder uma mensagem √© inaceit√°vel. Write-Through garante durabilidade imediata com performance aceit√°vel."
        },
        "schemaIsolation": {
          "question": "Por que schema isolation e n√£o row-level security?",
          "answer": "RLS adiciona overhead em cada query. Com schemas separados (t_{tenant_id}), o isolamento √© f√≠sico e a performance √© m√°xima. Trade-off: mais complexidade operacional."
        },
        "temporalFacts": {
          "question": "Por que Customer Facts temporais?",
          "answer": "LLMs s√£o p√©ssimos em \"esquecer\". Se o cliente mudou de prefer√™ncia, o modelo com hist√≥rico completo continuaria usando a prefer√™ncia antiga. Facts temporais com valid_at/invalid_at resolvem isso elegantemente."
        },
        "factsSummary": {
          "question": "Por que separar Facts vs Summary no Context Composer?",
          "answer": "Facts s√£o para l√≥gica (o sistema usa para tomar decis√µes). Summary √© para linguagem (o LLM usa para gerar respostas naturais). Essa separa√ß√£o evita que o LLM \"alucine\" sobre dados estruturados."
        }
      },
      "nextProject": "Pr√≥ximo: AI Conversation Engine ‚Üí"
    },
    "backend": {
      "badge": "Gateway Inteligente",
      "title": "Backend Orchestrator",
      "description": "Gateway enterprise multi-tenant com rate limiting distribu√≠do, circuit breaker, handover dual-mode (operator + AI-initiated), WebSocket real-time e fail-closed resilience.",
      "metrics": {
        "gatewayLatency": "Gateway Latency",
        "reqPerMinTenant": "Req/min/tenant",
        "retryStrategies": "Retry Strategies",
        "uptime": "Uptime"
      },
      "problem": {
        "title": "O Problema",
        "intro": "Em sistemas de atendimento multi-tenant, o gateway √© o ponto cr√≠tico de falha. Problemas comuns:",
        "noisyNeighbor": "Noisy Neighbor",
        "noisyNeighborDesc": "Um tenant com tr√°fego alto derruba todos os outros",
        "cascadingFailures": "Cascading Failures",
        "cascadingFailuresDesc": "AI Engine lento bloqueia todo o sistema",
        "handoverChaos": "Handover Chaos",
        "handoverChaosDesc": "AI responde quando humano est√° atendendo",
        "idempotencyBugs": "Idempotency Bugs",
        "idempotencyBugsDesc": "Mesma mensagem processada m√∫ltiplas vezes",
        "frontendDesync": "Frontend Desync",
        "frontendDesyncDesc": "UI n√£o reflete estado real das conversas"
      },
      "solution": {
        "title": "A Solu√ß√£o",
        "rateLimiting": {
          "title": "Enterprise Rate Limiting",
          "intro": "Sistema de rate limiting multi-camada com algoritmos adaptativos:",
          "slidingWindow": "Sliding Window",
          "slidingWindowDesc": "Precis√£o temporal com Redis ZSET",
          "tokenBucket": "Token Bucket",
          "tokenBucketDesc": "Burst handling com Lua scripts at√¥micos",
          "localFallback": "Local Fallback",
          "localFallbackDesc": "Cache local quando Redis indispon√≠vel",
          "tenantTiers": "Tenant Tiers",
          "tenantTiersDesc": "FREE (10 req/min) ‚Üí BASIC (50) ‚Üí PROFESSIONAL (200) ‚Üí ENTERPRISE (unlimited)"
        },
        "circuitBreaker": {
          "title": "Circuit Breaker Pattern",
          "intro": "Prote√ß√£o contra cascading failures com 3 estados:",
          "closed": "CLOSED",
          "open": "OPEN",
          "halfOpen": "HALF_OPEN",
          "failureThreshold": "failure_threshold",
          "failureThresholdDesc": "5 falhas consecutivas abrem o circuito",
          "recoveryTimeout": "recovery_timeout",
          "recoveryTimeoutDesc": "60s antes de testar novamente",
          "halfOpenMaxCalls": "half_open_max_calls",
          "halfOpenMaxCallsDesc": "10 requests de teste antes de fechar"
        },
        "handover": {
          "title": "Handover Dual-Mode",
          "intro": "Dois modos de transi√ß√£o AI ‚Üî Humano:",
          "operatorTakeover": "Operator Takeover",
          "operatorTakeoverList": [
            "Operador clica \"assumir conversa\"",
            "Redis latch bloqueia AI instantaneamente",
            "Timer auto-resume configur√°vel por tenant",
            "Lazy finalize: summary gerado ao retomar"
          ],
          "aiInitiated": "AI-Initiated",
          "aiInitiatedList": [
            "AI detecta problema (ERP failure, complexidade)",
            "Context injection com prioridade m√°xima",
            "Mensagem natural para cliente",
            "Hist√≥rico multi-handover preservado"
          ]
        },
        "failClosed": {
          "title": "Fail-Closed Resilience",
          "intro": "Quando Redis est√° indispon√≠vel, o sistema bloqueia AI (n√£o fica silencioso):",
          "comment": "# Fail-closed",
          "customerReceives": "# Cliente recebe: \"Um momento, estamos te transferindo...\"",
          "notSilent": "# N√ÉO: sil√™ncio total (fail-open)",
          "retryStrategy": "Retry Strategy",
          "retryStrategyDesc": "3 tentativas com exponential backoff (50ms base) + jitter aleat√≥rio"
        },
        "websocket": {
          "title": "WebSocket Real-Time",
          "intro": "Broadcasting de eventos para sincroniza√ß√£o frontend:",
          "conversationUpdate": "conversation_update",
          "conversationUpdateDesc": "Nova conversa ou mudan√ßa de status",
          "newMessage": "new_message",
          "newMessageDesc": "Mensagem cliente/AI normalizada",
          "operatorMessage": "operator_message",
          "operatorMessageDesc": "Mensagem do operador (WhatsApp/Web)",
          "cacheInvalidation": "cache_invalidation",
          "cacheInvalidationDesc": "Trigger de refetch no frontend"
        },
        "idempotency": {
          "title": "Idempotency Gate",
          "intro": "Prote√ß√£o contra processamento duplicado:",
          "step1": "Request chega com",
          "step2": "Check Redis: j√° processado? ‚Üí retorna cached response",
          "step3": "Slot reservado ‚Üí processa request",
          "step4": "Response cacheada com TTL de 24h"
        }
      },
      "architecture": {
        "title": "Arquitetura",
        "gatewayEnterprise": "(Gateway Enterprise)",
        "rateLimiter": "Rate Limiter",
        "multiTier": "(Multi-tier)",
        "circuitBreaker": "Circuit Breaker",
        "threeStates": "(3 states)",
        "handoverGate": "Handover Gate",
        "failClosed": "(Fail-closed)",
        "chatOrchestrator": "Chat Orchestrator",
        "idempotency": "+ Idempotency",
        "aiEngine": "AI Engine",
        "langGraph": "(LangGraph)",
        "memoryEngine": "Memory Engine",
        "postgresql": "(PostgreSQL)",
        "websocketBroadcast": "WebSocket Broadcast",
        "requestFlow": "Request Flow:",
        "step1": "1. Rate Limit Check (per-tenant tier)",
        "step2": "2. Circuit Breaker (protect downstream)",
        "step3": "3. Handover Gate (AI blocking)",
        "step4": "4. Idempotency Check (dedupe)",
        "step5": "5. AI Engine Call (with timeout)",
        "step6": "6. WebSocket Broadcast (real-time)",
        "step7": "7. Cache Response (24h TTL)"
      },
      "decisions": {
        "title": "Decis√µes T√©cnicas",
        "failClosed": {
          "question": "Por que fail-closed e n√£o fail-open?",
          "answer": "Em atendimento ao cliente, sil√™ncio √© pior que resposta de fallback. Fail-closed garante que o cliente sempre receba feedback (\"estamos te transferindo\") mesmo quando Redis est√° indispon√≠vel. Fail-open deixaria o cliente esperando indefinidamente."
        },
        "redisLatch": {
          "question": "Por que Redis latch e n√£o database flag?",
          "answer": "Redis latch com TTL autom√°tico elimina a necessidade de cleanup workers. Se o operador esquecer de \"devolver\" a conversa, o TTL expira e AI retoma automaticamente. Database flags precisariam de cron jobs para timeout."
        },
        "slidingWindow": {
          "question": "Por que sliding window e n√£o fixed window?",
          "answer": "Fixed window tem o problema de \"boundary burst\": 100 requests no segundo 59 + 100 no segundo 0 = 200 requests em 2 segundos. Sliding window distribui uniformemente e evita esse pico."
        },
        "luaScripts": {
          "question": "Por que Lua scripts para token bucket?",
          "answer": "Token bucket precisa de opera√ß√µes at√¥micas (read-modify-write). Sem Lua, ter√≠amos race conditions entre GET e SET. Lua scripts executam atomicamente no servidor Redis, garantindo consist√™ncia mesmo com milhares de requests concorrentes."
        }
      },
      "nextProject": "Pr√≥ximo: Memory Engine ‚Üí"
    },
    "rules": {
      "badge": "Optimus Platform",
      "badgeSecondary": "Business Intelligence",
      "title": "Rules Engine",
      "description": "Motor de regras Python-native que elimina o overhead interpretado do JSONLogic. Avalia√ß√£o em sub-millisegundo, regras criadas em runtime por tenant, type safety completo.",
      "tags": {
        "pythonLambda": "Python Lambda",
        "subMillisecond": "Sub-millisecond",
        "multiTenant": "Multi-tenant",
        "eventDriven": "Event-driven",
        "typeSafe": "Type Safe",
        "cacheCoherence": "Cache Coherence"
      },
      "problem": {
        "title": "O Problema: Por que JSONLogic n√£o escala",
        "jsonLogicTrap": "JSONLogic - A Armadilha",
        "simpleRule": "// Regra \"simples\" em JSONLogic",
        "issues": {
          "interpreted": "Interpretado recursivamente",
          "interpretedDesc": "cada operador √© uma chamada de fun√ß√£o aninhada",
          "limitedOps": "Operadores limitados",
          "limitedOpsDesc": "s√≥ suporta {'<'}, {'>'}, ==, in, and, or",
          "noTypeCheck": "Sem type checking",
          "noTypeCheckDesc": "erros s√≥ aparecem em runtime",
          "debugImpossible": "Debug imposs√≠vel",
          "debugImpossibleDesc": "stack traces incompreens√≠veis",
          "slowPerf": "~50-200ms",
          "slowPerfDesc": "para avaliar 100 regras complexas"
        },
        "pythonNativeSolution": "Python-Native - A Solu√ß√£o",
        "sameRule": "# Mesma regra em Python-native",
        "benefits": {
          "compiledOnce": "Compilado uma vez",
          "compiledOnceDesc": "bytecode Python nativo",
          "fullPower": "Full Python power",
          "fullPowerDesc": "regex, datetime, math, tudo",
          "typeHints": "Type hints + mypy",
          "typeHintsDesc": "erros antes do deploy",
          "normalDebug": "Debug normal",
          "normalDebugDesc": "pdb, breakpoints, stack traces",
          "fastPerf": "<0.5ms",
          "fastPerfDesc": "para avaliar 100 regras - 1000x mais r√°pido"
        },
        "benchmark": {
          "title": "Benchmark Real: JSONLogic vs Python-Native",
          "jsonLogic": "JSONLogic (100 regras)",
          "pythonNative": "Python-Native (100 regras)",
          "fasterCold": "Mais r√°pido (cold)",
          "fasterCached": "Mais r√°pido (cached)"
        }
      },
      "architecture": {
        "title": "Arquitetura: Rules Engine + Coordinator",
        "requestFlow": "Request Flow (sub-ms target)",
        "clientRequest": "Client Request",
        "backendOrchestrator": "Backend Orchestrator",
        "rulesCoordinator": "Rules Coordinator",
        "cacheFallback": "(Cache + Fallback)",
        "rulesEngine": "Rules Engine",
        "port": "(Port 8040)",
        "redisCache": "Redis Cache",
        "ttl15min": "(15 min)",
        "postgresql": "PostgreSQL",
        "rulesDb": "(Rules DB)",
        "fallbackHierarchy": "Fallback Hierarchy (never fails)",
        "primary": "1. Rules Engine API ‚Üí Primary (target <50ms)",
        "secondary": "2. Redis Cache      ‚Üí Secondary (target <5ms)",
        "basic": "3. Basic Fallback   ‚Üí Always available (keyword-based)",
        "components": {
          "rulesEngine": {
            "title": "Rules Engine",
            "desc": "Microsservi√ßo dedicado que compila e executa regras Python-native. Cada tenant tem suas pr√≥prias regras isoladas.",
            "items": [
              "Compila√ß√£o de lambdas Python",
              "Sandboxing de execu√ß√£o",
              "M√©tricas por regra",
              "Multi-vertical support"
            ]
          },
          "rulesCoordinator": {
            "title": "Rules Coordinator",
            "desc": "Proxy inteligente no Backend Orchestrator com cache, circuit breaker e fallback multi-tier.",
            "items": [
              "Cache de avalia√ß√µes (15min TTL)",
              "Memory context enrichment",
              "Circuit breaker protection",
              "Graceful degradation"
            ]
          },
          "contextEnrichment": {
            "title": "Context Enrichment",
            "desc": "Integra√ß√£o com Memory Engine para enriquecer fatos com contexto hist√≥rico do cliente.",
            "items": [
              "Frequ√™ncia de intera√ß√£o",
              "N√≠vel de urg√™ncia detectado",
              "Indicadores de dor/emerg√™ncia",
              "Padr√µes inteligentes"
            ]
          }
        }
      },
      "runtimeCreation": {
        "title": "Runtime Rule Creation: Cada Neg√≥cio √© √önico",
        "intro": "O grande diferencial do Rules Engine √© permitir que cada tenant crie suas pr√≥prias regras em tempo real, sem deploy, sem downtime, sem c√≥digo.",
        "apiTitle": "API de Cria√ß√£o de Regras",
        "examples": {
          "dental": {
            "title": "ü¶∑ Regra Dental",
            "desc": "Lembrete de limpeza baseado em √∫ltima visita + status do seguro. Se passou 6 meses e tem cobertura ‚Üí agenda preventiva."
          },
          "ecommerce": {
            "title": "üõí Regra E-commerce",
            "desc": "Carrinho abandonado h√° 2h + valor > R$200 + cliente recorrente ‚Üí oferta de 10% desconto + frete gr√°tis."
          },
          "legal": {
            "title": "‚öñÔ∏è Regra Legal",
            "desc": "Prazo processual em 48h + cliente n√£o respondeu √∫ltima mensagem ‚Üí alerta urgente + escala√ß√£o para advogado respons√°vel."
          }
        },
        "multiTenant": {
          "title": "üîí Isolamento Multi-tenant Completo",
          "clinic": {
            "name": "Cl√≠nica ABC",
            "rules": "47 regras ativas",
            "vertical": "Vertical: dental",
            "focus": "Foco: agendamento"
          },
          "store": {
            "name": "Loja XYZ",
            "rules": "89 regras ativas",
            "vertical": "Vertical: e-commerce",
            "focus": "Foco: convers√£o"
          },
          "law": {
            "name": "Advocacia 123",
            "rules": "23 regras ativas",
            "vertical": "Vertical: legal",
            "focus": "Foco: prazos"
          },
          "footer": "Cada tenant tem regras completamente isoladas. Nenhuma regra da Cl√≠nica ABC afeta a Loja XYZ. Zero vazamento de l√≥gica de neg√≥cio entre clientes."
        }
      },
      "deepDive": {
        "title": "Deep Dive: Como Funciona",
        "coordinator": {
          "title": "Rules Coordinator: Cache + Fallback Inteligente",
          "docstring": "üéØ Coordenador Central de Regras",
          "responsibilities": [
            "1. Proxy inteligente para Rules Engine com <50ms target",
            "2. Cache Redis para performance otimizada",
            "3. Integra√ß√£o com Memory Coordinator para contexto enriquecido",
            "4. Fallback quando Rules Engine falha",
            "5. Circuit breaker para prote√ß√£o contra falhas"
          ],
          "comment1": "# 1. üß† Enriquecer dados com Memory Coordinator",
          "comment2": "# 2. üéØ Tentar Rules Engine (primary)",
          "comment3": "# Cache para reuso futuro",
          "comment4": "# 3. üîÑ Fallback para Redis cache",
          "comment5": "# 4. üö® Basic fallback (keyword-based, nunca falha)"
        },
        "enrichment": {
          "title": "Context Enrichment: Regras com Contexto Hist√≥rico",
          "docstring": "Extrai padr√µes inteligentes do contexto de mem√≥ria para regras mais sofisticadas",
          "comments": {
            "detectsUrgency": "# Detecta urg√™ncia (dor, emerg√™ncia, sangramento)",
            "detectsScheduling": "# Detecta necessidade de agendamento",
            "analyzesFrequency": "# Analisa frequ√™ncia de intera√ß√£o",
            "result": "# Resultado: regras podem usar facts enriquecidos"
          }
        },
        "eventTypes": {
          "title": "Event-Driven: Triggers Autom√°ticos",
          "messageReceived": "message_received",
          "messageReceivedDesc": "Nova mensagem do cliente",
          "conversationStarted": "conversation_started",
          "conversationStartedDesc": "In√≠cio de conversa",
          "handoverCompleted": "handover_completed",
          "handoverCompletedDesc": "Atendente finalizou",
          "appointmentScheduled": "appointment_scheduled",
          "appointmentScheduledDesc": "Agendamento confirmado",
          "cartAbandoned": "cart_abandoned",
          "cartAbandonedDesc": "Carrinho abandonado",
          "deadlineApproaching": "deadline_approaching",
          "deadlineApproachingDesc": "Prazo se aproximando",
          "sentimentNegative": "sentiment_negative",
          "sentimentNegativeDesc": "Cliente insatisfeito",
          "timeBased": "time_based",
          "timeBasedDesc": "Trigger por hor√°rio"
        }
      },
      "results": {
        "title": "Resultados: Regras que Escalam",
        "latencyP95": "Lat√™ncia P95",
        "latencyP95Desc": "Target de performance",
        "vsJsonLogic": "vs JSONLogic",
        "vsJsonLogicDesc": "Com cache aquecido",
        "rulesInProduction": "Regras em Produ√ß√£o",
        "rulesInProductionDesc": "Dental + E-commerce + Medical",
        "evaluationUptime": "Uptime Avalia√ß√£o",
        "evaluationUptimeDesc": "Fallback nunca falha",
        "decisions": {
          "title": "üí° Decis√µes T√©cnicas Chave",
          "pythonLambda": {
            "title": "Python Lambda vs DSL Customizada",
            "desc": "Consideramos criar uma DSL (Domain-Specific Language) para regras, mas decidimos usar Python lambda diretamente. Raz√£o: desenvolvedores j√° conhecem Python, debugging normal, type hints funcionam, ecosystem inteiro dispon√≠vel. O sandboxing √© feito via AST parsing + restricted builtins."
          },
          "cache15min": {
            "title": "Cache de 15 minutos (n√£o infinito)",
            "desc": "Regras s√£o cacheadas por 15 minutos, n√£o infinitamente. Isso permite que altera√ß√µes em regras (via API) sejam refletidas em tempo razo√°vel sem necessidade de invalida√ß√£o manual. O tradeoff entre performance e freshness foi calibrado em produ√ß√£o."
          },
          "keywordFallback": {
            "title": "Fallback Keyword-Based (Sempre Funciona)",
            "desc": "O √∫ltimo n√≠vel de fallback usa an√°lise simples de keywords. N√£o √© sofisticado, mas garante que o sistema NUNCA falha em avaliar uma mensagem. \"Dor\" ‚Üí urg√™ncia, \"agendar\" ‚Üí appointment. Simples, mas funcional como √∫ltimo recurso."
          },
          "separateMicroservice": {
            "title": "Microsservi√ßo Separado (n√£o library)",
            "desc": "Rules Engine √© um microsservi√ßo independente, n√£o uma library importada. Isso permite escalar horizontalmente, deploy independente, e isolamento de falhas. Se o Rules Engine crashar, o Coordinator usa cache/fallback."
          }
        }
      },
      "technicalStack": {
        "title": "Stack T√©cnico",
        "runtime": "Runtime",
        "runtimeDesc": "Python 3.11+ (bytecode optimized)",
        "framework": "Framework",
        "frameworkDesc": "FastAPI + Pydantic",
        "cache": "Cache",
        "cacheDesc": "Redis (cache + pub/sub)",
        "storage": "Storage",
        "storageDesc": "PostgreSQL (rules metadata)",
        "isolation": "Isolation",
        "isolationDesc": "Per-tenant rule namespaces",
        "circuitBreaker": "Circuit Breaker",
        "circuitBreakerDesc": "5 failures ‚Üí 60s recovery",
        "httpClient": "HTTP Client",
        "httpClientDesc": "HTTPX async pooling",
        "metrics": "Metrics",
        "metricsDesc": "Prometheus + per-rule tracking"
      },
      "cta": {
        "title": "Quer discutir mais sobre Rules Engines?",
        "desc": "JSONLogic vs Python-native, DSLs customizadas, ou como fazer regras escalarem - adoro falar sobre esses temas.",
        "contact": "Entrar em Contato"
      },
      "meta": {
        "title": "Rules Engine - Python-Native 1000x mais r√°pido que JSONLogic | Marcelo Marleta",
        "description": "Motor de regras Python-native que elimina JSONLogic. Avalia√ß√£o sub-millisecond, regras em runtime por tenant, type safety completo."
      }
    }
  }
}
